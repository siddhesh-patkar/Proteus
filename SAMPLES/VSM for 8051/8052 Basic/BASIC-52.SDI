,,,;  December 18, 1986
,,,;  MS-DOS compatible Source code for MCS BASIC-52 (tm)
,,,;  Assembles with ASM51 Macro Assembler Version 2.2
,,,;
,,,;  The following source code does not include the floating point math
,,,;  routines. These are seperately compiled using FP52.SRC.
,,,;
,,,;  Both the BASIC.SRC and FP52.SRC programs assemble into ABSOLUTE
,,,;  object files, and do not need to be relocated or linked. The FP52
,,,;  object code and the BASIC object code, when compiled without modification
,,,;  of the source listings, create the same object code that is found on
,,,;  the MCS BASIC-52 Version 1.1 microcontrollers.
,,,;
,,,;  The original source code had 7 "include" files that have been incorporated
,,,;  into this file for ease of assembly.
,,,;  These 7 files are: LOOK52.SRC, BAS52.RST, BAS52.PGM, BAS52.TL, BAS52.OUT,
,,,;  BAS52.PWM, and BAS52.CLK.
,,,;
,,,;
,,,;                       Intel Corporation, Embedded Controller Operations
,,,
,,,$EJECT
,,,        ;**************************************************************
,,,        ;
,,,        ; TRAP VECTORS TO MONITOR
,,,        ;
,,,        ; RESET TAG (0AAH) ---------2001H
,,,        ;
,,,        ; TAG LOCATION (5AH) ------ 2002H
,,,        ;
,,,        ; EXTERNAL INTERRUPT 0 ---- 2040H
,,,        ;
,,,        ; COMMAND MODE ENTRY ------ 2048H
,,,        ;
,,,        ; SERIAL PORT ------------- 2050H
,,,        ;
,,,        ; MONITOR (BUBBLE) OUTPUT - 2058H
,,,        ;
,,,        ; MONITOR (BUBBLE) INPUT -- 2060H
,,,        ;
,,,        ; MONITOR (BUBBLE) CSTS --- 2068H
,,,        ;
,,,        ; GET USER JUMP VECTOR ---- 2070H
,,,        ;
,,,        ; GET USER LOOKUP VECTOR -- 2078H
,,,        ;
,,,        ; PRINT AT VECTOR --------- 2080H
,,,        ;
,,,        ; INTERRUPT PWM ----------- 2088H
,,,        ;
,,,        ; EXTERNAL RESET ---------- 2090H
,,,        ;
,,,        ; USER OUTPUT-------------- 4030H
,,,        ;
,,,        ; USER INPUT -------------- 4033H
,,,        ;
,,,        ; USER CSTS --------------- 4036H
,,,        ;
,,,        ; USER RESET -------------- 4039H
,,,        ;
,,,        ; USER DEFINED PRINT @ ---  403CH
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; MCS - 51  -  8K BASIC VERSION 1.1
,,,        ;
,,,        ;***************************************************************
,,,        ;
0000,61 87,,        AJMP    CRST            ;START THE PROGRAM
,,,        ;
,,,        ORG     3H
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,        ;EXTERNAL INTERRUPT 0
,,,        ;
,,,        ;***************************************************************
,,,        ;
0003,20 31 2D,,        JB      DRQ,STQ         ;SEE IF DMA IS SET
0006,C0 D0,,        PUSH    PSW             ;SAVE THE STATUS
0008,02 40 03,,        LJMP    4003H           ;JUMP TO USER IF NOT SET
,,,        ;
,,,        ORG     0BH
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,        ;TIMER 0 OVERFLOW INTERRUPT
,,,        ;
,,,        ;***************************************************************
,,,        ;
000B,C0 D0,,        PUSH    PSW             ;SAVE THE STATUS
000D,20 2E 10,,        JB      C_BIT,STJ       ;SEE IF USER WANTS INTERRUPT
0010,02 40 0B,,        LJMP    400BH           ;EXIT IF USER WANTS INTERRUPTS
,,,        ;
,,,        ORG     13H
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,        ;EXTERNAL INTERRUPT 1
,,,        ;
,,,        ;***************************************************************
,,,        ;
0013,20 12 2B,,        JB      INTBIT,STK
0016,C0 D0,,        PUSH    PSW
0018,02 40 13,,        LJMP    4013H
,,,        ;
,,,$EJECT
,,,        ;
,,,        ORG     1BH
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,        ;TIMER 1 OVERFLOW INTERRUPT
,,,        ;
,,,        ;***************************************************************
,,,        ;
001B,C0 D0,,        PUSH    PSW
001D,02 1F 78,,        LJMP    CKS_I
,,,        ;
0020,02 19 03,STJ,STJ:    LJMP    I_DR            ;DO THE INTERRUPT
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,        ;SERIAL PORT INTERRUPT
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,        ORG     23H
,,,        ;
0023,C0 D0,,        PUSH    PSW
0025,20 1F 1C,,        JB      SPINT,STU       ;SEE IF MONITOR EANTS INTERRUPT
0028,02 40 23,,        LJMP    4023H
,,,        ;
,,,        ORG     2BH
,,,        ;
,,,        ;**************************************************************
,,,        ;
,,,        ;TIMER 2 OVERFLOW INTERRUPT
,,,        ;
,,,        ;**************************************************************
,,,        ;
002B,C0 D0,,        PUSH    PSW
002D,02 40 2B,,        LJMP    402BH
,,,        ;
,,,$EJECT
,,,        ;**************************************************************
,,,        ;
,,,        ;USER ENTRY
,,,        ;
,,,        ;**************************************************************
,,,        ;
,,,        ORG     30H
,,,        ;
0030,02 19 3D,,        LJMP    IBLK            ;LINK TO USER BLOCK
,,,        ;
0033,20 26 08,STQ,STQ:    JB      I_T0,STS        ;SEE IF MONITOR WANTS IT
0036,C2 96,,        CLR     DACK
0038,30 B2 FD,,        JNB     P3.2,$          ;WAIT FOR DMA TO END
003B,D2 96,,        SETB    DACK
003D,32,,        RETI
,,,        ;
003E,02 20 40,STS,STS:    LJMP    2040H           ;GO TO THE MONITOR
,,,        ;
0041,D2 16,STK,STK:    SETB    INTPEN          ;TELL BASIC AN INTERRUPT WAS RECEIVED
0043,32,,        RETI
,,,        ;
0044,02 20 50,STU,STU:    LJMP    2050H           ;SERIAL PORT INTERRUPT
,,,        ;
,,,$EJECT
,,,
,,,;$INCLUDE(:F2:LOOK52.SRC)
,,,; INCLUDED BELOW
,,,
,,,        ;
,,,        ;**************************************************************
,,,        ;
,,,        ; This is the equate table for 8052 basic.
,,,        ;
,,,        ;**************************************************************
,,,        ;
,,,        ; The register to direct equates for CJNE instructions.
,,,        ;
,,,R0B0    EQU     0
,,,R1B0    EQU     1
,,,R2B0    EQU     2
,,,R3B0    EQU     3
,,,R4B0    EQU     4
,,,R5B0    EQU     5
,,,R6B0    EQU     6
,,,R7B0    EQU     7
,,,        ;
,,,        ; Register bank 1 contains the text pointer
,,,        ; and the arg stack pointer.
,,,        ;
,,,TXAL    EQU     8               ;R0 BANK 1 = TEXT POINTER LOW
,,,ASTKA   EQU     9               ;R1 BANK 1 = ARG STACK
,,,TXAH    EQU     10              ;R2 BANK 1 = TEXT POINTER HIGH
,,,        ;
,,,        ; Now five temporary locations that are used by basic.
,,,        ;
,,,TEMP1   EQU     11
,,,TEMP2   EQU     12
,,,TEMP3   EQU     13
,,,TEMP4   EQU     14
,,,TEMP5   EQU     15
,,,        ;
,,,$EJECT
,,,        ; Register bank 2 contains the read text pointer
,,,        ; and the control stack pointer.
,,,        ;
,,,RTXAL   EQU     16              ;R0 BANK 2 = READ TEXT POINTER LOW
,,,CSTKA   EQU     17              ;R1 BANK 2 = CONTROL STACK POINTER
,,,RTXAH   EQU     18              ;R2 BANK 2 = READ TEXT POINTER HIGH
,,,        ;
,,,        ; Now some internal system equates.
,,,        ;
,,,BOFAH   EQU     19              ;START OF THE BASIC PROGRAM, HIGH BYTE
,,,BOFAL   EQU     20              ;START OF THE BASIC PROGRAM, LOW BYTE
,,,NULLCT  EQU     21              ;NULL COUNT
,,,PHEAD   EQU     22              ;PRINT HEAD POSITION
,,,FORMAT  EQU     23
,,,        ;
,,,        ; Register bank 3 is for the user and can be loaded
,,,        ; by basic
,,,        ;
,,,        ;
,,,        ;
,,,        ; Now everything else is used by basic.
,,,        ; First the bit locations, these use bytes 34, 35, 36, 37 and 38
,,,        ;
,,,$EJECT
,,,OTS             BIT     16      ;34.0-ON TIME INSTRUCTION EXECUTED
,,,INPROG          BIT     17      ;34.1-INTERRUPT IN PROCESS
,,,INTBIT          BIT     18      ;34.2-INTERRUPT SET BIT
,,,ON_ERR          BIT     19      ;34.3-ON ERROR EXECUTED
,,,OTI             BIT     20      ;34.4-ON TIME INTERRUPT IN PROGRESS
,,,LINEB           BIT     21      ;34.5-LINE CHANGE OCCURED
,,,INTPEN          BIT     22      ;34.6-INTERRUPT PENDING BIT
,,,CONB            BIT     23      ;34.7-CAN CONTINUE IF SET
,,,GTRD            BIT     24      ;35.0-READ GET LOCATION
,,,LPB             BIT     25      ;35.1-PRINT TO LINE PRINTER PORT
,,,CKS_B           BIT     26      ;35.2-FOR PWM INTERRUPT
,,,COB             BIT     27      ;35.3-CONSOLE OUT BIT
,,,                                ;     0 = SERIAL PORT
,,,                                ;     1 = LINE PRINTER
,,,COUB            BIT     28      ;35.4-USER CONSOLE OUT BIT
,,,                                ;     0 = SERIAL PORT
,,,                                ;     1 = USER DRIVER
,,,INBIT           BIT     29      ;35.5-INITIALIZATION BIT
,,,CIUB            BIT     30      ;35.6-USER CONSOLE IN BIT
,,,                                ;     0 = SERIAL PORT
,,,                                ;     1 = USER ROUTINE
,,,SPINT           BIT     31      ;35.7-SERIAL PORT INTERRUPT
,,,STOPBIT         BIT     32      ;36.0-PROGRAM STOP ENCOUNTERED
,,,U_IDL           BIT     33      ;36.1-USER IDLE BREAK
,,,INP_B           BIT     34      ;36.2-SET DURING INPUT INSTRUCTION
,,,;DCMPXZ         BIT     35      ;36.3-DCMPX ZERO FLAG
,,,ARGF            BIT     36      ;36.4-ARG STACK HAS A VALUE
,,,RETBIT          BIT     37      ;36.5-RET FROM INTERRUPT EXECUTED
,,,I_T0            BIT     38      ;36.6-TRAP INTERRUPT ZERO TO MON
,,,UPB             BIT     39      ;36.7-SET WHEN @ IS VALID
,,,JKBIT           BIT     40      ;37.0-WB TRIGGER
,,,ENDBIT          BIT     41      ;37.1-GET END OF PROGRAM
,,,UBIT            BIT     42      ;37.2-FOR DIM STATEMENT
,,,ISAV            BIT     43      ;37.3-SAVE INTERRUPT STATUS
,,,BO              BIT     44      ;37.4-BUBBLE OUTPUT
,,,XBIT            BIT     45      ;37.5-EXTERNAL PROGRAM PRESENT
,,,C_BIT           BIT     46      ;37.6-SET WHEN CLOCK RUNNING
,,,DIRF            BIT     47      ;37.7-DIRECT INPUT MODE
,,,NO_C            BIT     48      ;38.0-NO CONTROL C
,,,DRQ             BIT     49      ;38.1-DMA ENABLED
,,,BI              BIT     50      ;38.2-BUBBLE INPUT
,,,INTELB          BIT     51      ;38.3-INTELLIGENT PROM PROGRAMMING
,,,C0ORX1          BIT     52      ;38.4-PRINT FROM ROM OR RAM
,,,CNT_S           BIT     53      ;38.5-CONTROL S ENCOUNTERED
,,,ZSURP           BIT     54      ;38.6-ZERO SUPRESS
,,,HMODE           BIT     55      ;38.7-HEX MODE PRINT
000B,,,LP              BIT     P1.7    ;SOFTWARE LINE PRINTER
000B,,,DACK            BIT     P1.6    ;DMA ACK
000B,,,PROMV           BIT     P1.5    ;TURN ON PROM VOLTAGE
000B,,,PROMP           BIT     P1.4    ;PROM PULSE
000B,,,ALED            BIT     P1.3    ;ALE DISABLE
000B,,,T_BIT           BIT     P1.2    ;I/O TOGGLE BIT
,,,        ;
,,,$EJECT
,,,        ;
,,,        ; The next location is a bit addressable byte counter
,,,        ;
,,,BABC    EQU     39
,,,        ;
,,,        ; Now floating point and the other temps
,,,        ;
,,,        ; FP Uses to locations 03CH
,,,        ;
,,,        ; Now the stack designators.
,,,        ;
,,,SPSAV   EQU     3EH
,,,S_LEN   EQU     3FH
,,,T_HH    EQU     40H
,,,T_LL    EQU     41H
,,,INTXAH  EQU     42H
,,,INTXAL  EQU     43H
,,,MT1     EQU     45H
,,,MT2     EQU     46H
,,,MILLIV  EQU     47H             ;TIMER LOCATIONS
,,,TVH     EQU     48H
,,,TVL     EQU     49H
,,,SAVE_T  EQU     4AH
,,,SP_H    EQU     4BH             ;SERIAL PORT TIME OUT
,,,SP_L    EQU     4CH
,,,CMNDSP  EQU     4DH             ;SYSTEM STACK POINTER
,,,IRAMTOP EQU     0FFH            ;TOP OF RAM
,,,STACKTP EQU     0FEH            ;ARG AND CONTROL STACK TOPS
,,,        ;
,,,        ; The character equates
,,,        ;
,,,CR      EQU     0DH             ;CARRIAGE RETURN
,,,LF      EQU     0AH             ;LINE FEED
,,,BELL    EQU     07H             ;BELL CHARACTER
,,,BS      EQU     08H             ;BACK SPACE
,,,CNTRLC  EQU     03H             ;CONTROL C
,,,CNTRLD  EQU     04H             ;CONTROL D
,,,NULL    EQU     00H             ;NULL
,,,        ;
,,,$EJECT
,,,        ;
,,,        ; The internal system equates
,,,        ;
,,,LINLEN  EQU     73              ;THE LENGTH OF AN INPUT LINE
,,,EOF     EQU     01              ;END OF FILE CHARACTER
,,,ASTKAH  EQU     01              ;ASTKA IS IN PAGE 1 OF RAM
,,,CSTKAH  EQU     00              ;CSTKA IS IN PAGE 0 OF RAM
,,,FTYPE   EQU     01              ;CONTROL STACK "FOR"
,,,GTYPE   EQU     02              ;CONTROL STACK "GOSUB"
,,,DTYPE   EQU     03              ;DO-WHILE/UNTIL TYPE
,,,ROMADR  EQU     8000H           ;LOCATION OF ROM
,,,        ;
,,,        ; The floating point equates
,,,        ;
,,,FPSIZ   EQU     6               ;NO. OF BYTES IN A FLOATING NUM
,,,DIGIT   EQU     FPSIZ-2         ;THE MANTISSA OF A FLOATING NUM
,,,STESIZ  EQU     FPSIZ+3         ;SIZE OF SYMBOL ADJUSTED TABLE ELEMENT
,,,FP_BASE EQU     1993H           ;BASE OF FLOATING POINT ROUTINES
,,,PSTART  EQU     512             ;START OF A PROGRAM IN RAM
,,,FSIZE   EQU     FPSIZ+FPSIZ+2+2+1
,,,        ;
,,,$EJECT
,,,        ;**************************************************************
,,,        ;
0047,,USENT,USENT:  ; User entry jump table
,,,        ;
,,,        ;**************************************************************
,,,        ;
0047,17 85,,        DW      CMND1           ;(00, 00H)COMMAND MODE JUMP
0049,12 15,,        DW      IFIX            ;(01, 01H)CONVERT FP TO INT
004B,0F E6,,        DW      PUSHAS          ;(02, 02H)PUSH VALUE ONTO ARG STACK
004D,0F DC,,        DW      POPAS           ;(03, 03H)POP VALUE OFF ARG STACK
004F,04 95,,        DW      PG1             ;(04, 04H)PROGRAM A PROM
0051,06 D0,,        DW      INLINE          ;(05, 05H)INPUT A LINE
0053,06 B7,,        DW      UPRNT           ;(06, 06H)PRINT A LINR
0055,06 9D,,        DW      CRLF            ;(07, 07H)OUTPUT A CRLF
,,,        ;
,,,        ;**************************************************************
,,,        ;
,,,        ; This is the operation jump table for arithmetics
,,,        ;
,,,        ;**************************************************************
,,,        ;
0057,13 9E,OPTAB,OPTAB:  DW      ALPAR           ;(08, 08H)LEFT PAREN
0059,13 1D,,        DW      AEXP            ;(09, 09H)EXPONENTAION
005B,11 A2,,        DW      AMUL            ;(10, 0AH)FP MUL
005D,17 3F,,        DW      AADD            ;(11, 0BH)FLOATING POINT ADD
005F,13 FC,,        DW      ADIV            ;(12, 0CH)FLOATING POINT DIVIDE
0061,17 1A,,        DW      ASUB            ;(13, 0DH)FLOATING POINT SUBTRACTION
0063,14 8A,,        DW      AXRL            ;(14, 0EH)XOR
0065,14 76,,        DW      AANL            ;(15, 0FH)AND
0067,14 7F,,        DW      AORL            ;(16, 10H)OR
0069,13 93,,        DW      ANEG            ;(17, 11H)NEGATE
006B,13 CD,,        DW      AEQ             ;(18, 12H)EQUAL
006D,13 D9,,        DW      AGE             ;(19, 13H)GREATER THAN OR EQUAL
006F,13 DD,,        DW      ALE             ;(20, 14H)LESS THAN OR EQUAL
0071,13 D3,,        DW      ANE             ;(21, 15H)NOT EQUAL
0073,13 C8,,        DW      ALT             ;(22, 16H)LESS THAN
0075,13 B7,,        DW      AGT             ;(23, 17H)GREATER THAN
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; This is the jump table for unary operators
,,,        ;
,,,        ;***************************************************************
,,,        ;
0077,13 81,,        DW      AABS            ;(24, 18H)ABSOLUTE VALUE
0079,13 5F,,        DW      AINT            ;(25, 19H)INTEGER OPERATOR
007B,13 87,,        DW      ASGN            ;(26, 1AH)SIGN OPERATOR
007D,14 88,,        DW      ANOT            ;(27, 1BH)ONE'S COMPLEMENT
007F,11 5F,,        DW      ACOS            ;(28, 1CH)COSINE
0081,11 C2,,        DW      ATAN            ;(29, 1DH)TANGENT
0083,11 63,,        DW      ASIN            ;(30, 1EH)SINE
0085,12 7F,,        DW      ASQR            ;(31, 1FH)SQUARE ROOT
0087,13 9F,,        DW      ACBYTE          ;(32, 20H)READ CODE
0089,13 19,,        DW      AETOX           ;(33, 21H)E TO THE X
008B,11 D2,,        DW      AATAN           ;(34, 22H)ARC TANGENT
008D,12 B2,,        DW      ALN             ;(35, 23H)NATURAL LOG
008F,13 A8,,        DW      ADBYTE          ;(36, 24H)READ DATA MEMORY
0091,13 B0,,        DW      AXBYTE          ;(37, 25H)READ EXTERNAL MEMORY
0093,14 71,,        DW      PIPI            ;(38, 26H)PI
0095,13 E3,,        DW      ARND            ;(39, 27H)RANDOM NUMBER
0097,14 9B,,        DW      AGET            ;(40, 28H)GET INPUT CHARACTER
0099,17 0F,,        DW      AFREE           ;(41, 29H)COMPUTE #BYTES FREE
009B,17 1F,,        DW      ALEN            ;(42, 2AH) COMPUTE LEN OF PORGRAM
009D,0F E2,,        DW      AXTAL           ;(43, 2BH) CRYSTAL
009F,16 41,,        DW      PMTOP           ;(44, 2CH)TOP OF MEMORY
00A1,17 27,,        DW      ATIME           ;(45, 2DH) TIME
00A3,14 AB,,        DW      A_IE            ;(46, 2EH) IE
00A5,14 AF,,        DW      A_IP            ;(47, 2FH) IP
00A7,14 B3,,        DW      ATIM0           ;(48, 30H) TIMER 0
00A9,14 B9,,        DW      ATIM1           ;(49, 31H) TIMER 1
00AB,14 BF,,        DW      ATIM2           ;(50, 32H) TIMER 2
00AD,14 C5,,        DW      AT2CON          ;(51, 33H) T2CON
00AF,14 C9,,        DW      ATCON           ;(52, 34H) TCON
00B1,14 CD,,        DW      ATMOD           ;(53, 35H) ATMOD
00B3,14 D1,,        DW      ARCAP2          ;(54, 36H) RCAP2
00B5,14 D7,,        DW      AP1             ;(55, 37H) P1
00B7,14 DB,,        DW      APCON           ;(56, 38H) PCON
00B9,0F 4C,,        DW      EXPRB           ;(57, 39H) EVALUATE AN EXPRESSION
00BB,16 4E,,        DW      AXTAL1          ;(58, 3AH) CALCULATE CRYSTAL
00BD,14 E2,,        DW      LINE            ;(59, 3BH) EDIT A LINE
00BF,15 AC,,        DW      PP              ;(60, 3CH) PROCESS A LINE
00C1,10 8C,,        DW      UPPL-3          ;(61, 3DH) UNPROCESS A LINE
00C3,0D 6E,,        DW      VAR             ;(62, 3EH) FIND A VARIABLE
00C5,0E D6,,        DW      GC              ;(63, 3FH) GET A CHARACTER
00C7,0E DE,,        DW      GCI             ;(64, 40H) GET CHARACTER AND INCREMENT
00C9,07 89,,        DW      INCHAR          ;(65, 41H) INPUT A CHARACTER
00CB,08 06,,        DW      CRUN            ;(66, 42H) RUN A PROGRAM
,,,$EJECT
00CD,01,OPBOL,OPBOL:  DB      1               ;
,,,        ;
00CE,0F,,        DB      15              ;LEFT PAREN
00CF,0E,,        DB      14              ;EXPONENTIAN **
00D0,0A,,        DB      10              ;MUL
00D1,08,,        DB      8               ;ADD
00D2,0A,,        DB      10              ;DIVIDE
00D3,08,,        DB      8               ;SUB
00D4,03,,        DB      3               ;XOR
00D5,05,,        DB      5               ;AND
00D6,04,,        DB      4               ;OR
00D7,0C,,        DB      12              ;NEGATE
00D8,06,,        DB      6               ;EQ
00D9,06,,        DB      6               ;GT
00DA,06,,        DB      6               ;LT
00DB,06,,        DB      6               ;NE
00DC,06,,        DB      6               ;LE
00DD,06,,        DB      6               ;GE
,,,        ;
00DE,0F,UOPBOL,UOPBOL: DB      15              ;AABS
00DF,0F,,        DB      15              ;AAINT
00E0,0F,,        DB      15              ;ASGN
00E1,0F,,        DB      15              ;ANOT
00E2,0F,,        DB      15              ;ACOS
00E3,0F,,        DB      15              ;ATAN
00E4,0F,,        DB      15              ;ASIN
00E5,0F,,        DB      15              ;ASQR
00E6,0F,,        DB      15              ;ACBYTE
00E7,0F,,        DB      15              ;E TO THE X
00E8,0F,,        DB      15              ;AATAN
00E9,0F,,        DB      15              ;NATURAL LOG
00EA,0F,,        DB      15              ;DBYTE
00EB,0F,,        DB      15              ;XBYTE
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; The ASCII printed messages.
,,,        ;
,,,        ;***************************************************************
,,,        ;
00EC,53 54 4F 50,STP,STP:    DB      'STOP"'
,,,        ;
00F1,54 52 59 20,IAN,IAN:    DB      'TRY AGAIN"'
,,,        ;
00FB,52 45 41 44,RDYS,RDYS:   DB      'READY"'
,,,        ;
0101,20 2D 20 49,INS,INS:    DB      ' - IN LINE "'
,,,        ;
,,,        ;**************************************************************
,,,        ;
,,,        ; This is the command jump table
,,,        ;
,,,        ;**************************************************************
,,,        ;
010D,08 06,CMNDD,CMNDD:  DW      CRUN            ;RUN
010F,10 3A,,        DW      CLIST           ;LIST
0111,0B 10,,        DW      CNULL           ;NULL
0113,06 54,,        DW      CNEW            ;NEW
0115,18 3F,,        DW      CCONT           ;CONTINUE
0117,04 61,,        DW      CPROG           ;PROGRAM A PROM
0119,17 71,,        DW      CXFER           ;TRANSFER FROM ROM TO RAM
011B,17 7D,,        DW      CRAM            ;RAM MODE
011D,05 36,,        DW      CROM            ;ROM MODE
011F,04 5A,,        DW      CIPROG          ;INTELLIGENT PROM PROGRAMMING
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; This is the statement jump table.
,,,        ;
,,,        ;**************************************************************
,,,        ;
0121,,STATD,STATD:  ;
0121,09 76,,        DW      SLET            ;LET            80H
0123,06 87,,        DW      SCLR            ;CLEAR          81H
0125,0A 7E,,        DW      SPUSH           ;PUSH VAR       82H
0127,0A B2,,        DW      SGOTO           ;GO TO          83H
0129,16 84,,        DW      STONE           ;TONE           84H
012B,0C 31,,        DW      SPH0            ;PRINT MODE 0   85H
012D,19 2C,,        DW      SUI             ;USER INPUT     86H
012F,19 31,,        DW      SUO             ;USER OUTPUT    87H
0131,0A 85,,        DW      SPOP            ;POP VAR        88H
0133,0C 35,,        DW      SPRINT          ;PRINT          89H
0135,0E 6C,,        DW      SCALL           ;CALL           8AH
0137,0D 6A,,        DW      SDIMX           ;DIMENSION      8BH
0139,06 04,,        DW      STRING          ;STRING ALLO    8CH
013B,16 F7,,        DW      SBAUD           ;SET BAUD       8DH
013D,19 19,,        DW      SCLOCK          ;CLOCK          8EH
013F,0C 33,,        DW      SPH1            ;PRINT MODE 1   8FH
,,,        ;
,,,        ; No direct mode from here on
,,,        ;
0141,08 5C,,        DW      SSTOP           ;STOP           90H
0143,0E 5F,,        DW      SOT             ;ON TIME        91H
0145,14 0B,,        DW      SONEXT          ;ON EXT INT     92H
0147,0B 16,,        DW      SRETI           ;RET FROM INT   93H
0149,0F 0E,,        DW      S_DO            ;DO             94H
014B,0B D6,,        DW      SRESTR          ;RESTOR         95H
014D,0F 05,,        DW      WCR             ;REM            96H
014F,0B 67,,        DW      SNEXT           ;NEXT           97H
0151,14 01,,        DW      SONERR          ;ON ERROR       98H
0153,0C F4,,        DW      S_ON            ;ON             99H
0155,0D FE,,        DW      SINPUT          ;INPUT          9AH
0157,0B EB,,        DW      SREAD           ;READ           9BH
0159,0E F5,,        DW      FINDCR          ;DATA           9CH
015B,0B 18,,        DW      SRETRN          ;RETURN         9DH
015D,0A 8E,,        DW      SIF             ;IF             9EH
015F,0B 35,,        DW      SGOSUB          ;GOSUB          9FH
0161,0A 44,,        DW      SFOR            ;FOR            A0H
0163,0B 04,,        DW      SWHILE          ;WHILE          A1H
0165,0B 09,,        DW      SUNTIL          ;UNTIL          A2H
0167,17 85,,        DW      CMND1           ;END            A3H
0169,18 5C,,        DW      I_DL            ;IDLE           A4H
016B,0F EE,,        DW      ST_A            ;STORE AT       A5H
016D,0F F2,,        DW      LD_A            ;LOAD AT        A6H
016F,05 0C,,        DW      PGU             ;PGM            A7H
0171,07 BC,,        DW      RROM            ;RUN A ROM      A9H
,,,        ;
,,,$EJECT
,,,        ;**************************************************************
,,,        ;
0173,,TOKTAB,TOKTAB: ; This is the basic token table
,,,        ;
,,,        ;**************************************************************
,,,        ;
,,,        ; First the tokens for statements
,,,        ;
0173,80,,        DB      80H             ;LET TOKEN
0174,4C 45 54,,        DB      'LET'
,,,        ;
0177,81,,        DB      81H             ;CLEAR TOKEN
0178,43 4C 45 41,,        DB      'CLEAR'
,,,        ;
017D,82,,        DB      82H             ;PUSH TOKEN
017E,50 55 53 48,,        DB      'PUSH'
,,,        ;
,,,T_GOTO  EQU     83H
,,,        ;
0182,83,,        DB      83H             ;GO TO TOKEN
0183,47 4F 54 4F,,        DB      'GOTO'
,,,        ;
0187,84,,        DB      84H             ;TOGGLE TOKEN
0188,50 57 4D,,        DB      'PWM'
,,,        ;
018B,85,,        DB      85H             ;PRINT HEX MODE 0
018C,50 48 30 2E,,        DB      'PH0.'
,,,        ;
0190,86,,        DB      86H             ;USER IN TOKEN
0191,55 49,,        DB      'UI'
,,,        ;
0193,87,,        DB      87H             ;USER OUT TOKEN
0194,55 4F,,        DB      'UO'
,,,        ;
0196,88,,        DB      88H             ;POP TOKEN
0197,50 4F 50,,        DB      'POP'
,,,        ;
,,,$EJECT
019A,89,,        DB      89H             ;PRINT TOKEN
019B,50 52 49 4E,,        DB      'PRINT'
01A0,89,,        DB      89H
01A1,50 2E,,        DB      'P.'            ;P. ALSO MEANS PRINT
01A3,89,,        DB      89H             ;? ALSO
01A4,3F,,        DB      '?'
,,,        ;
01A5,8A,,        DB      8AH             ;CALL TOKEN
01A6,43 41 4C 4C,,        DB      'CALL'
,,,        ;
01AA,8B,,        DB      8BH             ;DIMENSION TOKEN
01AB,44 49 4D,,        DB      'DIM'
,,,        ;
01AE,8C,,        DB      8CH             ;STRING TOKEN
01AF,53 54 52 49,,        DB      'STRING'
,,,        ;
01B5,8D,,        DB      8DH             ;SET BAUD RATE
01B6,42 41 55 44,,        DB      'BAUD'
,,,        ;
01BA,8E,,        DB      8EH             ;CLOCK
01BB,43 4C 4F 43,,        DB      'CLOCK'
,,,        ;
01C0,8F,,        DB      8FH             ;PRINT HEX MODE 1
01C1,50 48 31 2E,,        DB      'PH1.'
,,,        ;
,,,T_STOP  EQU     90H             ;STOP TOKEN
01C5,90,,        DB      T_STOP
01C6,53 54 4F 50,,        DB      'STOP'
,,,        ;
,,,T_DIR   EQU     T_STOP          ;NO DIRECT FROM HERE ON
,,,        ;
01CA,91,,        DB      T_STOP+1        ;ON TIMER INTERRUPT
01CB,4F 4E 54 49,,        DB      'ONTIME'
,,,        ;
01D1,92,,        DB      T_STOP+2        ;ON EXTERNAL INTERRUPT
01D2,4F 4E 45 58,,        DB      'ONEX1'
,,,        ;
01D7,93,,        DB      T_STOP+3        ;RETURN FROM INTERRUPT
01D8,52 45 54 49,,        DB      'RETI'
,,,        ;
01DC,94,,        DB      T_STOP+4        ;DO TOKEN
01DD,44 4F,,        DB      'DO'
,,,        ;
01DF,95,,        DB      T_STOP+5        ;RESTORE TOKEN
01E0,52 45 53 54,,        DB      'RESTORE'
,,,        ;
,,,$EJECT
,,,T_REM   EQU     T_STOP+6        ;REMARK TOKEN
01E7,96,,        DB      T_REM
01E8,52 45 4D,,        DB      'REM'
,,,        ;
01EB,97,,        DB      T_REM+1         ;NEXT TOKEN
01EC,4E 45 58 54,,        DB      'NEXT'
,,,        ;
01F0,98,,        DB      T_REM+2         ;ON ERROR TOKEN
01F1,4F 4E 45 52,,        DB      'ONERR'
,,,        ;
01F6,99,,        DB      T_REM+3         ;ON TOKEN
01F7,4F 4E,,        DB      'ON'
,,,        ;
01F9,9A,,        DB      T_REM+4         ;INPUT
01FA,49 4E 50 55,,        DB      'INPUT'
,,,        ;
01FF,9B,,        DB      T_REM+5         ;READ
0200,52 45 41 44,,        DB      'READ'
,,,        ;
,,,T_DATA  EQU     T_REM+6         ;DATA
0204,9C,,        DB      T_DATA
0205,44 41 54 41,,        DB      'DATA'
,,,        ;
0209,9D,,        DB      T_DATA+1        ;RETURN
020A,52 45 54 55,,        DB      'RETURN'
,,,        ;
0210,9E,,        DB      T_DATA+2        ;IF
0211,49 46,,        DB      'IF'
,,,        ;
,,,T_GOSB  EQU     T_DATA+3        ;GOSUB
0213,9F,,        DB      T_GOSB
0214,47 4F 53 55,,        DB      'GOSUB'
,,,        ;
0219,A0,,        DB      T_GOSB+1        ;FOR
021A,46 4F 52,,        DB      'FOR'
,,,        ;
021D,A1,,        DB      T_GOSB+2        ;WHILE
021E,57 48 49 4C,,        DB      'WHILE'
,,,        ;
0223,A2,,        DB      T_GOSB+3        ;UNTIL
0224,55 4E 54 49,,        DB      'UNTIL'
,,,        ;
0229,A3,,        DB      T_GOSB+4        ;END
022A,45 4E 44,,        DB      'END'
,,,        ;
,,,$EJECT
,,,T_LAST  EQU     T_GOSB+5        ;LAST INITIAL TOKEN
,,,        ;
,,,T_TAB   EQU     T_LAST          ;TAB TOKEN
022D,A4,,        DB      T_TAB
022E,54 41 42,,        DB      'TAB'
,,,        ;
,,,T_THEN  EQU     T_LAST+1        ;THEN TOKEN
0231,A5,,        DB      T_THEN
0232,54 48 45 4E,,        DB      'THEN'
,,,        ;
,,,T_TO    EQU     T_LAST+2        ;TO TOKEN
0236,A6,,        DB      T_TO
0237,54 4F,,        DB      'TO'
,,,        ;
,,,T_STEP  EQU     T_LAST+3        ;STEP TOKEN
0239,A7,,        DB      T_STEP
023A,53 54 45 50,,        DB      'STEP'
,,,        ;
,,,T_ELSE  EQU     T_LAST+4        ;ELSE TOKEN
023E,A8,,        DB      T_ELSE
023F,45 4C 53 45,,        DB      'ELSE'
,,,        ;
,,,T_SPC   EQU     T_LAST+5        ;SPACE TOKEN
0243,A9,,        DB      T_SPC
0244,53 50 43,,        DB      'SPC'
,,,        ;
,,,T_CR    EQU     T_LAST+6
0247,AA,,        DB      T_CR
0248,43 52,,        DB      'CR'
,,,        ;
024A,AB,,        DB      T_CR+1
024B,49 44 4C 45,,        DB      'IDLE'
,,,        ;
024F,AC,,        DB      T_CR+2
0250,53 54 40,,        DB      'ST@'
,,,        ;
0253,AD,,        DB      T_CR+3
0254,4C 44 40,,        DB      'LD@'
,,,        ;
0257,AE,,        DB      T_CR+4
0258,50 47 4D,,        DB      'PGM'
,,,        ;
025B,AF,,        DB      T_CR+5
025C,52 52 4F 4D,,        DB      'RROM'
,,,        ;
,,,$EJECT
,,,        ; Operator tokens
,,,        ;
,,,T_LPAR  EQU     0E0H            ;LEFT PAREN
0260,E0,,        DB      T_LPAR
0261,28,,        DB      '('
,,,        ;
0262,E1,,        DB      T_LPAR+1        ;EXPONENTIAN
0263,2A 2A,,        DB      '**'
,,,        ;
0265,E2,,        DB      T_LPAR+2        ;FP MULTIPLY
0266,2A,,        DB      '*'
,,,        ;
,,,T_ADD   EQU     T_LPAR+3
0267,E3,,        DB      T_LPAR+3        ;ADD TOKEN
0268,2B,,        DB      '+'
,,,        ;
0269,E4,,        DB      T_LPAR+4        ;DIVIDE TOKEN
026A,2F,,        DB      '/'
,,,        ;
,,,T_SUB   EQU     T_LPAR+5        ;SUBTRACT TOKEN
026B,E5,,        DB      T_SUB
026C,2D,,        DB      '-'
,,,        ;
026D,E6,,        DB      T_LPAR+6        ;LOGICAL EXCLUSIVE OR
026E,2E 58 4F 52,,        DB      '.XOR.'
,,,        ;
0273,E7,,        DB      T_LPAR+7        ;LOGICAL AND
0274,2E 41 4E 44,,        DB      '.AND.'
,,,        ;
0279,E8,,        DB      T_LPAR+8        ;LOGICAL OR
027A,2E 4F 52 2E,,        DB      '.OR.'
,,,        ;
,,,T_NEG   EQU     T_LPAR+9
,,,        ;
,,,T_EQU   EQU     T_LPAR+10       ;EQUAL
027E,EA,,        DB      T_EQU
027F,3D,,        DB      '='
,,,        ;
0280,EB,,        DB      T_LPAR+11       ;GREATER THAN OR EQUAL
0281,3E 3D,,        DB      '>='
,,,        ;
0283,EC,,        DB      T_LPAR+12       ;LESS THAN OR EQUAL
0284,3C 3D,,        DB      '<='
,,,        ;
0286,ED,,        DB      T_LPAR+13       ;NOT EQUAL
0287,3C 3E,,        DB      '<>'
,,,        ;
0289,EE,,        DB      T_LPAR+14       ;LESS THAN
028A,3C,,        DB      '<'
,,,        ;
028B,EF,,        DB      T_LPAR+15       ;GREATER THAN
028C,3E,,        DB      '>'
,,,        ;
,,,        ;
,,,T_UOP   EQU     0B0H            ;UNARY OP BASE TOKEN
,,,        ;
028D,B0,,        DB      T_UOP           ;ABS TOKEN
028E,41 42 53,,        DB      'ABS'
,,,        ;
0291,B1,,        DB      T_UOP+1         ;INTEGER TOKEN
0292,49 4E 54,,        DB      'INT'
,,,        ;
0295,B2,,        DB      T_UOP+2         ;SIGN TOKEN
0296,53 47 4E,,        DB      'SGN'
,,,        ;
0299,B3,,        DB      T_UOP+3         ;GET TOKEN
029A,4E 4F 54,,        DB      'NOT'
,,,        ;
029D,B4,,        DB      T_UOP+4         ;COSINE TOKEN
029E,43 4F 53,,        DB      'COS'
,,,        ;
02A1,B5,,        DB      T_UOP+5         ;TANGENT TOKEN
02A2,54 41 4E,,        DB      'TAN'
,,,        ;
02A5,B6,,        DB      T_UOP+6         ;SINE TOKEN
02A6,53 49 4E,,        DB      'SIN'
,,,        ;
02A9,B7,,        DB      T_UOP+7         ;SQUARE ROOT TOKEN
02AA,53 51 52,,        DB      'SQR'
,,,        ;
02AD,B8,,        DB      T_UOP+8         ;CBYTE TOKEN
02AE,43 42 59,,        DB      'CBY'
,,,        ;
02B1,B9,,        DB      T_UOP+9         ;EXP (E TO THE X) TOKEN
02B2,45 58 50,,        DB      'EXP'
,,,        ;
02B5,BA,,        DB      T_UOP+10
02B6,41 54 4E,,        DB      'ATN'
,,,        ;
02B9,BB,,        DB      T_UOP+11
02BA,4C 4F 47,,        DB      'LOG'
,,,        ;
02BD,BC,,        DB      T_UOP+12        ;DBYTE TOKEN
02BE,44 42 59,,        DB      'DBY'
,,,        ;
02C1,BD,,        DB      T_UOP+13        ;XBYTE TOKEN
02C2,58 42 59,,        DB      'XBY'
,,,        ;
,,,T_ULAST EQU     T_UOP+14        ;LAST OPERATOR NEEDING PARENS
,,,        ;
02C5,BE,,        DB      T_ULAST
02C6,50 49,,        DB      'PI'
,,,        ;
02C8,BF,,        DB      T_ULAST+1       ;RND TOKEN
02C9,52 4E 44,,        DB      'RND'
,,,        ;
02CC,C0,,        DB      T_ULAST+2       ;GET TOKEN
02CD,47 45 54,,        DB      'GET'
,,,        ;
02D0,C1,,        DB      T_ULAST+3       ;FREE TOKEN
02D1,46 52 45 45,,        DB      'FREE'
,,,        ;
02D5,C2,,        DB      T_ULAST+4       ;LEN TOKEN
02D6,4C 45 4E,,        DB      'LEN'
,,,        ;
,,,T_XTAL  EQU     T_ULAST+5       ;CRYSTAL TOKEN
02D9,C3,,        DB      T_XTAL
02DA,58 54 41 4C,,        DB      'XTAL'
,,,        ;
,,,T_MTOP  EQU     T_ULAST+6       ;MTOP
02DE,C4,,        DB      T_MTOP
02DF,4D 54 4F 50,,        DB      'MTOP'
,,,        ;
,,,T_IE    EQU     T_ULAST+8       ;IE REGISTER
02E3,C6,,        DB      T_IE
02E4,49 45,,        DB      'IE'
,,,        ;
,,,T_IP    EQU     T_ULAST+9       ;IP REGISTER
02E6,C7,,        DB      T_IP
02E7,49 50,,        DB      'IP'
,,,        ;
,,,TMR0    EQU     T_ULAST+10      ;TIMER 0
02E9,C8,,        DB      TMR0
02EA,54 49 4D 45,,        DB      'TIMER0'
,,,        ;
,,,TMR1    EQU     T_ULAST+11      ;TIMER 1
02F0,C9,,        DB      TMR1
02F1,54 49 4D 45,,        DB      'TIMER1'
,,,        ;
,,,TMR2    EQU     T_ULAST+12      ;TIMER 2
02F7,CA,,        DB      TMR2
02F8,54 49 4D 45,,        DB      'TIMER2'
,,,        ;
,,,T_TIME  EQU     T_ULAST+7       ;TIME
02FE,C5,,        DB      T_TIME
02FF,54 49 4D 45,,        DB      'TIME'
,,,        ;
,,,TT2C    EQU     T_ULAST+13      ;T2CON
0303,CB,,        DB      TT2C
0304,54 32 43 4F,,        DB      'T2CON'
,,,        ;
,,,TTC     EQU     T_ULAST+14      ;TCON
0309,CC,,        DB      TTC
030A,54 43 4F 4E,,        DB      'TCON'
,,,        ;
,,,TTM     EQU     T_ULAST+15      ;TMOD
030E,CD,,        DB      TTM
030F,54 4D 4F 44,,        DB      'TMOD'
,,,        ;
,,,TRC2    EQU     T_ULAST+16      ;RCAP2
0313,CE,,        DB      TRC2
0314,52 43 41 50,,        DB      'RCAP2'
,,,        ;
,,,T_P1    EQU     T_ULAST+17      ;P1
0319,CF,,        DB      T_P1
031A,50 4F 52 54,,        DB      'PORT1'
,,,        ;
,,,T_PC    EQU     T_ULAST+18      ;PCON
031F,D0,,        DB      T_PC
0320,50 43 4F 4E,,        DB      'PCON'
,,,        ;
,,,T_ASC   EQU     T_ULAST+19      ;ASC TOKEN
0324,D1,,        DB      T_ASC
0325,41 53 43 28,,        DB      'ASC('
,,,        ;
,,,T_USE   EQU     T_ULAST+20      ;USING TOKEN
0329,D2,,        DB      T_USE
032A,55 53 49 4E,,        DB      'USING('
0330,D2,,        DB      T_USE
0331,55 2E 28,,        DB      'U.('
,,,        ;
,,,T_CHR   EQU     T_ULAST+21      ;CHR TOKEN
0334,D3,,        DB      T_CHR
0335,43 48 52 28,,        DB      'CHR('
,,,        ;
,,,$EJECT
,,,T_CMND  EQU     0F0H            ;COMMAND BASE
,,,        ;
0339,F0,,        DB      0F0H            ;RUN TOKEN
033A,52 55 4E,,        DB      'RUN'
,,,        ;
033D,F1,,        DB      0F1H            ;LIST TOKEN
033E,4C 49 53 54,,        DB      'LIST'
,,,        ;
0342,F2,,        DB      0F2H            ;NULL TOKEN
0343,4E 55 4C 4C,,        DB      'NULL'
,,,        ;
0347,F3,,        DB      0F3H            ;NEW TOKEN
0348,4E 45 57,,        DB      'NEW'
,,,        ;
034B,F4,,        DB      0F4H            ;CONTINUE TOKEN
034C,43 4F 4E 54,,        DB      'CONT'
,,,        ;
0350,F5,,        DB      0F5H            ;PROGRAM TOKEN
0351,50 52 4F 47,,        DB      'PROG'
,,,        ;
0355,F6,,        DB      0F6H            ;TRANSFER TOKEN
0356,58 46 45 52,,        DB      'XFER'
,,,        ;
035A,F7,,        DB      0F7H            ;RAM MODE
035B,52 41 4D,,        DB      'RAM'
,,,        ;
035E,F8,,        DB      0F8H            ;ROM MODE
035F,52 4F 4D,,        DB      'ROM'
,,,        ;
0362,F9,,        DB      0F9H            ;INTELLIGENT PROM PROGRAMMING
0363,46 50 52 4F,,        DB      'FPROG'
,,,        ;
0368,FF,,        DB      0FFH            ;END OF TABLE
,,,        ;
,,,
,,,; END OF INCLUDE LOOK52
,,,;$INCLUDE(:F2:LOOK52.SRC)
,,,        ;
0369,45 58 54 52,EIG,EIG:    DB      'EXTRA IGNORED"'
,,,        ;
0377,41 2D 53 54,EXA,EXA:    DB      'A-STACK"'
,,,        ;
037F,43 2D 53 54,EXC,EXC:    DB      'C-STACK"'
,,,        ;
,,,$EJECT
,,,;$INCLUDE(:F2:BAS52.RST)
,,,; BEGINNING
,,,
,,,        ;**************************************************************
,,,        ;
0387,,CRST,CRST:   ; This performs system initialzation, it was moved here so the
,,,        ; new power on reset functions could be tested in an 8751.
,,,        ;
,,,        ;**************************************************************
,,,        ;
,,,        ; First, initialize SFR's
,,,        ;
0387,75 98 5A,,        MOV     SCON,#5AH       ;INITIALIZE SFR'S
038A,75 89 10,,        MOV     TMOD,#10H
038D,75 88 54,,        MOV     TCON,#54H
0390,75,,        DB      75H             ;MOV DIRECT, # OP CODE
0391,C8,,        DB      0C8H            ;T2CON LOCATION
0392,34,,        DB      34H             ;CONFIGURATION BYTE
,,,        ;
0393,90 20 01,,        MOV     DPTR,#2001H     ;READ CODE AT 2001H
0396,E4,,        CLR     A
0397,93,,        MOVC    A,@A+DPTR
0398,B4 AA 03,,        CJNE    A,#0AAH,$+6     ;IF IT IS AN AAH, DO USER RESET
039B,12 20 90,,        LCALL   2090H
,,,        ;
039E,78 FF,,        MOV     R0,#IRAMTOP     ;PUT THE TOP OF RAM IN R0
03A0,E4,,        CLR     A               ;ZERO THE ACC
,,,        ;
03A1,F6,,        MOV     @R0,A           ;CLEAR INTERNAL MEMORY
03A2,D8 FD,,        DJNZ    R0,$-1          ;LOOP TIL DONE
,,,        ;
,,,        ; Now, test the external memory
,,,        ;
03A4,75 3E 4D,,        MOV     SPSAV,#CMNDSP   ;SET UP THE STACK
03A7,85 3E 81,,        MOV     SP,SPSAV
,,,        ;
03AA,75 13 80,,        MOV     BOFAH,#HIGH ROMADR
03AD,75 14 11,,        MOV     BOFAL,#LOW ROMADR+17
03B0,90 80 00,,        MOV     DPTR,#ROMADR    ;GET THE BYTE AT 8000H
03B3,E0,,        MOVX    A,@DPTR
03B4,C3,,        CLR     C
03B5,94 31,,        SUBB    A,#31H          ;FOR BIAS
03B7,F5 45,,        MOV     MT1,A           ;SAVE IN DIRECT MATH LOC
03B9,C2 E2,,        CLR     ACC.2           ;SAVE FOR RESET
03BB,FF,,        MOV     R7,A            ;SAVE IT IN R7
03BC,A3,,        INC     DPTR
03BD,B1 B2,,        ACALL   L31DPI          ;GET SAVED BAUD RATE
03BF,12 08 89,,        LCALL   RCL
03C2,A3,,        INC     DPTR            ;GET MEMTOP
03C3,B1 B2,,        ACALL   L31DPI
03C5,90 00 5F,,        MOV     DPTR,#5FH       ;READ THE EXTERNAL BYTE
03C8,E0,,        MOVX    A,@DPTR
03C9,90 00 00,,        MOV     DPTR,#0         ;ESTABLISH BASE FOR CLEAR
03CC,B4 A5 08,,        CJNE    A,#0A5H,CRS
03CF,E5 45,,        MOV     A,MT1
03D1,C2 E0,,        CLR     ACC.0           ;CLEAR BIT ONE
03D3,64 04,,        XRL     A,#4H
03D5,60 29,,        JZ      CR2
,,,        ;
03D7,BF 02 02,CRS,CRS:    CJNE    R7,#2,$+5
03DA,80 03,,        SJMP    $+5
03DC,BF 03 04,,        CJNE    R7,#3,$+7
03DF,D1 75,,        ACALL   CL_1
03E1,80 11,,        SJMP    CR1
,,,        ;
03E3,AB 83,CR0,CR0:    MOV     R3,DPH          ;SAVE THE DPTR
03E5,A9 82,,        MOV     R1,DPL
03E7,A3,,        INC     DPTR
03E8,74 5A,,        MOV     A,#5AH
03EA,F0,,        MOVX    @DPTR,A
03EB,E0,,        MOVX    A,@DPTR
03EC,B4 5A 05,,        CJNE    A,#5AH,CR1
03EF,E4,,        CLR     A
03F0,F0,,        MOVX    @DPTR,A
03F1,BB E0 EF,,        CJNE    R3,#0E0H,CR0
,,,        ;
03F4,BB 03 00,CR1,CR1:    CJNE    R3,#03H,$+3     ;NEED THIS MUCH RAM
03F7,40 8E,,        JC      CRST
03F9,90 01 0A,,        MOV     DPTR,#MEMTOP    ;SAVE MEMTOP
03FC,B1 FB,,        ACALL   S31DP2          ;SAVE MEMTOP AND SEED RCELL
03FE,D1 54,,        ACALL   CNEW            ;CLEAR THE MEMORY AND SET UP POINTERS
,,,        ;
0400,D1 67,CR2,CR2:    ACALL   RC1             ;SET UP STACKS IF NOT DONE
,,,        ;
0402,12 16 49,,        LCALL   AXTAL0          ;DO THE CRYSTAL
0405,E5 45,,        MOV     A,MT1           ;GET THE RESET BYTE
0407,B4 05 03,,        CJNE    A,#5,$+6
040A,12 40 39,,        LCALL   4039H
040D,50 0D,,        JNC     BG1             ;CHECK FOR 0,1,2,3, OR 4
040F,30 E0 25,,        JNB     ACC.0,BG3       ;NO RUN IF WRONG TYPE
0412,90 80 10,,        MOV     DPTR,#ROMADR+16
0415,E0,,        MOVX    A,@DPTR         ;READ THE BYTE
0416,B4 55 1E,,        CJNE    A,#55H,BG3
0419,02 08 06,,        LJMP    CRUN
,,,        ;
041C,E4,BG1,BG1:    CLR     A               ;DO BAUD RATE
041D,FB,,        MOV     R3,A
041E,F9,,        MOV     R1,A
041F,78 04,,        MOV     R0,#4
0421,20 B0 FD,,        JB      RXD,$           ;LOOP UNTIL A CHARACTER IS RECEIVED
,,,        ;
0424,D8 FE,BG2,BG2:    DJNZ    R0,$            ;FOUR CLOCKS, IN LOOP
0426,12 15 81,,        CALL    DEC3210+4       ;NINE CLOCKS
0429,78 02,,        MOV     R0,#2           ;ONE CLOCK
042B,30 B0 F6,,        JNB     RXD,BG2         ;TWO CLOCKS, LOOP UNTIL DONE
042E,20 B0 FD,,        JB      RXD,$           ;WAIT FOR STOP CHARACTER TO END
0431,30 B0 FD,,        JNB     RXD,$
0434,12 08 89,,        CALL    RCL             ;LOAD THE TIMER
,,,        ;
0437,90 1F D3,BG3,BG3:    MOV     DPTR,#S_N       ;GET THE MESSAGE
043A,D1 A5,,        ACALL   CRP             ;PRINT IT
043C,02 17 7D,,        LJMP    CRAM
,,,
,,,; END
,,,;$INCLUDE(:F2:BAS52.RST)
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; CIPROG AND CPROG - Program a prom
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,;$INCLUDE(:F2:BAS52.PGM)
,,,;BEGINNING
,,,
043F,7F 00,PG8,PG8:    MOV     R7,#00H         ;PROGRAM ONE BYTE AT A TIME
0441,7E 01,,        MOV     R6,#01H
0443,7A 7F,,        MOV     R2,#HIGH ROMADR-1
0445,78 FF,,        MOV     R0,#LOW ROMADR-1;LOAD PROM ADDRESS
0447,91 98,,        ACALL   PG1+3
0449,0E,,        INC     R6
044A,E5,,        DB      0E5H            ;MOV A DIRECT OP CODE
044B,CB,,        DB      0CBH            ;ADDRESS OF R2CAP HIGH
044C,91 98,,        ACALL   PG1+3
044E,E5,,        DB      0E5H            ;MOV A, DIRECT OP CODE
044F,CA,,        DB      0CAH            ;R2CAP LOW
0450,7E 03,,        MOV     R6,#3
0452,79 09,,        MOV     R1,#LOW MEMTOP-1
0454,7B 01,,        MOV     R3,#HIGH MEMTOP
0456,91 98,,        ACALL   PG1+3           ;SAVE MEMTOP
0458,80 37,,        SJMP    PGR
,,,        ;
045A,90 01 2A,CIPROG,CIPROG: MOV     DPTR,#IPROGS    ;LOAD IPROG LOCATION
045D,D2 33,,        SETB    INTELB
045F,80 05,,        SJMP    $+7             ;GO DO PROG
,,,        ;
0461,90 01 28,CPROG,CPROG:  MOV     DPTR,#PROGS     ;LOAD PROG LOCATION
0464,C2 33,,        CLR     INTELB
,,,        ;
0466,B1 7A,,        ACALL   LD_T            ;LOAD THE TIMER
0468,C2 95,,        CLR     PROMV           ;TURN ON THE PROM VOLTAGE
046A,12 0E EA,,        CALL    DELTST          ;SEE IF A CR
046D,70 D0,,        JNZ     PG8             ;SAVE TIMER IF SO
046F,7C FE,,        MOV     R4,#0FEH
0471,D2 1D,,        SETB    INBIT
0473,B1 53,,        ACALL   ROMFD           ;GET THE ROM ADDRESS OF THE LAST LOCATION
0475,12 18 55,,        CALL    TEMPD           ;SAVE THE ADDRESS
0478,EC,,        MOV     A,R4            ;GET COUNT
0479,F4,,        CPL     A
047A,12 14 A3,,        CALL    TWO_R2          ;PUT IT ON THE STACK
047D,12 19 A1,,        CALL    FP_BASE+14      ;OUTPUT IT
0480,B1 16,,        ACALL   CCAL            ;GET THE PROGRAM
0482,D1 9D,,        ACALL   CRLF            ;DO CRLF
0484,A8 0E,,        MOV     R0,TEMP4        ;GET ADDRESS
0486,AA 0F,,        MOV     R2,TEMP5
0488,74 55,,        MOV     A,#55H          ;LOAD SIGNIFIER
048A,0E,,        INC     R6              ;LOAD LEN + 1
048B,BE 00 01,,        CJNE    R6,#00,$+4
048E,0F,,        INC     R7
048F,91 9B,,        ACALL   PG2-2
,,,        ;
,,,$EJECT
0491,D2 95,PGR,PGR:    SETB    PROMV
0493,A1 3A,,        AJMP    C_K
,,,        ;
0495,8B A0,PG1,PG1:    MOV     P2,R3           ;GET THE BYTE TO PROGRAM
0497,E3,,        MOVX    A,@R1
0498,12 15 68,,        LCALL   INC3210         ;BUMP POINTERS
049B,7D 01,,        MOV     R5,#1           ;SET UP INTELLIGENT COUMTER
,,,        ;
049D,FC,PG2,PG2:    MOV     R4,A            ;SAVE THE BYTE IN R4
049E,91 D6,,        ACALL   PG7             ;PROGRAM THE BYTE
04A0,91 F0,,        ACALL   PG9
04A2,20 33 0C,,        JB      INTELB,PG4      ;SEE IF INTELLIGENT PROGRAMMING
,,,        ;
04A5,6C,PG3,PG3:    XRL     A,R4
04A6,70 20,,        JNZ     PG6             ;ERROR IF NOT THE SAME
04A8,12 16 39,,        CALL    DEC76           ;BUMP THE COUNTERS
04AB,70 E8,,        JNZ     PG1             ;LOOP IF NOT DONE
04AD,53 D0 E7,,        ANL     PSW,#11100111B  ;INSURE RB0
04B0,22,,        RET
,,,        ;
04B1,6C,PG4,PG4:    XRL     A,R4            ;SEE IF PROGRAMMED
04B2,70 0F,,        JNZ     PG5             ;JUMP IF NOT
04B4,EC,,        MOV     A,R4            ;GET THE DATA BACK
04B5,91 D6,,        ACALL   PG7             ;PROGRAM THE LOCATION
04B7,91 E0,,        ACALL   ZRO             ;AGAIN
04B9,91 E0,,        ACALL   ZRO             ;AND AGAIN
04BB,91 E0,,        ACALL   ZRO             ;AND AGAIN
04BD,DD F8,,        DJNZ    R5,$-6          ;KEEP DOING IT
04BF,91 F0,,        ACALL   PG9             ;RESET PROG
04C1,80 E2,,        SJMP    PG3             ;FINISH THE LOOP
,,,        ;
04C3,0D,PG5,PG5:    INC     R5              ;BUMP THE COUNTER
04C4,EC,,        MOV     A,R4            ;GET THE BYTE
04C5,BD 19 D5,,        CJNE    R5,#25,PG2      ;SEE IF TRIED 25 TIMES
,,,        ;
04C8,D2 95,PG6,PG6:    SETB    PROMV           ;TURN OFF PROM VOLTAGE
04CA,75 D0 00,,        MOV     PSW,#0          ;INSURE RB0
04CD,30 2F E0,,        JNB     DIRF,PG4-1      ;EXIT IF IN RUN MODE
04D0,90 1F 9A,,        MOV     DPTR,#E16X      ;PROGRAMMING ERROR
,,,        ;
04D3,02 18 90,ERRLK,ERRLK:  LJMP    ERROR           ;PROCESS THE ERROR
,,,        ;
,,,$EJECT
04D6,88 80,PG7,PG7:    MOV     P0,R0           ;SET UP THE PORTS
04D8,8A A0,,        MOV     P2,R2           ;LATCH LOW ORDER ADDRESS
04DA,B1 05,,        ACALL   PG11            ;DELAY FOR 8748/9
04DC,C2 93,,        CLR     ALED
04DE,F5 80,,        MOV     P0,A            ;PUT DATA ON THE PORT
,,,        ;
04E0,00,ZRO,ZRO:    NOP                     ;SETTLEING TIME + FP ZERO
04E1,00,,        NOP
04E2,00,,        NOP
04E3,00,,        NOP
04E4,00,,        NOP
04E5,00,,        NOP
04E6,B1 05,,        ACALL   PG11            ;DELAY A WHILE
04E8,C2 94,,        CLR     PROMP           ;START PROGRAMMING
04EA,B1 27,,        ACALL   TIMER_LOAD      ;START THE TIMER
04EC,30 8F FD,,        JNB     TF1,$           ;WAIT FOR PART TO PROGRAM
04EF,22,,        RET                     ;EXIT
,,,        ;
04F0,D2 94,PG9,PG9:    SETB    PROMP
04F2,B1 05,,        ACALL   PG11            ;DELAY FOR A WHILE
04F4,30 B2 FD,,        JNB     P3.2,$          ;LOOP FOR EEPROMS
04F7,75 80 FF,,        MOV     P0,#0FFH
04FA,C2 B7,,        CLR     P3.7            ;LOWER READ
04FC,B1 05,,        ACALL   PG11
04FE,E5 80,,        MOV     A,P0            ;READ THE PORT
0500,D2 B7,,        SETB    P3.7
0502,D2 93,,        SETB    ALED
0504,22,,        RET
,,,        ;
0505,75 0F 0C,PG11,PG11:   MOV     TEMP5,#12       ;DELAY 30uS AT 12 MHZ
0508,D5 0F FD,,        DJNZ    TEMP5,$
050B,22,,        RET
,,,        ;
,,,
,,,;END
,,,;$INCLUDE(:F2:BAS52.PGM)
,,,$EJECT
,,,        ;**************************************************************
,,,        ;
050C,,PGU,PGU:    ;PROGRAM A PROM FOR THE USER
,,,        ;
,,,        ;**************************************************************
,,,        ;
050C,C2 95,,        CLR     PROMV           ;TURN ON THE VOLTAGE
050E,75 D0 18,,        MOV     PSW,#00011000B  ;SELECT RB3
0511,91 95,,        ACALL   PG1             ;DO IT
0513,D2 95,,        SETB    PROMV           ;TURN IT OFF
0515,22,,        RET
,,,        ;
,,,        ;
,,,        ;*************************************************************
,,,        ;
0516,,CCAL,CCAL:   ; Set up for prom moves
,,,        ; R3:R1 gets source
,,,        ; R7:R6 gets # of bytes
,,,        ;
,,,        ;*************************************************************
,,,        ;
0516,B1 82,,        ACALL   GETEND          ;GET THE LAST LOCATION
0518,A3,,        INC     DPTR            ;BUMP TO LOAD EOF
0519,AB 13,,        MOV     R3,BOFAH
051B,A9 14,,        MOV     R1,BOFAL        ;RESTORE START
051D,C3,,        CLR     C               ;PREPARE FOR SUBB
051E,E5 82,,        MOV     A,DPL           ;SUB DPTR - BOFA > R7:R6
0520,99,,        SUBB    A,R1
0521,FE,,        MOV     R6,A
0522,E5 83,,        MOV     A,DPH
0524,9B,,        SUBB    A,R3
0525,FF,,        MOV     R7,A
0526,22,,        RET
,,,        ;
,,,        ;
,,,;$INCLUDE(:F2:BAS52.TL)
,,,;BEGINNING
,,,
,,,        ;**************************************************************
,,,        ;
0527,,TIMER_LOAD,TIMER_LOAD:; Load the timer
,,,        ;
,,,        ;*************************************************************
,,,        ;
0527,B1 26,,        ACALL   $-1             ;DELAY FOUR CLOCKS
0529,C2 8E,,        CLR     TR1             ;STOP IT WHILE IT'S LOADED
052B,85 40 8D,,        MOV     TH1,T_HH
052E,85 41 8B,,        MOV     TL1,T_LL
0531,C2 8F,,        CLR     TF1             ;CLEAR THE OVERFLOW FLAG
0533,D2 8E,,        SETB    TR1             ;START IT NOW
0535,22,,        RET
,,,        ;
,,,
,,,;END
,,,;$INCLUDE(:F2:BAS52.TL)
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
0536,,CROM,CROM:   ; The command action routine - ROM - Run out of rom
,,,        ;
,,,        ;***************************************************************
,,,        ;
0536,C2 17,,        CLR     CONB            ;CAN'T CONTINUE IF MODE CHANGE
0538,B1 3D,,        ACALL   RO1             ;DO IT
,,,        ;
053A,02 10 7E,C_K,C_K:    LJMP    CL3             ;EXIT
,,,        ;
053D,12 0F 3E,RO1,RO1:    CALL    INTGER          ;SEE IF INTGER PRESENT
0540,AC 00,,        MOV     R4,R0B0         ;SAVE THE NUMBER
0542,50 02,,        JNC     $+4
0544,7C 01,,        MOV     R4,#01H         ;ONE IF NO INTEGER PRESENT
0546,B1 53,,        ACALL   ROMFD           ;FIND THE PROGRAM
0548,BC 00 11,,        CJNE    R4,#0,RFX       ;EXIT IF R4 <> 0
054B,A3,,        INC     DPTR            ;BUMP PAST TAG
054C,85 83 13,,        MOV     BOFAH,DPH       ;SAVE THE ADDRESS
054F,85 82 14,,        MOV     BOFAL,DPL
0552,22,,        RET
,,,        ;
0553,90 80 10,ROMFD,ROMFD:  MOV     DPTR,#ROMADR+16 ;START OF USER PROGRAM
,,,        ;
0556,E0,RF1,RF1:    MOVX    A,@DPTR         ;GET THE BYTE
0557,B4 55 09,,        CJNE    A,#55H,RF3      ;SEE IF PROPER TAG
055A,DC 01,,        DJNZ    R4,RF2          ;BUMP COUNTER
,,,        ;
055C,22,RFX,RFX:    RET                     ;DPTR HAS THE START ADDRESS
,,,        ;
055D,A3,RF2,RF2:    INC     DPTR            ;BUMP PAST TAG
055E,B1 A4,,        ACALL   G5
0560,A3,,        INC     DPTR            ;BUMP TO NEXT PROGRAM
0561,80 F3,,        SJMP    RF1             ;DO IT AGAIN
,,,        ;
0563,10 1D F6,RF3,RF3:    JBC     INBIT,RFX       ;EXIT IF SET
,,,        ;
0566,90 1F C9,NOGO,NOGO:   MOV     DPTR,#NOROM
0569,81 D3,,        AJMP    ERRLK
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
056B,,L20DPI,L20DPI: ; load R2:R0 with the location the DPTR is pointing to
,,,        ;
,,,        ;***************************************************************
,,,        ;
056B,E0,,        MOVX    A,@DPTR
056C,FA,,        MOV     R2,A
056D,A3,,        INC     DPTR
056E,E0,,        MOVX    A,@DPTR
056F,F8,,        MOV     R0,A
0570,22,,        RET                     ;DON'T BUMP DPTR
,,,        ;
,,,        ;***************************************************************
,,,        ;
0571,,X31DP,X31DP:  ; swap R3:R1 with DPTR
,,,        ;
,,,        ;***************************************************************
,,,        ;
0571,CB,,        XCH     A,R3
0572,C5 83,,        XCH     A,DPH
0574,CB,,        XCH     A,R3
0575,C9,,        XCH     A,R1
0576,C5 82,,        XCH     A,DPL
0578,C9,,        XCH     A,R1
0579,22,,        RET
,,,        ;
,,,        ;***************************************************************
,,,        ;
057A,,LD_T,LD_T:   ; Load the timer save location with the value the DPTR is
,,,        ; pointing to.
,,,        ;
,,,        ;****************************************************************
,,,        ;
057A,E0,,        MOVX    A,@DPTR
057B,F5 40,,        MOV     T_HH,A
057D,A3,,        INC     DPTR
057E,E0,,        MOVX    A,@DPTR
057F,F5 41,,        MOV     T_LL,A
0581,22,,        RET
,,,        ;
,,,$EJECT
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,        ;GETLIN - FIND THE LOCATION OF THE LINE NUMBER IN R3:R1
,,,        ;         IF ACC = 0 THE LINE WAS NOT FOUND I.E. R3:R1
,,,        ;         WAS TOO BIG, ELSE ACC <> 0 AND THE DPTR POINTS
,,,        ;         AT THE LINE THAT IS GREATER THAN OR EQUAL TO THE
,,,        ;         VALUE IN R3:R1.
,,,        ;
,,,        ;***************************************************************
,,,        ;
0582,D2 29,GETEND,GETEND: SETB    ENDBIT          ;GET THE END OF THE PROGRAM
,,,        ;
0584,12 0E A4,GETLIN,GETLIN: CALL    DP_B            ;GET BEGINNING ADDRESS
,,,        ;
0587,12 0A AC,G1,G1:     CALL    B_C
058A,60 12,,        JZ      G3              ;EXIT WITH A ZERO IN A IF AT END
058C,A3,,        INC     DPTR            ;POINT AT THE LINE NUMBER
058D,20 29 0A,,        JB      ENDBIT,G2       ;SEE IF WE WANT TO FIND THE END
0590,B1 C4,,        ACALL   DCMPX           ;SEE IF (DPTR) = R3:R1
0592,B1 BA,,        ACALL   DECDP           ;POINT AT LINE COUNT
0594,E0,,        MOVX    A,@DPTR         ;PUT LINE LENGTH INTO ACC
0595,20 2A 06,,        JB      UBIT,G3         ;EXIT IF EQUAL
0598,40 04,,        JC      G3              ;SEE IF LESS THAN OR ZERO
,,,        ;
059A,B1 D6,G2,G2:     ACALL   ADDPTR          ;ADD IT TO DPTR
059C,80 E9,,        SJMP    G1              ;LOOP
,,,        ;
059E,C2 29,G3,G3:     CLR     ENDBIT          ;RESET ENDBIT
05A0,22,,        RET                     ;EXIT
,,,        ;
05A1,90 02 00,G4,G4:     MOV     DPTR,#PSTART    ;DO RAM
,,,        ;
05A4,D2 29,G5,G5:     SETB    ENDBIT
05A6,80 DF,,        SJMP    G1              ;NOW DO TEST
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; LDPTRI - Load the DATA POINTER with the value it is pointing
,,,        ;          to - DPH = (DPTR) , DPL = (DPTR+1)
,,,        ;
,,,        ; acc gets wasted
,,,        ;
,,,        ;***************************************************************
,,,        ;
05A8,E0,LDPTRI,LDPTRI: MOVX    A,@DPTR         ;GET THE HIGH BYTE
05A9,C0 E0,,        PUSH    ACC             ;SAVE IT
05AB,A3,,        INC     DPTR            ;BUMP THE POINTER
05AC,E0,,        MOVX    A,@DPTR         ;GET THE LOW BYTE
05AD,F5 82,,        MOV     DPL,A           ;PUT IT IN DPL
05AF,D0 83,,        POP     DPH             ;GET THE HIGH BYTE
05B1,22,,        RET                     ;GO BACK
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,        ;L31DPI - LOAD R3 WITH (DPTR) AND R1 WITH (DPTR+1)
,,,        ;
,,,        ;ACC GETS CLOBBERED
,,,        ;
,,,        ;***************************************************************
,,,        ;
05B2,E0,L31DPI,L31DPI: MOVX    A,@DPTR         ;GET THE HIGH BYTE
05B3,FB,,        MOV     R3,A            ;PUT IT IN THE REG
05B4,A3,,        INC     DPTR            ;BUMP THE POINTER
05B5,E0,,        MOVX    A,@DPTR         ;GET THE NEXT BYTE
05B6,F9,,        MOV     R1,A            ;SAVE IT
05B7,22,,        RET
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,        ;DECDP - DECREMENT THE DATA POINTER - USED TO SAVE SPACE
,,,        ;
,,,        ;***************************************************************
,,,        ;
05B8,B1 BA,DECDP2,DECDP2: ACALL   DECDP
,,,        ;
05BA,C5 82,DECDP,DECDP:  XCH     A,DPL           ;GET DPL
05BC,70 02,,        JNZ     $+4             ;BUMP IF ZERO
05BE,15 83,,        DEC     DPH
05C0,14,,        DEC     A               ;DECREMENT IT
05C1,C5 82,,        XCH     A,DPL           ;GET A BACK
05C3,22,,        RET                     ;EXIT
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ;DCMPX - DOUBLE COMPARE - COMPARE (DPTR) TO R3:R1
,,,        ;R3:R1 - (DPTR) = SET CARRY FLAG
,,,        ;
,,,        ;IF R3:R1 > (DPTR) THEN C = 0
,,,        ;IF R3:R1 < (DPTR) THEN C = 1
,,,        ;IF R3:R1 = (DPTR) THEN C = 0
,,,        ;
,,,        ;***************************************************************
,,,        ;
05C4,C2 2A,DCMPX,DCMPX:  CLR     UBIT            ;ASSUME NOT EQUAL
05C6,E0,,        MOVX    A,@DPTR         ;GET THE BYTE
05C7,B5 03 0A,,        CJNE    A,R3B0,D1       ;IF A IS GREATER THAN R3 THEN NO CARRY
,,,                                ;WHICH IS R3<@DPTR = NO CARRY AND
,,,                                ;R3>@DPTR CARRY IS SET
05CA,A3,,        INC     DPTR            ;BUMP THE DATA POINTER
05CB,E0,,        MOVX    A,@DPTR         ;GET THE BYTE
05CC,B1 BA,,        ACALL   DECDP           ;PUT DPTR BACK
05CE,B5 01 03,,        CJNE    A,R1B0,D1       ;DO THE COMPARE
05D1,B3,,        CPL     C               ;FLIP CARRY
,,,        ;
05D2,B2 2A,,        CPL     UBIT            ;SET IT
05D4,B3,D1,D1:     CPL     C               ;GET THE CARRY RIGHT
05D5,22,,        RET                     ;EXIT
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,        ; ADDPTR - Add acc to the dptr
,,,        ;
,,,        ; acc gets wasted
,,,        ;
,,,        ;***************************************************************
,,,        ;
05D6,25 82,ADDPTR,ADDPTR: ADD     A,DPL           ;ADD THE ACC TO DPL
05D8,F5 82,,        MOV     DPL,A           ;PUT IT IN DPL
05DA,50 02,,        JNC     $+4             ;JUMP IF NO CARRY
05DC,05 83,,        INC     DPH             ;BUMP DPH
05DE,22,,        RET                     ;EXIT
,,,        ;
,,,$EJECT
,,,        ;*************************************************************
,,,        ;
05DF,,LCLR,LCLR:   ; Set up the storage allocation
,,,        ;
,,,        ;*************************************************************
,,,        ;
05DF,D1 92,,        ACALL   ICLR            ;CLEAR THE INTERRUPTS
05E1,B1 A1,,        ACALL   G4              ;PUT END ADDRESS INTO DPTR
05E3,74 06,,        MOV     A,#6            ;ADJUST MATRIX SPACE
05E5,B1 D6,,        ACALL   ADDPTR          ;ADD FOR PROPER BOUNDS
05E7,B1 71,,        ACALL   X31DP           ;PUT MATRIX BOUNDS IN R3:R1
05E9,90 01 08,,        MOV     DPTR,#MT_ALL    ;SAVE R3:R1 IN MATRIX FREE SPACE
05EC,B1 FD,,        ACALL   S31DP           ;DPTR POINTS TO MEMTOP
05EE,B1 B2,,        ACALL   L31DPI          ;LOAD MEMTOP INTO R3:R1
05F0,90 01 22,,        MOV     DPTR,#STR_AL    ;GET MEMORY ALLOCATED FOR STRINGS
05F3,B1 A8,,        ACALL   LDPTRI
05F5,12 0A 0A,,        CALL    DUBSUB          ;R3:R1 = MEMTOP - STRING ALLOCATION
05F8,90 01 04,,        MOV     DPTR,#VARTOP    ;SAVE R3:R1 IN VARTOP
,,,        ;
,,,        ; FALL THRU TO S31DP2
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,        ;S31DP - STORE R3 INTO (DPTR) AND R1 INTO (DPTR+1)
,,,        ;
,,,        ;ACC GETS CLOBBERED
,,,        ;
,,,        ;***************************************************************
,,,        ;
05FB,B1 FD,S31DP2,S31DP2: ACALL   S31DP           ;DO IT TWICE
,,,        ;
05FD,EB,S31DP,S31DP:  MOV     A,R3            ;GET R3 INTO ACC
05FE,F0,,        MOVX    @DPTR,A         ;STORE IT
05FF,A3,,        INC     DPTR            ;BUMP DPTR
0600,E9,,        MOV     A,R1            ;GET R1
0601,F0,,        MOVX    @DPTR,A         ;STORE IT
0602,A3,,        INC     DPTR            ;BUMP IT AGAIN TO SAVE PROGRAM SPACE
0603,22,,        RET                     ;GO BACK
,,,        ;
,,,        ;
,,,        ;***************************************************************
,,,        ;
0604,,STRING,STRING: ; Allocate memory for strings
,,,        ;
,,,        ;***************************************************************
,,,        ;
0604,12 0E 8E,,        LCALL   TWO             ;R3:R1 = NUMBER, R2:R0 = LEN
0607,90 01 22,,        MOV     DPTR,#STR_AL    ;SAVE STRING ALLOCATION
060A,B1 FD,,        ACALL   S31DP
060C,0E,,        INC     R6              ;BUMP
060D,8E 3F,,        MOV     S_LEN,R6        ;SAVE STRING LENGTH
060F,C1 5C,,        AJMP    RCLEAR          ;CLEAR AND SET IT UP
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; F_VAR - Find  the variable in symbol table
,,,        ;         R7:R6 contain the variable name
,,,        ;         If not found create a zero entry and set the carry
,,,        ;         R2:R0 has the address of variable on return
,,,        ;
,,,        ;***************************************************************
,,,        ;
0611,90 01 04,F_VAR,F_VAR:  MOV     DPTR,#VARTOP    ;PUT VARTOP IN DPTR
0614,B1 A8,,        ACALL   LDPTRI
0616,B1 B8,,        ACALL   DECDP2          ;ADJUST DPTR FOR LOOKUP
,,,        ;
0618,E0,F_VAR0,F_VAR0: MOVX    A,@DPTR         ;LOAD THE VARIABLE
0619,60 20,,        JZ      F_VAR2          ;TEST IF AT THE END OF THE TABLE
061B,A3,,        INC     DPTR            ;BUMP FOR NEXT BYTE
061C,B5 07 0F,,        CJNE    A,R7B0,F_VAR1   ;SEE IF MATCH
061F,E0,,        MOVX    A,@DPTR         ;LOAD THE NAME
0620,B5 06 0B,,        CJNE    A,R6B0,F_VAR1
,,,        ;
,,,        ; Found the variable now adjust and put in R2:R0
,,,        ;
0623,E5 82,DLD,DLD:    MOV     A,DPL           ;R2:R0 = DPTR-2
0625,94 02,,        SUBB    A,#2
0627,F8,,        MOV     R0,A
0628,E5 83,,        MOV     A,DPH
062A,94 00,,        SUBB    A,#0            ;CARRY IS CLEARED
062C,FA,,        MOV     R2,A
062D,22,,        RET
,,,        ;
062E,E5 82,F_VAR1,F_VAR1: MOV     A,DPL           ;SUBTRACT THE STACK SIZE+ADJUST
0630,C3,,        CLR     C
0631,94 09,,        SUBB    A,#STESIZ
0633,F5 82,,        MOV     DPL,A           ;RESTORE DPL
0635,50 E1,,        JNC     F_VAR0
0637,15 83,,        DEC     DPH
0639,80 DD,,        SJMP    F_VAR0          ;CONTINUE COMPARE
,,,        ;
,,,$EJECT
,,,        ;
,,,        ; Add the entry to the symbol table
,,,        ;
063B,12 0D F8,F_VAR2,F_VAR2: LCALL   R76S            ;SAVE R7 AND R6
063E,C3,,        CLR     C
063F,D1 23,,        ACALL   DLD             ;BUMP THE POINTER TO GET ENTRY ADDRESS
,,,        ;
,,,        ; Adjust pointer and save storage allocation
,,,        ; and make sure we aren't wiping anything out
,,,        ; First calculate new storage allocation
,,,        ;
0641,E8,,        MOV     A,R0
0642,94 06,,        SUBB    A,#STESIZ-3     ;NEED THIS MUCH RAM
0644,F9,,        MOV     R1,A
0645,EA,,        MOV     A,R2
0646,94 00,,        SUBB    A,#0
0648,FB,,        MOV     R3,A
,,,        ;
,,,        ; Now save the new storage allocation
,,,        ;
0649,90 01 06,,        MOV     DPTR,#ST_ALL
064C,B1 FD,,        CALL    S31DP           ;SAVE STORAGE ALLOCATION
,,,        ;
,,,        ; Now make sure we didn't blow it, by wiping out MT_ALL
,,,        ;
064E,B1 C4,,        ACALL   DCMPX           ;COMPARE STORAGE ALLOCATION
0650,40 32,,        JC      CCLR3           ;ERROR IF CARRY
0652,D3,,        SETB    C               ;DID NOT FIND ENTRY
0653,22,,        RET                     ;EXIT IF TEST IS OK
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; Command action routine - NEW
,,,        ;
,,,        ;***************************************************************
,,,        ;
0654,90 02 00,CNEW,CNEW:   MOV     DPTR,#PSTART    ;SAVE THE START OF PROGRAM
0657,74 01,,        MOV     A,#EOF          ;END OF FILE
0659,F0,,        MOVX    @DPTR,A         ;PUT IT IN MEMORY
,,,        ;
,,,        ; falls thru
,,,        ;
,,,        ;*****************************************************************
,,,        ;
,,,        ; The statement action routine - CLEAR
,,,        ;
,,,        ;*****************************************************************
,,,        ;
065A,C2 15,,        CLR     LINEB           ;SET UP FOR RUN AND GOTO
,,,        ;
065C,B1 DF,RCLEAR,RCLEAR: ACALL   LCLR            ;CLEAR THE INTERRUPTS, SET UP MATRICES
065E,90 01 0A,,        MOV     DPTR,#MEMTOP    ;PUT MEMTOP IN R3:R1
0661,B1 B2,,        ACALL   L31DPI
0663,B1 A1,,        ACALL   G4              ;DPTR GETS END ADDRESS
0665,D1 75,,        ACALL   CL_1            ;CLEAR THE MEMORY
,,,        ;
0667,90 00 FE,RC1,RC1:    MOV     DPTR,#STACKTP   ;POINT AT CONTROL STACK TOP
066A,E4,,        CLR     A               ;CONTROL UNDERFLOW
,,,        ;
066B,F0,RC2,RC2:    MOVX    @DPTR,A         ;SAVE IN MEMORY
066C,75 11 FE,,        MOV     CSTKA,#STACKTP
066F,75 09 FE,,        MOV     ASTKA,#STACKTP
0672,C2 17,,        CLR     CONB            ;CAN'T CONTINUE
0674,22,,        RET
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; Loop until the memory is cleared
,,,        ;
,,,        ;***************************************************************
,,,        ;
0675,A3,CL_1,CL_1:   INC     DPTR            ;BUMP MEMORY POINTER
0676,E4,,        CLR     A               ;CLEAR THE MEMORY
0677,F0,,        MOVX    @DPTR,A         ;CLEAR THE RAM
0678,E0,,        MOVX    A,@DPTR         ;READ IT
0679,70 09,,        JNZ     CCLR3           ;MAKE SURE IT IS CLEARED
067B,EB,,        MOV     A,R3            ;GET POINTER FOR COMPARE
067C,B5 83 F6,,        CJNE    A,DPH,CL_1      ;SEE TO LOOP
067F,E9,,        MOV     A,R1            ;NOW TEST LOW BYTE
0680,B5 82 F2,,        CJNE    A,DPL,CL_1
,,,        ;
0683,22,CL_2,CL_2:   RET
,,,        ;
0684,02 15 A7,CCLR3,CCLR3:  JMP     TB              ;ALLOCATED MEMORY DOESN'T EXSIST
,,,        ;
,,,        ;**************************************************************
,,,        ;
0687,,SCLR,SCLR:   ;Entry point for clear return
,,,        ;
,,,        ;**************************************************************
,,,        ;
0687,12 0E EA,,        CALL    DELTST          ;TEST FOR A CR
068A,50 D0,,        JNC     RCLEAR
068C,12 0E E0,,        CALL    GCI1            ;BUMP THE TEST POINTER
068F,B4 49 D5,,        CJNE    A,#'I',RC1      ;SEE IF I, ELSE RESET THE STACK
,,,        ;
,,,        ;**************************************************************
,,,        ;
0692,,ICLR,ICLR:   ; Clear interrupts and system garbage
,,,        ;
,,,        ;**************************************************************
,,,        ;
0692,30 12 02,,        JNB     INTBIT,$+5      ;SEE IF BASIC HAS INTERRUPTS
0695,C2 AA,,        CLR     EX1             ;IF SO, CLEAR INTERRUPTS
0697,53 22 20,,        ANL     34,#00100000B   ;SET INTERRUPTS + CONTINUE
069A,32,,        RETI
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ;OUTPUT ROUTINES
,,,        ;
,,,        ;***************************************************************
,,,        ;
069B,D1 9D,CRLF2,CRLF2:  ACALL   CRLF            ;DO TWO CRLF'S
,,,        ;
069D,7D 0D,CRLF,CRLF:   MOV     R5,#CR          ;LOAD THE CR
069F,F1 09,,        ACALL   TEROT           ;CALL TERMINAL OUT
06A1,7D 0A,,        MOV     R5,#LF          ;LOAD THE LF
06A3,E1 09,,        AJMP    TEROT           ;OUTPUT IT AND RETURN
,,,        ;
,,,        ;PRINT THE MESSAGE ADDRESSED IN ROM OR RAM BY THE DPTR
,,,        ;ENDS WITH THE CHARACTER IN R4
,,,        ;DPTR HAS THE ADDRESS OF THE TERMINATOR
,,,        ;
06A5,D1 9D,CRP,CRP:    ACALL   CRLF            ;DO A CR THEN PRINT ROM
,,,        ;
06A7,E4,ROM_P,ROM_P:  CLR     A               ;CLEAR A FOR LOOKUP
06A8,93,,        MOVC    A,@A+DPTR       ;GET THE CHARACTER
06A9,C2 E7,,        CLR     ACC.7           ;CLEAR MS BIT
06AB,B4 22 01,,        CJNE    A,#'"',$+4      ;EXIT IF TERMINATOR
06AE,22,,        RET
06AF,D2 34,,        SETB    C0ORX1
,,,        ;
06B1,FD,PN1,PN1:    MOV     R5,A            ;OUTPUT THE CHARACTER
06B2,F1 09,,        ACALL   TEROT
06B4,A3,,        INC     DPTR            ;BUMP THE POINTER
06B5,80 04,,        SJMP    PN0
,,,        ;
06B7,B1 71,UPRNT,UPRNT:  ACALL   X31DP
,,,        ;
06B9,7C 0D,PRNTCR,PRNTCR: MOV     R4,#CR          ;OUTPUT UNTIL A CR
,,,        ;
06BB,10 34 E9,PN0,PN0:    JBC     C0ORX1,ROM_P
06BE,E0,,        MOVX    A,@DPTR         ;GET THE RAM BYTE
06BF,60 03,,        JZ      $+5
06C1,B5 04 01,,        CJNE    A,R4B0,$+4      ;SEE IF THE SAME AS TERMINATOR
06C4,22,,        RET                     ;EXIT IF THE SAME
06C5,B4 0D E9,,        CJNE    A,#CR,PN1       ;NEVER PRINT A CR IN THIS ROUTINE
06C8,02 18 86,,        LJMP    E1XX            ;BAD SYNTAX
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; INLINE - Input a line to IBUF, exit when a CR is received
,,,        ;
,,,        ;***************************************************************
,,,        ;
06CB,B4 04 16,INL2,INL2:   CJNE    A,#CNTRLD,INL2B ;SEE IF A CONTROL D
,,,        ;
06CE,D1 9D,INL0,INL0:   ACALL   CRLF            ;DO A CR
,,,        ;
06D0,75 A0 00,INLINE,INLINE: MOV     P2,#HIGH IBUF   ;IBUF IS IN THE ZERO PAGE
06D3,78 07,,        MOV     R0,#LOW IBUF    ;POINT AT THE INPUT BUFFER
,,,        ;
06D5,F1 89,INL1,INL1:   ACALL   INCHAR          ;GET A CHARACTER
06D7,FD,,        MOV     R5,A            ;SAVE IN R5 FOR OUTPUT
06D8,B4 08 F0,,        CJNE    A,#BS,INL2      ;SEE IF A DELETE CHARACTER
06DB,B8 07 18,,        CJNE    R0,#LOW IBUF,INL6
06DE,7D 07,,        MOV     R5,#BELL        ;OUTPUT A BELL
,,,        ;
06E0,F1 09,INLX,INLX:   ACALL   TEROT           ;OUTPUT CHARACTER
06E2,80 F1,,        SJMP    INL1            ;DO IT AGAIN
,,,        ;
06E4,F2,INL2B,INL2B:  MOVX    @R0,A           ;SAVE THE CHARACTER
06E5,B4 0D 02,,        CJNE    A,#CR,$+5       ;IS IT A CR
06E8,C1 9D,,        AJMP    CRLF            ;OUTPUT A CRLF AND EXIT
06EA,B4 20 00,,        CJNE    A,#20H,$+3
06ED,40 F1,,        JC      INLX            ;ONLY ECHO CONTROL CHARACTERS
06EF,08,,        INC     R0              ;BUMP THE POINTER
06F0,B8 56 ED,,        CJNE    R0,#IBUF+79,INLX
06F3,18,,        DEC     R0              ;FORCE 79
06F4,80 E8,,        SJMP    INLX-2          ;OUTPUT A BELL
,,,        ;
06F6,18,INL6,INL6:   DEC     R0              ;DEC THE RAM POINTER
06F7,7D 08,,        MOV     R5,#BS          ;OUTPUT A BACK SPACE
06F9,F1 09,,        ACALL   TEROT
06FB,F1 07,,        ACALL   STEROT          ;OUTPUT A SPACE
06FD,7D 08,,        MOV     R5,#BS          ;ANOTHER BACK SPACE
06FF,80 DF,,        SJMP    INLX            ;OUTPUT IT
,,,        ;
0701,7E,PTIME,PTIME:  DB      128-2           ; PROM PROGRAMMER TIMER
0702,00,,        DB      00H
0703,00,,        DB      00H
0704,50,,        DB      50H
0705,67,,        DB      67H
0706,41,,        DB      41H
,,,        ;
,,,$EJECT
,,,;$INCLUDE(:F2:BAS52.OUT)
,,,;BEGINNING
,,,        ;***************************************************************
,,,        ;
,,,        ; TEROT - Output a character to the system console
,,,        ;         update PHEAD position.
,,,        ;
,,,        ;***************************************************************
,,,        ;
0707,7D 20,STEROT,STEROT: MOV     R5,#' '         ;OUTPUT A SPACE
,,,        ;
0709,C0 E0,TEROT,TEROT:  PUSH    ACC             ;SAVE THE ACCUMULATOR
070B,C0 83,,        PUSH    DPH             ;SAVE THE DPTR
070D,C0 82,,        PUSH    DPL
070F,30 35 04,,        JNB     CNT_S,$+7       ;WAIT FOR A CONTROL Q
0712,F1 85,,        ACALL   BCK             ;GET SERIAL STATUS
0714,80 F9,,        SJMP    $-5
0716,ED,,        MOV     A,R5            ;PUT OUTPUT BYTE IN A
0717,30 2C 05,,        JNB     BO,$+8          ;CHECK FOR MONITOR
071A,12 20 40,,        LCALL   2040H           ;DO THE MONITOR
071D,E1 5E,,        AJMP    TEROT1          ;CLEAN UP
071F,30 1C 05,,        JNB     COUB,$+8        ;SEE IF USER WANTS OUTPUT
0722,12 40 30,,        LCALL   4030H
0725,E1 5E,,        AJMP    TEROT1
0727,30 27 08,,        JNB     UPB,T_1         ;NO AT IF NO XBIT
072A,30 19 05,,        JNB     LPB,T_1         ;AT PRINT
072D,12 40 3C,,        LCALL   403CH           ;CALL AT LOCATION
0730,E1 5E,,        AJMP    TEROT1          ;FINISH OFF OUTPUT
,,,        ;
0732,30 1B 22,T_1,T_1:    JNB     COB,TXX         ;SEE IF LIST SET
0735,90 01 24,,        MOV     DPTR,#SPV       ;LOAD BAUD RATE
0738,B1 7A,,        ACALL   LD_T
073A,C2 97,,        CLR     LP              ;OUTPUT START BIT
073C,B1 27,,        ACALL   TIMER_LOAD      ;LOAD AND START THE TIMER
073E,ED,,        MOV     A,R5            ;GET THE OUTPUT BYTE
073F,D3,,        SETB    C               ;SET CARRY FOR LAST OUTPUT
0740,7D 09,,        MOV     R5,#9           ;LOAD TIMER COUNTDOWN
,,,        ;
0742,13,LTOUT1,LTOUT1: RRC     A               ;ROTATE A
0743,30 8F FD,,        JNB     TF1,$           ;WAIT TILL TIMER READY
0746,92 97,,        MOV     LP,C            ;OUTPUT THE BIT
0748,B1 27,,        ACALL   TIMER_LOAD      ;DO THE NEXT BIT
074A,DD F6,,        DJNZ    R5,LTOUT1       ;LOOP UNTIL DONE
074C,30 8F FD,,        JNB     TF1,$           ;FIRST STOP BIT
074F,B1 27,,        ACALL   TIMER_LOAD
0751,30 8F FD,,        JNB     TF1,$           ;SECOND STOP BIT
0754,FD,,        MOV     R5,A            ;RESTORE R5
0755,80 07,,        SJMP    TEROT1          ;BACK TO TEROT
,,,        ;
,,,$EJECT
0757,30 99 FD,TXX,TXX:    JNB     TI,$            ;WAIT FOR TRANSMIT READY
075A,C2 99,,        CLR     TI
075C,8D 99,,        MOV     SBUF,R5         ;SEND OUT THE CHARACTER
,,,        ;
075E,BD 0D 03,TEROT1,TEROT1: CJNE    R5,#CR,$+6      ;SEE IF A CR
0761,75 16 00,,        MOV     PHEAD,#00H      ;IF A CR, RESET PHEAD AND
,,,        ;
0764,BD 0A 0B,,        CJNE    R5,#LF,NLC      ;SEE IF A LF
0767,E5 15,,        MOV     A,NULLCT        ;GET THE NULL COUNT
0769,60 07,,        JZ      NLC             ;NO NULLS IF ZERO
,,,        ;
076B,7D 00,TEROT2,TEROT2: MOV     R5,#NULL        ;PUT THE NULL IN THE OUTPUT REGISTER
076D,F1 09,,        ACALL   TEROT           ;OUTPUT THE NULL
076F,14,,        DEC     A               ;DECREMENT NULL COUNT
0770,70 F9,,        JNZ     TEROT2          ;LOOP UNTIL DONE
,,,        ;
0772,BD 08 02,NLC,NLC:    CJNE    R5,#BS,$+5      ;DEC PHEAD IF A BACKSPACE
0775,15 16,,        DEC     PHEAD
0777,BD 20 00,,        CJNE    R5,#20H,$+3     ;IS IT A PRINTABLE CHARACTER?
077A,40 02,,        JC      $+4             ;DON'T INCREMENT PHEAD IF NOT PRINTABLE
077C,05 16,,        INC     PHEAD           ;BUMP PRINT HEAD
077E,D0 82,,        POP     DPL             ;RESTORE DPTR
0780,D0 83,,        POP     DPH
0782,D0 E0,,        POP     ACC             ;RESTORE ACC
0784,22,,        RET                     ;EXIT
,,,        ;
,,,
,,,;END
,,,;$INCLUDE(:F2:BAS52.OUT)
,,,        ;
0785,F1 C4,BCK,BCK:    ACALL   CSTS            ;CHECK STATUS
0787,50 32,,        JNC     CI_RET+1        ;EXIT IF NO CHARACTER
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ;INPUTS A CHARACTER FROM THE SYSTEM CONSOLE.
,,,        ;
,,,        ;***************************************************************
,,,        ;
0789,30 32 05,INCHAR,INCHAR: JNB     BI,$+8          ;CHECK FOR MONITOR (BUBBLE)
078C,12 20 60,,        LCALL   2060H
078F,80 11,,        SJMP    INCH1
0791,30 1E 05,,        JNB     CIUB,$+8        ;CHECK FOR USER
0794,12 40 33,,        LCALL   4033H
0797,80 09,,        SJMP    INCH1
0799,30 98 FD,,        JNB     RI,$            ;WAIT FOR RECEIVER READY.
079C,E5 99,,        MOV     A,SBUF
079E,C2 98,,        CLR     RI              ;RESET READY
07A0,C2 E7,,        CLR     ACC.7           ;NO BIT 7
,,,        ;
07A2,B4 13 02,INCH1,INCH1:  CJNE    A,#13H,$+5
07A5,D2 35,,        SETB    CNT_S
07A7,B4 11 02,,        CJNE    A,#11H,$+5
07AA,C2 35,,        CLR     CNT_S
07AC,B4 03 04,,        CJNE    A,#CNTRLC,$+7
07AF,30 30 26,,        JNB     NO_C,C_EX       ;TRAP NO CONTROL C
07B2,22,,        RET
,,,        ;
07B3,C2 28,,        CLR     JKBIT
07B5,B4 17 02,,        CJNE    A,#17H,CI_RET   ;CONTROL W
07B8,D2 28,,        SETB    JKBIT
,,,        ;
07BA,D3,CI_RET,CI_RET: SETB    C               ;CARRY SET IF A CHARACTER
07BB,22,,        RET                     ;EXIT
,,,        ;
,,,        ;*************************************************************
,,,        ;
,,,        ;RROM - The Statement Action Routine RROM
,,,        ;
,,,        ;*************************************************************
,,,        ;
07BC,D2 1D,RROM,RROM:   SETB    INBIT           ;SO NO ERRORS
07BE,B1 3D,,        ACALL   RO1             ;FIND THE LINE NUMBER
07C0,10 1D 43,,        JBC     INBIT,CRUN
07C3,22,,        RET                     ;EXIT
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
07C4,,CSTS,CSTS:   ;       RETURNS CARRY = 1 IF THERE IS A CHARACTER WAITING FROM
,,,        ;       THE SYSTEM CONSOLE. IF NO CHARACTER THE READY CHARACTER
,,,        ;       WILL BE CLEARED
,,,        ;
,,,        ;***************************************************************
,,,        ;
07C4,30 32 03,,        JNB     BI,$+6          ;BUBBLE STATUS
07C7,02 20 68,,        LJMP    2068H
07CA,30 1E 03,,        JNB     CIUB,$+6        ;SEE IF EXTERNAL CONSOLE
07CD,02 40 36,,        LJMP    4036H
07D0,A2 98,,        MOV     C,RI
07D2,22,,        RET
,,,        ;
07D3,90 19 69,,        MOV     DPTR,#WB        ;EGO MESSAGE
07D6,D1 A7,,        ACALL   ROM_P
,,,        ;
07D8,C2 35,C_EX,C_EX:   CLR     CNT_S           ;NO OUTPUT STOP
07DA,12 0C 39,,        LCALL   SPRINT+4        ;ASSURE CONSOLE
07DD,D1 9D,,        ACALL   CRLF
07DF,10 28 F1,,        JBC     JKBIT,C_EX-5
,,,        ;
07E2,30 2F 7F,,        JNB     DIRF,SSTOP0
07E5,A1 3A,,        AJMP    C_K             ;CLEAR COB AND EXIT
,,,        ;
07E7,E5 48,T_CMP,T_CMP:  MOV     A,TVH           ;COMPARE TIMER TO SP_H AND SP_L
07E9,A9 49,,        MOV     R1,TVL
07EB,B5 48 F9,,        CJNE    A,TVH,T_CMP
07EE,C9,,        XCH     A,R1
07EF,95 4C,,        SUBB    A,SP_L
07F1,E9,,        MOV     A,R1
07F2,95 4B,,        SUBB    A,SP_H
07F4,22,,        RET
,,,        ;
,,,        ;*************************************************************
,,,        ;
07F5,,BR0,BR0:    ; Trap the timer interrupt
,,,        ;
,,,        ;*************************************************************
,,,        ;
07F5,F1 E7,,        CALL    T_CMP           ;COMPARE TIMER
07F7,40 40,,        JC      BCHR+6          ;EXIT IF TEST FAILS
07F9,D2 14,,        SETB    OTI             ;DOING THE TIMER INTERRUPT
07FB,C2 10,,        CLR     OTS             ;CLEAR TIMER BIT
07FD,A2 11,,        MOV     C,INPROG        ;SAVE IN PROGRESS
07FF,92 2B,,        MOV     ISAV,C
0801,90 01 26,,        MOV     DPTR,#TIV
0804,80 3C,,        SJMP    BR2
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; The command action routine - RUN
,,,        ;
,,,        ;***************************************************************
,,,        ;
0806,12 06 5A,CRUN,CRUN:   LCALL   RCLEAR-2        ;CLEAR THE STORAGE ARRAYS
0809,71 D8,,        ACALL   SRESTR+2        ;GET THE STARTING ADDRESS
080B,51 AC,,        ACALL   B_C
080D,60 4A,,        JZ      CMNDLK          ;IF NULL GO TO COMMAND MODE
,,,        ;
080F,D1 C1,,        ACALL   T_DP
0811,F1 2C,,        ACALL   B_TXA           ;BUMP TO STARTING LINE
,,,        ;
0813,91 44,CILOOP,CILOOP: ACALL   SP0             ;DO A CR AND A LF
0815,C2 2F,,        CLR     DIRF            ;NOT IN DIRECT MODE
,,,        ;
,,,        ;INTERPERTER DRIVER
,,,        ;
0817,85 3E 81,ILOOP,ILOOP:  MOV     SP,SPSAV        ;RESTORE THE STACK EACH TIME
081A,20 2F 06,,        JB      DIRF,$+9        ;NO INTERRUPTS IF IN DIRECT MODE
081D,85 0A 42,,        MOV     INTXAH,TXAH     ;SAVE THE TEXT POINTER
0820,85 08 43,,        MOV     INTXAL,TXAL
0823,12 07 85,,        LCALL   BCK             ;GET CONSOLE STATUS
0826,20 2F 24,,        JB      DIRF,I_L        ;DIRECT MODE
0829,B0 18,,        ANL     C,/GTRD         ;SEE IF CHARACTER READY
082B,50 06,,        JNC     BCHR            ;NO CHARACTER = NO CARRY
,,,        ;
,,,        ; DO TRAP OPERATION
,,,        ;
082D,90 01 00,,        MOV     DPTR,#GTB       ;SAVE TRAP CHARACTER
0830,F0,,        MOVX    @DPTR,A
0831,D2 18,,        SETB    GTRD            ;SAYS READ A BYTE
,,,        ;
0833,20 14 17,BCHR,BCHR:   JB      OTI,I_L         ;EXIT IF TIMER INTERRUPT IN PROGRESS
0836,20 10 BC,,        JB      OTS,BR0         ;TEST TIMER VALUE IF SET
0839,30 16 11,,        JNB     INTPEN,I_L      ;SEE IF INTERRUPT PENDING
083C,20 11 0E,,        JB      INPROG,I_L      ;DON'T DO IT AGAIN IF IN PROGRESS
083F,90 01 20,,        MOV     DPTR,#INTLOC    ;POINT AT INTERRUPT LOCATION
,,,        ;
0842,7C 02,BR2,BR2:    MOV     R4,#GTYPE       ;SETUP FOR A FORCED GOSUB
0844,71 3D,,        ACALL   SGS1            ;PUT TXA ON STACK
0846,D2 11,,        SETB    INPROG          ;INTERRUPT IN PROGRESS
,,,        ;
0848,12 05 6B,ERL4,ERL4:   CALL    L20DPI
084B,61 00,,        AJMP    D_L1            ;GET THE LINE NUMBER
,,,        ;
084D,31 00,I_L,I_L:    ACALL   ISTAT           ;LOOP
084F,F1 20,,        ACALL   CLN_UP          ;FINISH IT OFF
0851,50 C4,,        JNC     ILOOP           ;LOOP ON THE DRIVER
0853,30 2F 03,,        JNB     DIRF,CMNDLK     ;CMND1 IF IN RUN MODE
0856,02 17 9B,,        LJMP    CMNDR           ;DON'T PRINT READY
,,,        ;
0859,02 17 85,CMNDLK,CMNDLK: JMP     CMND1           ;DONE
,,,$EJECT
,,,        ;**************************************************************
,,,        ;
,,,        ; The Statement Action Routine - STOP
,,,        ;
,,,        ;**************************************************************
,,,        ;
085C,F1 20,SSTOP,SSTOP:  ACALL   CLN_UP          ;FINISH OFF THIS LINE
085E,85 0A 42,,        MOV     INTXAH,TXAH     ;SAVE TEXT POINTER FOR CONT
0861,85 08 43,,        MOV     INTXAL,TXAL
,,,        ;
0864,D2 17,SSTOP0,SSTOP0: SETB    CONB            ;CONTINUE WILL WORK
0866,90 00 EC,,        MOV     DPTR,#STP       ;PRINT THE STOP MESSAGE
0869,D2 20,,        SETB    STOPBIT         ;SET FOR ERROR ROUTINE
086B,02 18 AE,,        JMP     ERRS            ;JUMP TO ERROR ROUTINE
,,,        ;
,,,$EJECT
,,,        ;**************************************************************
,,,        ;
,,,        ; ITRAP - Trap special function register operators
,,,        ;
,,,        ;**************************************************************
,,,        ;
086E,B4 C8 05,ITRAP,ITRAP:  CJNE    A,#TMR0,$+8     ;TIMER 0
0871,8B 8C,,        MOV     TH0,R3
0873,89 8A,,        MOV     TL0,R1
0875,22,,        RET
,,,        ;
0876,B4 C9 05,,        CJNE    A,#TMR1,$+8     ;TIMER 1
0879,8B 8D,,        MOV     TH1,R3
087B,89 8B,,        MOV     TL1,R1
087D,22,,        RET
,,,        ;
087E,B4 CA 05,,        CJNE    A,#TMR2,$+8     ;TIMER 2
0881,8B,,        DB      8BH             ;MOV R3 DIRECT OP CODE
0882,CD,,        DB      0CDH            ;T2H LOCATION
0883,89,,        DB      89H             ;MOV R1 DIRECT OP CODE
0884,CC,,        DB      0CCH            ;T2L LOCATION
0885,22,,        RET
,,,        ;
0886,B4 CE 05,,        CJNE    A,#TRC2,$+8     ;RCAP2 TOKEN
,,,
0889,BB FF 04,RCL,RCL:    CJNE    R3,#0FFh,RCL1   ;JKJ: Don't allow to load FF
088C,B9 FF 01,,        CJNE    R1,#0FFh,RCL1
088F,22,,        RET
,,,
0890,8B,RCL1,RCL1:   DB      8BH             ;MOV R3 DIRECT OP CODE
0891,CB,,        DB      0CBH            ;RCAP2H LOCATION
0892,89,,        DB      89H             ;MOV R1 DIRECT OP CODE
0893,CA,,        DB      0CAH            ;RCAP2L LOCATION
0894,22,,        RET
,,,        ;
0895,31 DD,,        ACALL   R3CK            ;MAKE SURE THAT R3 IS ZERO
0897,B4 CB 03,,        CJNE    A,#TT2C,$+6
089A,89,,        DB      89H             ;MOV R1 DIRECT OP CODE
089B,C8,,        DB      0C8H            ;T2CON LOCATION
089C,22,,        RET
,,,        ;
089D,B4 C6 03,,        CJNE    A,#T_IE,$+6     ;IE TOKEN
08A0,89 A8,,        MOV     IE,R1
08A2,22,,        RET
,,,        ;
08A3,B4 C7 03,,        CJNE    A,#T_IP,$+6     ;IP TOKEN
08A6,89 B8,,        MOV     IP,R1
08A8,22,,        RET
,,,        ;
08A9,B4 CC 03,,        CJNE    A,#TTC,$+6      ;TCON TOKEN
08AC,89 88,,        MOV     TCON,R1
08AE,22,,        RET
,,,        ;
08AF,B4 CD 03,,        CJNE    A,#TTM,$+6      ;TMOD TOKEN
08B2,89 89,,        MOV     TMOD,R1
08B4,22,,        RET
,,,        ;
08B5,B4 CF 2F,,        CJNE    A,#T_P1,T_T2    ;P1 TOKEN
08B8,89 90,,        MOV     P1,R1
08BA,22,,        RET
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,        ; T_TRAP - Trap special operators
,,,        ;
,,,        ;***************************************************************
,,,        ;
08BB,F5 0F,T_T,T_T:    MOV     TEMP5,A         ;SAVE THE TOKEN
08BD,D1 E0,,        ACALL   GCI1            ;BUMP POINTER
08BF,31 D0,,        ACALL   SLET2           ;EVALUATE AFTER =
08C1,E5 0F,,        MOV     A,TEMP5         ;GET THE TOKEN BACK
08C3,B4 C3 03,,        CJNE    A,#T_XTAL,$+6
08C6,02 16 4E,,        LJMP    AXTAL1          ;SET UP CRYSTAL
,,,        ;
08C9,D1 99,,        ACALL   IFIXL           ;R3:R1 HAS THE TOS
08CB,E5 0F,,        MOV     A,TEMP5         ;GET THE TOKEN AGAIN
08CD,B4 C4 09,,        CJNE    A,#T_MTOP,T_T1  ;SEE IF MTOP TOKEN
08D0,90 01 0A,,        MOV     DPTR,#MEMTOP
08D3,12 05 FD,,        CALL    S31DP
08D6,02 06 5C,,        JMP     RCLEAR          ;CLEAR THE MEMORY
,,,        ;
08D9,B4 C5 92,T_T1,T_T1:   CJNE    A,#T_TIME,ITRAP ;SEE IF A TIME TOKEN
08DC,A2 AF,,        MOV     C,EA            ;SAVE INTERRUPTS
08DE,C2 AF,,        CLR     EA              ;NO TIMER 0 INTERRUPTS DURING LOAD
08E0,8B 48,,        MOV     TVH,R3          ;SAVE THE TIME
08E2,89 49,,        MOV     TVL,R1
08E4,92 AF,,        MOV     EA,C            ;RESTORE INTERRUPTS
08E6,22,,        RET                     ;EXIT
,,,        ;
08E7,B4 D0 56,T_T2,T_T2:   CJNE    A,#T_PC,INTERX  ;PCON TOKEN
08EA,89,,        DB      89H             ;MOV DIRECT, R1 OP CODE
08EB,87,,        DB      87H             ;ADDRESS OF PCON
08EC,22,,        RET                     ;EXIT
,,,        ;
08ED,B4 D1 CB,T_TRAP,T_TRAP: CJNE    A,#T_ASC,T_T    ;SEE IF ASC TOKEN
08F0,D1 D4,,        ACALL   IGC             ;EAT IT AND GET THE NEXT CHARACTER
08F2,B4 24 4B,,        CJNE    A,#'$',INTERX   ;ERROR IF NOT A STRING
08F5,51 26,,        ACALL   CSY             ;CALCULATE ADDRESS
08F7,B1 B6,,        ACALL   X3120
08F9,12 14 A6,,        CALL    TWO_EY
08FC,31 E5,,        ACALL   SPEOP+4         ;EVALUATE AFTER EQUALS
08FE,21 29,,        AJMP    ISTAX1          ;SAVE THE CHARACTER
,,,        ;
,,,$EJECT
,,,        ;**************************************************************
,,,        ;
,,,        ;INTERPERT THE STATEMENT POINTED TO BY TXAL AND TXAH
,,,        ;
,,,        ;**************************************************************
,,,        ;
0900,D1 D6,ISTAT,ISTAT:  ACALL   GC              ;GET THR FIRST CHARACTER
0902,30 2D 0E,,        JNB     XBIT,IAT        ;TRAP TO EXTERNAL RUN PACKAGE
0905,B4 20 00,,        CJNE    A,#20H,$+3
0908,50 09,,        JNC     IAT
090A,12 20 70,,        LCALL   2070H           ;LET THE USER SET UP THE DPTR
090D,D1 E0,,        ACALL   GCI1
090F,54 0F,,        ANL     A,#0FH          ;STRIP OFF BIAS
0911,80 51,,        SJMP    ISTA1
,,,        ;
0913,B4 C3 00,IAT,IAT:    CJNE    A,#T_XTAL,$+3
0916,50 D5,,        JNC     T_TRAP
0918,30 E7 5B,,        JNB     ACC.7,SLET      ;IMPLIED LET IF BIT 7 NOT SET
091B,B4 BC 06,,        CJNE    A,#T_UOP+12,ISTAX       ;DBYTE TOKEN
091E,31 E1,,        ACALL   SPEOP           ;EVALUATE SPECIAL OPERATOR
0920,31 DD,,        ACALL   R3CK            ;CHECK LOCATION
0922,F7,,        MOV     @R1,A           ;SAVE IT
0923,22,,        RET
,,,        ;
0924,B4 BD 06,ISTAX,ISTAX:  CJNE    A,#T_UOP+13,ISTAY       ;XBYTE TOKEN
0927,31 E1,,        ACALL   SPEOP
,,,        ;
0929,8B A0,ISTAX1,ISTAX1: MOV     P2,R3
092B,F3,,        MOVX    @R1,A
092C,22,,        RET
,,,        ;
092D,B4 AB 00,ISTAY,ISTAY:  CJNE    A,#T_CR+1,$+3   ;TRAP NEW OPERATORS
0930,40 09,,        JC      I_S
0932,B4 B0 00,,        CJNE    A,#0B0H,$+3     ;SEE IF TOO BIG
0935,50 09,,        JNC     INTERX
0937,24 F9,,        ADD     A,#0F9H         ;BIAS FOR LOOKUP TABLE
0939,80 1D,,        SJMP    ISTA0           ;DO THE OPERATION
,,,        ;
093B,B4 A4 00,I_S,I_S:    CJNE    A,#T_LAST,$+3   ;MAKE SURE AN INITIAL RESERVED WORD
093E,40 03,,        JC      $+5             ;ERROR IF NOT
,,,        ;
0940,02 18 86,INTERX,INTERX: LJMP    E1XX            ;SYNTAX ERROR
,,,        ;
0943,30 2F 12,,        JNB     DIRF,ISTA0      ;EXECUTE ALL STATEMENTS IF IN RUN MODE
0946,B4 90 00,,        CJNE    A,#T_DIR,$+3    ;SEE IF ON TOKEN
0949,40 0D,,        JC      ISTA0           ;OK IF DIRECT
094B,B4 A0 02,,        CJNE    A,#T_GOSB+1,$+5 ;SEE IF FOR
094E,80 08,,        SJMP    ISTA0           ;FOR IS OK
0950,B4 97 02,,        CJNE    A,#T_REM+1,$+5  ;NEXT IS OK
0953,80 03,,        SJMP    ISTA0
0955,B4 96 E8,,        CJNE    A,#T_STOP+6,INTERX      ;SO IS REM
,,,        ;
,,,$EJECT
0958,D1 E0,ISTA0,ISTA0:  ACALL   GCI1            ;ADVANCE THE TEXT POINTER
095A,90 01 21,,        MOV     DPTR,#STATD     ;POINT DPTR TO LOOKUP TABLE
095D,B4 80 02,,        CJNE    A,#T_GOTO-3,$+5 ;SEE IF LET TOKEN
0960,80 9E,,        SJMP    ISTAT           ;WASTE LET TOKEN
0962,54 3F,,        ANL     A,#3FH          ;STRIP OFF THE GARBAGE
,,,        ;
0964,23,ISTA1,ISTA1:  RL      A               ;ROTATE FOR OFFSET
0965,25 82,,        ADD     A,DPL           ;BUMP
0967,F5 82,,        MOV     DPL,A           ;SAVE IT
0969,E4,,        CLR     A
096A,93,,        MOVC    A,@A+DPTR       ;GET HIGH BYTE
096B,C0 E0,,        PUSH    ACC             ;SAVE IT
096D,A3,,        INC     DPTR
096E,E4,,        CLR     A
096F,93,,        MOVC    A,@A+DPTR       ;GET LOW BYTE
0970,D0 83,,        POP     DPH
0972,F5 82,,        MOV     DPL,A
,,,        ;
0974,E4,AC1,AC1:    CLR     A
0975,73,,        JMP     @A+DPTR         ;GO DO IT
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; The statement action routine - LET
,,,        ;
,,,        ;***************************************************************
,,,        ;
0976,D1 C8,SLET,SLET:   ACALL   S_C             ;CHECK FOR POSSIBLE STRING
0978,40 50,,        JC      SLET0           ;NO STRING
097A,C2 15,,        CLR     LINEB           ;USED STRINGS
,,,        ;
097C,12 05 71,,        CALL    X31DP           ;PUT ADDRESS IN DPTR
097F,7F EA,,        MOV     R7,#T_EQU       ;WASTE =
0981,91 EE,,        ACALL   EATC
0983,D1 D6,,        ACALL   GC              ;GET THE NEXT CHARACTER
0985,B4 22 11,,        CJNE    A,#'"',S_3      ;CHECK FOR A "
0988,AF 3F,,        MOV     R7,S_LEN        ;GET THE STRING LENGTH
,,,        ;
098A,D1 E0,S_0,S_0:    ACALL   GCI1            ;BUMP PAST "
098C,D1 EA,,        ACALL   DELTST          ;CHECK FOR DELIMITER
098E,60 B0,,        JZ      INTERX          ;EXIT IF CARRIAGE RETURN
0990,F0,,        MOVX    @DPTR,A         ;SAVE THE CHARACTER
0991,B4 22 26,,        CJNE    A,#'"',S_1      ;SEE IF DONE
,,,        ;
0994,74 0D,S_E,S_E:    MOV     A,#CR           ;PUT A CR IN A
0996,F0,,        MOVX    @DPTR,A         ;SAVE CR
0997,C1 E0,,        AJMP    GCI1
,,,        ;
0999,C0 83,S_3,S_3:    PUSH    DPH
099B,C0 82,,        PUSH    DPL             ;SAVE DESTINATION
099D,D1 C8,,        ACALL   S_C             ;CALCULATE SOURCE
099F,40 9F,,        JC      INTERX          ;ERROR IF CARRY
09A1,D0 00,,        POP     R0B0            ;GET DESTINATION BACK
09A3,D0 02,,        POP     R2B0
,,,        ;
09A5,AF 3F,SSOOP,SSOOP:  MOV     R7,S_LEN        ;SET UP COUNTER
,,,        ;
09A7,12 15 88,S_4,S_4:    CALL    TBYTE           ;TRANSFER THE BYTE
09AA,B4 0D 01,,        CJNE    A,#CR,$+4       ;EXIT IF A CR
09AD,22,,        RET
09AE,DF 05,,        DJNZ    R7,S_5          ;BUMP COUNTER
09B0,74 0D,,        MOV     A,#CR           ;SAVE A CR
09B2,F2,,        MOVX    @R0,A
09B3,C1 57,,        AJMP    EIGP            ;PRINT EXTRA IGNORED
,,,        ;
,,,$EJECT
,,,        ;
09B5,12 15 68,S_5,S_5:    CALL    INC3210         ;BUMP POINTERS
09B8,80 ED,,        SJMP    S_4             ;LOOP
,,,        ;
09BA,DF 06,S_1,S_1:    DJNZ    R7,$+8          ;SEE IF DONE
09BC,31 94,,        ACALL   S_E
09BE,D1 57,,        ACALL   EIGP            ;PRINT EXTRA IGNORED
09C0,C1 F5,,        AJMP    FINDCR          ;GO FIND THE END
09C2,A3,,        INC     DPTR            ;BUMP THE STORE POINTER
09C3,80 C5,,        SJMP    S_0             ;CONTINUE TO LOOP
,,,        ;
09C5,90 18 29,E3XX,E3XX:   MOV     DPTR,#E3X       ;BAD ARG ERROR
09C8,81 16,,        AJMP    EK
,,,        ;
09CA,31 CE,SLET0,SLET0:  ACALL   SLET1
09CC,E1 DC,,        AJMP    POPAS           ;COPY EXPRESSION TO VARIABLE
,,,        ;
09CE,F1 0A,SLET1,SLET1:  ACALL   VAR_ER          ;CHECK FOR A"VARIABLE"
,,,        ;
09D0,C0 02,SLET2,SLET2:  PUSH    R2B0            ;SAVE THE VARIABLE ADDRESS
09D2,C0 00,,        PUSH    R0B0
09D4,7F EA,,        MOV     R7,#T_EQU       ;GET EQUAL TOKEN
09D6,F1 4A,,        ACALL   WE
09D8,D0 01,,        POP     R1B0            ;POP VARIABLE TO R3:R1
09DA,D0 03,,        POP     R3B0
09DC,22,,        RET                     ;EXIT
,,,        ;
09DD,BB 00 E5,R3CK,R3CK:   CJNE    R3,#00H,E3XX    ;CHECK TO SEE IF R3 IS ZERO
09E0,22,,        RET
,,,        ;
09E1,D1 E0,SPEOP,SPEOP:  ACALL   GCI1            ;BUMP TXA
09E3,91 E8,,        ACALL   P_E             ;EVALUATE PAREN
09E5,31 D0,,        ACALL   SLET2           ;EVALUATE AFTER =
09E7,12 14 93,,        CALL    TWOL            ;R7:R6 GETS VALUE, R3:R1 GETS LOCATION
09EA,EE,,        MOV     A,R6            ;SAVE THE VALUE
,,,        ;
09EB,BF 00 D7,,        CJNE    R7,#00H,E3XX    ;R2 MUST BE = 0
09EE,22,,        RET
,,,        ;
,,,$EJECT
,,,        ;**************************************************************
,,,        ;
,,,        ; ST_CAL - Calculate string Address
,,,        ;
,,,        ;**************************************************************
,,,        ;
09EF,,IST_CAL,IST_CAL:;
,,,        ;
09EF,D1 9E,,        ACALL   I_PI            ;BUMP TEXT, THEN EVALUATE
09F1,31 DD,,        ACALL   R3CK            ;ERROR IF R3 <> 0
09F3,09,,        INC     R1              ;BUMP FOR OFFSET
09F4,E9,,        MOV     A,R1            ;ERROR IF R1 = 255
09F5,60 CE,,        JZ      E3XX
09F7,90 01 04,,        MOV     DPTR,#VARTOP    ;GET TOP OF VARIABLE STORAGE
09FA,85 3F F0,,        MOV     B,S_LEN         ;MULTIPLY FOR LOCATION
09FD,51 18,,        ACALL   VARD            ;CALCULATE THE LOCATION
09FF,90 01 0A,,        MOV     DPTR,#MEMTOP    ;SEE IF BLEW IT
0A02,12 15 A2,,        CALL    FUL1
0A05,85 3F 82,,        MOV     DPL,S_LEN       ;GET STRING LENGTH, DPH = 00H
0A08,15 83,,        DEC     DPH             ;DPH = 0
,,,        ;
0A0A,C3,DUBSUB,DUBSUB: CLR     C
0A0B,E9,,        MOV     A,R1
0A0C,95 82,,        SUBB    A,DPL
0A0E,F9,,        MOV     R1,A
0A0F,EB,,        MOV     A,R3
0A10,95 83,,        SUBB    A,DPH
0A12,FB,,        MOV     R3,A
0A13,49,,        ORL     A,R1
0A14,22,,        RET
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,        ;VARD - Calculate the offset base
,,,        ;
,,,        ;***************************************************************
,,,        ;
0A15,75 F0 06,VARB,VARB:   MOV     B,#FPSIZ        ;SET UP FOR OPERATION
,,,        ;
0A18,12 05 A8,VARD,VARD:   CALL    LDPTRI          ;LOAD DPTR
0A1B,E9,,        MOV     A,R1            ;MULTIPLY BASE
0A1C,A4,,        MUL     AB
0A1D,25 82,,        ADD     A,DPL
0A1F,F9,,        MOV     R1,A
0A20,E5 F0,,        MOV     A,B
0A22,35 83,,        ADDC    A,DPH
0A24,FB,,        MOV     R3,A
0A25,22,,        RET
,,,        ;
,,,$EJECT
,,,        ;*************************************************************
,,,        ;
0A26,,CSY,CSY:    ; Calculate a biased string address and put in R3:R1
,,,        ;
,,,        ;*************************************************************
,,,        ;
0A26,31 EF,,        ACALL   IST_CAL         ;CALCULATE IT
0A28,C0 03,,        PUSH    R3B0            ;SAVE IT
0A2A,C0 01,,        PUSH    R1B0
0A2C,7F 2C,,        MOV     R7,#','         ;WASTE THE COMMA
0A2E,91 EE,,        ACALL   EATC
0A30,D1 97,,        ACALL   ONE             ;GET THE NEXT EXPRESSION
0A32,E9,,        MOV     A,R1            ;CHECK FOR BOUNDS
0A33,B5 3F 00,,        CJNE    A,S_LEN,$+3
0A36,50 8D,,        JNC     E3XX            ;MUST HAVE A CARRY
0A38,19,,        DEC     R1              ;BIAS THE POINTER
0A39,D0 E0,,        POP     ACC             ;GET VALUE LOW
0A3B,29,,        ADD     A,R1            ;ADD IT TO BASE
0A3C,F9,,        MOV     R1,A            ;SAVE IT
0A3D,D0 03,,        POP     R3B0            ;GET HIGH ADDRESS
0A3F,50 01,,        JNC     $+3             ;PROPAGATE THE CARRY
0A41,0B,,        INC     R3
0A42,81 EC,,        AJMP    ERPAR           ;WASTE THE RIGHT PAREN
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; The statement action routine FOR
,,,        ;
,,,        ;***************************************************************
,,,        ;
0A44,31 CE,SFOR,SFOR:   ACALL   SLET1           ;SET UP CONTROL VARIABLE
0A46,C0 03,,        PUSH    R3B0            ;SAVE THE CONTROL VARIABLE LOCATION
0A48,C0 01,,        PUSH    R1B0
0A4A,F1 DC,,        ACALL   POPAS           ;POP ARG STACK AND COPY CONTROL VAR
0A4C,7F A6,,        MOV     R7,#T_TO        ;GET TO TOKEN
0A4E,F1 4A,,        ACALL   WE
0A50,D1 D6,,        ACALL   GC              ;GET NEXT CHARACTER
0A52,B4 A7 06,,        CJNE    A,#T_STEP,SF2
0A55,D1 E0,,        ACALL   GCI1            ;EAT THE TOKEN
0A57,F1 4C,,        ACALL   EXPRB           ;EVALUATE EXPRESSION
0A59,80 03,,        SJMP    $+5             ;JUMP OVER
,,,        ;
0A5B,12 14 35,SF2,SF2:    LCALL   PUSH_ONE        ;PUT ONE ON THE STACK
,,,        ;
0A5E,74 EF,,        MOV     A,#-FSIZE       ;ALLOCATE FSIZE BYTES ON THE CONTROL STACK
0A60,71 B9,,        ACALL   PUSHCS          ;GET CS IN R0
0A62,71 C5,,        ACALL   CSC             ;CHECK CONTROL STACK
0A64,7B 00,,        MOV     R3,#CSTKAH      ;IN CONTROL STACK
0A66,A9 00,,        MOV     R1,R0B0         ;STACK ADDRESS
0A68,F1 DC,,        ACALL   POPAS           ;PUT STEP ON STACK
0A6A,F1 DC,,        ACALL   POPAS           ;PUT LIMIT ON STACK
0A6C,D1 AB,,        ACALL   DP_T            ;DPTR GETS TEXT
0A6E,A8 01,,        MOV     R0,R1B0         ;GET THE POINTER
0A70,71 41,,        ACALL   T_X_S           ;SAVE THE TEXT
0A72,D0 08,,        POP     TXAL            ;GET CONTROL VARIABLE
0A74,D0 0A,,        POP     TXAH
0A76,7C 01,,        MOV     R4,#FTYPE       ;AND THE TYPE
0A78,71 41,,        ACALL   T_X_S           ;SAVE IT
,,,        ;
0A7A,D1 C1,SF3,SF3:    ACALL   T_DP            ;GET THE TEXT POINTER
0A7C,01 17,,        AJMP    ILOOP           ;CONTINUE TO PROCESS
,,,        ;
,,,$EJECT
,,,        ;**************************************************************
,,,        ;
,,,        ; The statement action routines - PUSH and POP
,,,        ;
,,,        ;**************************************************************
,,,        ;
0A7E,F1 4C,SPUSH,SPUSH:  ACALL   EXPRB           ;PUT EXPRESSION ON STACK
0A80,D1 CF,,        ACALL   C_TST           ;SEE IF MORE TO DO
0A82,50 FA,,        JNC     SPUSH           ;IF A COMMA PUSH ANOTHER
0A84,22,,        RET
,,,        ;
,,,        ;
0A85,F1 0A,SPOP,SPOP:   ACALL   VAR_ER          ;GET VARIABLE
0A87,F1 DA,,        ACALL   XPOP            ;FLIP THE REGISTERS FOR POPAS
0A89,D1 CF,,        ACALL   C_TST           ;SEE IF MORE TO DO
0A8B,50 F8,,        JNC     SPOP
,,,        ;
0A8D,22,,        RET
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,        ; The statement action routine - IF
,,,        ;
,,,        ;***************************************************************
,,,        ;
0A8E,51 CF,SIF,SIF:    ACALL   RTST            ;EVALUATE THE EXPRESSION
0A90,F9,,        MOV     R1,A            ;SAVE THE RESULT
0A91,D1 D6,,        ACALL   GC              ;GET THE CHARACTER AFTER EXPR
0A93,B4 A5 02,,        CJNE    A,#T_THEN,$+5   ;SEE IF THEN TOKEN
0A96,D1 E0,,        ACALL   GCI1            ;WASTE THEN TOKEN
0A98,B9 00 0B,,        CJNE    R1,#0,T_F1      ;CHECK R_OP RESULT
,,,        ;
0A9B,7F A8,E_FIND,E_FIND: MOV     R7,#T_ELSE      ;FIND ELSE TOKEN
0A9D,D1 F7,,        ACALL   FINDC
0A9F,60 EC,,        JZ      SIF-1           ;EXIT IF A CR
0AA1,D1 E0,,        ACALL   GCI1            ;BUMP PAST TOKEN
0AA3,B4 A8 F5,,        CJNE    A,#T_ELSE,E_FIND;WASTE IF NO ELSE
,,,        ;
0AA6,F1 3E,T_F1,T_F1:   ACALL   INTGER          ;SEE IF NUMBER
0AA8,50 56,,        JNC     D_L1            ;EXECUTE LINE NUMBER
0AAA,21 00,,        AJMP    ISTAT           ;EXECUTE STATEMENT IN NOT
,,,        ;
0AAC,E0,B_C,B_C:    MOVX    A,@DPTR
0AAD,14,,        DEC     A
0AAE,20 E7 2E,,        JB      ACC.7,FL3-5
0AB1,22,,        RET
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; The statement action routine - GOTO
,,,        ;
,,,        ;***************************************************************
,,,        ;
0AB2,51 FA,SGOTO,SGOTO:  ACALL   RLINE           ;R2:R0 AND DPTR GET INTGER
,,,        ;
0AB4,D1 C1,SGT1,SGT1:   ACALL   T_DP            ;TEXT POINTER GETS DPTR
,,,        ;
0AB6,10 25 08,,        JBC     RETBIT,SGT2     ;SEE IF RETI EXECUTED
,,,        ;
0AB9,30 15 03,,        JNB     LINEB,$+6       ;SEE IF A LINE WAS EDITED
0ABC,12 06 5A,,        LCALL   RCLEAR-2        ;CLEAR THE MEMORY IF SET
0ABF,01 15,,        AJMP    ILOOP-2         ;CLEAR DIRF AND LOOP
,,,        ;
0AC1,10 14 05,SGT2,SGT2:   JBC     OTI,$+8         ;SEE IF TIMER INTERRUPT
0AC4,53 22 BD,,        ANL     34,#10111101B   ;CLEAR INTERRUPTS
0AC7,01 17,,        AJMP    ILOOP           ;EXECUTE
0AC9,A2 2B,,        MOV     C,ISAV
0ACB,92 11,,        MOV     INPROG,C
0ACD,01 17,,        AJMP    ILOOP           ;RESTORE INTERRUPTS AND RET
,,,        ;
,,,        ;
,,,        ;*************************************************************
,,,        ;
0ACF,,RTST,RTST:   ; Test for ZERO
,,,        ;
,,,        ;*************************************************************
,,,        ;
0ACF,F1 4C,,        ACALL   EXPRB           ;EVALUATE EXPRESSION
0AD1,12 12 41,,        CALL    INC_ASTKA       ;BUMP ARG STACK
0AD4,60 02,,        JZ      $+4             ;EXIT WITH ZERO OR 0FFH
0AD6,74 FF,,        MOV     A,#0FFH
0AD8,22,,        RET
,,,        ;
,,,$EJECT
,,,        ;
,,,        ;**************************************************************
,,,        ;
,,,        ; GLN - get the line number in R2:R0, return in DPTR
,,,        ;
,,,        ;**************************************************************
,,,        ;
0AD9,D1 A4,GLN,GLN:    ACALL   DP_B            ;GET THE BEGINNING ADDRESS
,,,        ;
0ADB,E0,FL1,FL1:    MOVX    A,@DPTR         ;GET THE LENGTH
0ADC,FF,,        MOV     R7,A            ;SAVE THE LENGTH
0ADD,DF 05,,        DJNZ    R7,FL3          ;SEE IF END OF FILE
,,,        ;
0ADF,90 1F B5,,        MOV     DPTR,#E10X      ;NO LINE NUMBER
0AE2,81 16,,        AJMP    EK              ;HANDLE THE ERROR
,,,        ;
0AE4,20 E7 F8,FL3,FL3:    JB      ACC.7,$-5       ;CHECK FOR BIT 7
0AE7,A3,,        INC     DPTR            ;POINT AT HIGH BYTE
0AE8,E0,,        MOVX    A,@DPTR         ;GET HIGH BYTE
0AE9,B5 02 08,,        CJNE    A,R2B0,FL2      ;SEE IF MATCH
0AEC,A3,,        INC     DPTR            ;BUMP TO LOW BYTE
0AED,1F,,        DEC     R7              ;ADJUST AGAIN
0AEE,E0,,        MOVX    A,@DPTR         ;GET THE LOW BYTE
0AEF,B5 00 02,,        CJNE    A,R0B0,FL2      ;SEE IF LOW BYTE MATCH
0AF2,A3,,        INC     DPTR            ;POINT AT FIRST CHARACTER
0AF3,22,,        RET                     ;FOUND IT
,,,        ;
0AF4,EF,FL2,FL2:    MOV     A,R7            ;GET THE LENGTH COUNTER
0AF5,12 05 D6,,        CALL    ADDPTR          ;ADD A TO DATA POINTER
0AF8,80 E1,,        SJMP    FL1             ;LOOP
,,,        ;
,,,        ;
,,,        ;*************************************************************
,,,        ;
,,,        ;RLINE - Read in ASCII string, get line, and clean it up
,,,        ;
,,,        ;*************************************************************
,,,        ;
0AFA,F1 39,RLINE,RLINE:  ACALL   INTERR          ;GET THE INTEGER
,,,        ;
0AFC,51 D9,RL1,RL1:    ACALL   GLN
0AFE,E1 20,,        AJMP    CLN_UP
,,,        ;
,,,        ;
0B00,51 D9,D_L1,D_L1:   ACALL   GLN             ;GET THE LINE
0B02,41 B4,,        AJMP    SGT1            ;EXECUTE THE LINE
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; The statement action routines WHILE and UNTIL
,,,        ;
,,,        ;***************************************************************
,,,        ;
0B04,51 CF,SWHILE,SWHILE: ACALL   RTST            ;EVALUATE RELATIONAL EXPRESSION
0B06,F4,,        CPL     A
0B07,80 02,,        SJMP    S_WU
,,,        ;
0B09,51 CF,SUNTIL,SUNTIL: ACALL   RTST            ;EVALUATE RELATIONAL EXPRESSION
,,,        ;
0B0B,7C 03,S_WU,S_WU:   MOV     R4,#DTYPE       ;DO EXPECTED
0B0D,FD,,        MOV     R5,A            ;SAVE R_OP RESULT
0B0E,80 0C,,        SJMP    SR0             ;GO PROCESS
,,,        ;
,,,        ;
,,,        ;***************************************************************
,,,        ;
0B10,,CNULL,CNULL:  ; The Command Action Routine - NULL
,,,        ;
,,,        ;***************************************************************
,,,        ;
0B10,F1 39,,        ACALL   INTERR          ;GET AN INTEGER FOLLOWING NULL
0B12,88 15,,        MOV     NULLCT,R0       ;SAVE THE NULLCOUNT
0B14,01 59,,        AJMP    CMNDLK          ;JUMP TO COMMAND MODE
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; The statement action routine - RETI
,,,        ;
,,,        ;***************************************************************
,,,        ;
0B16,D2 25,SRETI,SRETI:  SETB    RETBIT          ;SAYS THAT RETI HAS BEEN EXECUTED
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,        ; The statement action routine - RETURN
,,,        ;
,,,        ;***************************************************************
,,,        ;
0B18,7C 02,SRETRN,SRETRN: MOV     R4,#GTYPE       ;MAKE SURE OF GOSUB
0B1A,7D 55,,        MOV     R5,#55H         ;TYPE RETURN TYPE
,,,        ;
0B1C,71 53,SR0,SR0:    ACALL   CSETUP          ;SET UP CONTROL STACK
0B1E,E2,,        MOVX    A,@R0           ;GET RETURN TEXT ADDRESS
0B1F,F5 83,,        MOV     DPH,A
0B21,08,,        INC     R0
0B22,E2,,        MOVX    A,@R0
0B23,F5 82,,        MOV     DPL,A
0B25,08,,        INC     R0              ;POP CONTROL STACK
0B26,E0,,        MOVX    A,@DPTR         ;SEE IF GOSUB WAS THE LAST STATEMENT
0B27,B4 01 02,,        CJNE    A,#EOF,$+5
0B2A,01 59,,        AJMP    CMNDLK
0B2C,ED,,        MOV     A,R5            ;GET TYPE
0B2D,60 85,,        JZ      SGT1            ;EXIT IF ZERO
0B2F,88 11,,        MOV     CSTKA,R0        ;POP THE STACK
0B31,F4,,        CPL     A               ;OPTION TEST, 00H, 55H, 0FFH, NOW 55H
0B32,70 80,,        JNZ     SGT1            ;MUST BE GOSUB
0B34,22,,        RET                     ;NORMAL FALL THRU EXIT FOR NO MATCH
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; The statement action routine - GOSUB
,,,        ;
,,,        ;***************************************************************
,,,        ;
0B35,51 FA,SGOSUB,SGOSUB: ACALL   RLINE           ;NEW TXA IN DPTR
,,,        ;
0B37,7C 02,SGS0,SGS0:   MOV     R4,#GTYPE
0B39,71 3D,,        ACALL   SGS1            ;SET EVERYTHING UP
0B3B,41 7A,,        AJMP    SF3             ;EXIT
,,,        ;
0B3D,74 FD,SGS1,SGS1:   MOV     A,#-3           ;ALLOCATE 3 BYTES ON CONTROL STACK
0B3F,71 B9,,        ACALL   PUSHCS
,,,        ;
0B41,75 A0 00,T_X_S,T_X_S:  MOV     P2,#CSTKAH      ;SET UP PORT FOR CONTROL STACK
0B44,E5 08,,        MOV     A,TXAL          ;GET RETURN ADDRESS AND SAVE IT
0B46,F2,,        MOVX    @R0,A
0B47,18,,        DEC     R0
0B48,E5 0A,,        MOV     A,TXAH
0B4A,F2,,        MOVX    @R0,A
0B4B,18,,        DEC     R0
0B4C,EC,,        MOV     A,R4            ;GET TYPE
0B4D,F2,,        MOVX    @R0,A           ;SAVE TYPE
0B4E,22,,        RET                     ;EXIT
,,,        ;
,,,        ;
0B4F,74 03,CS1,CS1:    MOV     A,#3            ;POP 3 BYTES
0B51,71 B9,,        ACALL   PUSHCS
,,,        ;
0B53,A8 11,CSETUP,CSETUP: MOV     R0,CSTKA        ;GET CONTROL STACK
0B55,75 A0 00,,        MOV     P2,#CSTKAH
0B58,E2,,        MOVX    A,@R0           ;GET BYTE
0B59,B5 04 02,,        CJNE    A,R4B0,$+5      ;SEE IF TYPE MATCH
0B5C,08,,        INC     R0
0B5D,22,,        RET
0B5E,60 69,,        JZ      E4XX            ;EXIT IF STACK UNDERFLOW
0B60,B4 01 EC,,        CJNE    A,#FTYPE,CS1    ;SEE IF FOR TYPE
0B63,71 B7,,        ACALL   PUSHCS-2        ;WASTE THE FOR TYPE
0B65,80 EC,,        SJMP    CSETUP          ;LOOP
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; The statement action routine - NEXT
,,,        ;
,,,        ;***************************************************************
,,,        ;
0B67,7C 01,SNEXT,SNEXT:  MOV     R4,#FTYPE       ;FOR TYPE
0B69,71 53,,        ACALL   CSETUP          ;SETUP CONTROL STACK
0B6B,88 0F,,        MOV     TEMP5,R0        ;SAVE CONTROL VARIABLE ADDRESS
0B6D,79 0B,,        MOV     R1,#TEMP1       ;SAVE VAR + RETURN IN TEMP1-4
,,,        ;
0B6F,E2,XXI,XXI:    MOVX    A,@R0           ;LOOP UNTIL DONE
0B70,F7,,        MOV     @R1,A
0B71,09,,        INC     R1
0B72,08,,        INC     R0
0B73,B9 0F F9,,        CJNE    R1,#TEMP5,XXI
,,,        ;
0B76,B1 6E,,        ACALL   VAR             ;SEE IF THE USER HAS A VARIABLE
0B78,50 04,,        JNC     $+6
0B7A,AA 0B,,        MOV     R2,TEMP1
0B7C,A8 0C,,        MOV     R0,TEMP2
0B7E,EA,,        MOV     A,R2            ;SEE IF VAR'S AGREE
0B7F,B5 0B 47,,        CJNE    A,TEMP1,E4XX
0B82,E8,,        MOV     A,R0
0B83,B5 0C 43,,        CJNE    A,TEMP2,E4XX
0B86,F1 E6,,        ACALL   PUSHAS          ;PUT CONTROL VARIABLE ON STACK
0B88,74 0E,,        MOV     A,#FPSIZ+FPSIZ+2;COMPUTE ADDRESS TO STEP VALUE SIGN
0B8A,25 0F,,        ADD     A,TEMP5         ;ADD IT TO BASE OF STACK
0B8C,F8,,        MOV     R0,A            ;SAVE IN R0
0B8D,7A 00,,        MOV     R2,#CSTKAH      ;SET UP TO PUSH STEP VALUE
0B8F,8A A0,,        MOV     P2,R2           ;SET UP PORT
0B91,E2,,        MOVX    A,@R0           ;GET SIGN
0B92,08,,        INC     R0              ;BACK TO EXPONENT
0B93,C0 E0,,        PUSH    ACC             ;SAVE SIGN OF STEP
0B95,F1 E6,,        ACALL   PUSHAS          ;PUT STEP VALUE ON STACK
0B97,C0 00,,        PUSH    R0B0            ;SAVE LIMIT VALUE LOCATION
0B99,12 17 3F,,        CALL    AADD            ;ADD STEP VALUE TO VARIABLE
0B9C,12 14 1E,,        CALL    CSTAKA          ;COPY STACK
0B9F,AB 0B,,        MOV     R3,TEMP1        ;GET CONTROL VARIABLE
0BA1,A9 0C,,        MOV     R1,TEMP2
0BA3,F1 DC,,        ACALL   POPAS           ;SAVE THE RESULT
0BA5,7A 00,,        MOV     R2,#CSTKAH      ;RESTORE LIMIT LOCATION
0BA7,D0 00,,        POP     R0B0
0BA9,F1 E6,,        ACALL   PUSHAS          ;PUT LIMIT ON STACK
0BAB,12 19 97,,        CALL    FP_BASE+4       ;DO THE COMPARE
0BAE,D0 E0,,        POP     ACC             ;GET LIMIT SIGN BACK
0BB0,60 01,,        JZ      $+3             ;IF SIGN NEGATIVE, TEST "BACKWARDS"
0BB2,B3,,        CPL     C
0BB3,72 D5,,        ORL     C,F0            ;SEE IF EQUAL
0BB5,40 17,,        JC      N4              ;STILL SMALLER THAN LIMIT?
0BB7,74 11,,        MOV     A,#FSIZE        ;REMOVE CONTROL STACK ENTRY
,,,        ;
,,,        ; Fall thru to PUSHCS
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; PUSHCS - push frame onto control stack
,,,        ;          acc has - number of bytes, also test for overflow
,,,        ;
,,,        ;***************************************************************
,,,        ;
0BB9,25 11,PUSHCS,PUSHCS: ADD     A,CSTKA         ;BUMP CONTROL STACK
0BBB,B4 61 00,,        CJNE    A,#CONVT+17,$+3 ;SEE IF OVERFLOWED
0BBE,40 09,,        JC      E4XX            ;EXIT IF STACK OVERFLOW
0BC0,C5 11,,        XCH     A,CSTKA         ;STORE NEW CONTROL STACK VALUE, GET OLD
0BC2,14,,        DEC     A               ;BUMP OLD VALUE
0BC3,F8,,        MOV     R0,A            ;PUT OLD-1 IN R0
,,,        ;
0BC4,22,,        RET                     ;EXIT
,,,        ;
0BC5,F1 20,CSC,CSC:    ACALL   CLN_UP          ;FINISH OFF THE LINE
0BC7,50 FB,,        JNC     CSC-1           ;EXIT IF NO TERMINATOR
,,,        ;
0BC9,90 03 7F,E4XX,E4XX:   MOV     DPTR,#EXC       ;CONTROL STACK ERROR
0BCC,81 16,,        AJMP    EK              ;STACK ERROR
,,,        ;
0BCE,85 0D 0A,N4,N4:     MOV     TXAH,TEMP3      ;GET TEXT POINTER
0BD1,85 0E 08,,        MOV     TXAL,TEMP4
0BD4,01 17,,        AJMP    ILOOP           ;EXIT
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,        ; The statement action routine - RESTORE
,,,        ;
,,,        ;***************************************************************
,,,        ;
0BD6,71 DE,SRESTR,SRESTR: ACALL   X_TR            ;SWAP POINTERS
0BD8,D1 A4,,        ACALL   DP_B            ;GET THE STARTING ADDRESS
0BDA,D1 C1,,        ACALL   T_DP            ;PUT STARTING ADDRESS IN TEXT POINTER
0BDC,F1 2C,,        ACALL   B_TXA           ;BUMP TXA
,,,        ;
,,,        ; Fall thru
,,,        ;
0BDE,,X_TR,X_TR:   ;swap txa and rtxa
,,,        ;
0BDE,C5 0A,,        XCH     A,TXAH
0BE0,C5 12,,        XCH     A,RTXAH
0BE2,C5 0A,,        XCH     A,TXAH
0BE4,C5 08,,        XCH     A,TXAL
0BE6,C5 10,,        XCH     A,RTXAL
0BE8,C5 08,,        XCH     A,TXAL
0BEA,22,,        RET                     ;EXIT
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; The statement action routine - READ
,,,        ;
,,,        ;***************************************************************
,,,        ;
0BEB,71 DE,SREAD,SREAD:  ACALL   X_TR            ;SWAP POINTERS
,,,        ;
0BED,D1 CF,SRD0,SRD0:   ACALL   C_TST           ;CHECK FOR COMMA
0BEF,40 16,,        JC      SRD4            ;SEE WHAT IT IS
,,,        ;
0BF1,F1 4C,SRD,SRD:    ACALL   EXPRB           ;EVALUATE THE EXPRESSION
0BF3,D1 D6,,        ACALL   GC              ;GET THE CHARACTER AFTER EXPRESSION
0BF5,B4 2C 02,,        CJNE    A,#',',SRD1     ;SEE IF MORE DATA
0BF8,80 02,,        SJMP    SRD2            ;BYBASS CLEAN UP IF A COMMA
,,,        ;
0BFA,F1 20,SRD1,SRD1:   ACALL   CLN_UP          ;FINISH OFF THE LINE, IF AT END
,,,        ;
0BFC,71 DE,SRD2,SRD2:   ACALL   X_TR            ;RESTORE POINTERS
0BFE,F1 0A,,        ACALL   VAR_ER          ;GET VARIABLE ADDRESS
0C00,F1 DA,,        ACALL   XPOP            ;FLIP THE REGISTERS FOR POPAS
0C02,D1 CF,,        ACALL   C_TST           ;SEE IF A COMMA
0C04,50 E5,,        JNC     SREAD           ;READ AGAIN IF A COMMA
0C06,22,,        RET                     ;EXIT IF NOT
,,,        ;
0C07,B4 9C 04,SRD4,SRD4:   CJNE    A,#T_DATA,SRD5  ;SEE IF DATA
0C0A,D1 E0,,        ACALL   GCI1            ;BUMP POINTER
0C0C,80 E3,,        SJMP    SRD
,,,        ;
0C0E,B4 01 08,SRD5,SRD5:   CJNE    A,#EOF,SRD6     ;SEE IF YOU BLEW IT
0C11,71 DE,,        ACALL   X_TR            ;GET THE TEXT POINTER BACK
0C13,90 1F 81,,        MOV     DPTR,#E14X      ;READ ERROR
,,,        ;
0C16,02 18 90,EK,EK:     LJMP    ERROR
,,,        ;
0C19,D1 F5,SRD6,SRD6:   ACALL   FINDCR          ;WASTE THIS LINE
0C1B,F1 20,,        ACALL   CLN_UP          ;CLEAN IT UP
0C1D,40 F2,,        JC      SRD5+3          ;ERROR IF AT END
0C1F,80 CC,,        SJMP    SRD0
,,,        ;
0C21,D1 D6,NUMC,NUMC:   ACALL   GC              ;GET A CHARACTER
0C23,B4 23 04,,        CJNE    A,#'#',NUMC1    ;SEE IF A #
0C26,D2 1B,,        SETB    COB             ;VALID LINE PRINT
0C28,C1 D4,,        AJMP    IGC             ;BUMP THE TEXT POINTER
,,,        ;
0C2A,B4 40 D9,NUMC1,NUMC1:  CJNE    A,#'@',SRD4-1   ;EXIT IF NO GOOD
0C2D,D2 19,,        SETB    LPB
0C2F,C1 D4,,        AJMP    IGC
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; The statement action routine - PRINT
,,,        ;
,,,        ;***************************************************************
,,,        ;
0C31,D2 36,SPH0,SPH0:   SETB    ZSURP           ;NO ZEROS
,,,        ;
0C33,D2 37,SPH1,SPH1:   SETB    HMODE           ;HEX MODE
,,,        ;
0C35,91 21,SPRINT,SPRINT: ACALL   NUMC            ;TEST FOR A LINE PRINT
0C37,91 40,,        ACALL   $+9             ;PROCEED
0C39,53 23 F5,,        ANL     35,#11110101B   ;CLEAR COB AND LPB
0C3C,53 26 3F,,        ANL     38,#00111111B   ;NO HEX MODE
,,,        ;
0C3F,22,,        RET
,,,        ;
0C40,D1 EA,,        ACALL   DELTST          ;CHECK FOR A DELIMITER
0C42,40 07,,        JC      SP1
,,,        ;
0C44,02 06 9D,SP0,SP0:    JMP     CRLF            ;EXIT WITH A CR IF SO
,,,        ;
0C47,D1 CF,SP2,SP2:    ACALL   C_TST           ;CHECK FOR A COMMA
0C49,40 F9,,        JC      SP0             ;EXIT IF NO COMMA
,,,        ;
0C4B,D1 B2,SP1,SP1:    ACALL   CPS             ;SEE IF A STRING TO PRINT
0C4D,50 F8,,        JNC     SP2             ;IF A STRING, CHECK FOR A COMMA
,,,        ;
0C4F,B4 A4 08,SP4,SP4:    CJNE    A,#T_TAB,SP6
0C52,D1 9E,,        ACALL   I_PI            ;ALWAYS CLEARS CARRY
0C54,95 16,,        SUBB    A,PHEAD         ;TAKE DELTA BETWEEN TAB AND PHEAD
0C56,40 EF,,        JC      SP2             ;EXIT IF PHEAD > TAB
0C58,80 05,,        SJMP    SP7             ;OUTPUT SPACES
,,,        ;
0C5A,B4 A9 0A,SP6,SP6:    CJNE    A,#T_SPC,SM
0C5D,D1 9E,,        ACALL   I_PI            ;SET UP PAREN VALUE
,,,        ;
0C5F,60 E6,SP7,SP7:    JZ      SP2
0C61,12 07 07,,        LCALL   STEROT          ;OUTPUT A SPACE
0C64,14,,        DEC     A               ;DECREMENT COUNTER
0C65,80 F8,,        SJMP    SP7             ;LOOP
,,,        ;
,,,$EJECT
0C67,B4 D3 14,SM,SM:     CJNE    A,#T_CHR,SP8
0C6A,D1 D4,,        ACALL   IGC
0C6C,B4 24 06,,        CJNE    A,#'$',$+9
0C6F,12 10 02,,        LCALL   CNX             ;PUT THE CHARACTER ON THE STACK
0C72,D1 99,,        ACALL   IFIXL           ;PUT THE CHARACTER IN R1
0C74,80 04,,        SJMP    $+6
0C76,D1 97,,        ACALL   ONE             ;EVALUATE THE EXPRESSION, PUT IN R3:R1
0C78,91 EC,,        ACALL   ERPAR
0C7A,AD 01,,        MOV     R5,R1B0         ;BYTE TO OUTPUT
0C7C,80 07,,        SJMP    SQ
,,,        ;
0C7E,B4 AA 09,SP8,SP8:    CJNE    A,#T_CR,SX
0C81,D1 E0,,        ACALL   GCI1            ;EAT THE TOKEN
0C83,7D 0D,,        MOV     R5,#CR
,,,        ;
0C85,12 07 09,SQ,SQ:     CALL    TEROT
0C88,80 BD,,        SJMP    SP2             ;OUTPUT A CR AND DO IT AGAIN
,,,        ;
0C8A,B4 D2 53,SX,SX:     CJNE    A,#T_USE,SP9    ;USING TOKEN
0C8D,D1 D4,,        ACALL   IGC             ;GE THE CHARACTER AFTER THE USING TOKEN
0C8F,B4 46 16,,        CJNE    A,#'F',U4       ;SEE IF FLOATING
0C92,75 17 F0,,        MOV     FORMAT,#0F0H    ;SET FLOATING
0C95,D1 D4,,        ACALL   IGC             ;BUMP THE POINTER AND GET THE CHARACTER
0C97,D1 E0,,        ACALL   GCI1            ;BUMP IT AGAIN
0C99,54 0F,,        ANL     A,#0FH          ;STRIP OFF ASCII BIAS
0C9B,60 07,,        JZ      U3              ;EXIT IF ZERO
0C9D,B4 03 00,,        CJNE    A,#3,$+3        ;SEE IF AT LEAST A THREE
0CA0,50 02,,        JNC     U3              ;FORCE A THREE IF NOT A THREE
0CA2,74 03,,        MOV     A,#3
,,,        ;
0CA4,42 17,U3,U3:     ORL     FORMAT,A        ;PUT DIGIT IN FORMAT
0CA6,80 2A,,        SJMP    U8              ;CLEAN UP END
,,,        ;
0CA8,B4 30 07,U4,U4:     CJNE    A,#'0',U5
0CAB,75 17 00,,        MOV     FORMAT,#0       ;FREE FORMAT
0CAE,D1 E0,,        ACALL   GCI1            ;BUMP THE POINTER
0CB0,80 20,,        SJMP    U8
,,,        ;
0CB2,B4 23 1D,U5,U5:     CJNE    A,#'#',U8       ;SEE IF INTGER FORMAT
0CB5,91 D6,,        ACALL   U6
0CB7,8F 17,,        MOV     FORMAT,R7       ;SAVE THE FORMAT
0CB9,B4 2E 11,,        CJNE    A,#'.',U8A      ;SEE IF TERMINATOR WAS RADIX
0CBC,D1 D4,,        ACALL   IGC             ;BUMP PAST .
0CBE,91 D6,,        ACALL   U6              ;LOOP AGAIN
0CC0,EF,,        MOV     A,R7            ;GET COUNT
0CC1,25 17,,        ADD     A,FORMAT        ;SEE IF TOO BIG
0CC3,24 F7,,        ADD     A,#0F7H
0CC5,50 02,,        JNC     U5A
,,,        ;
,,,$EJECT
0CC7,21 40,SE0,SE0:    AJMP    INTERX          ;ERROR, BAD SYNTAX
,,,        ;
0CC9,EF,U5A,U5A:    MOV     A,R7            ;GET THE COUNT BACK
0CCA,C4,,        SWAP    A               ;ADJUST
0CCB,42 17,,        ORL     FORMAT,A        ;GET THE COUNT
,,,        ;
0CCD,E5 17,U8A,U8A:    MOV     A,FORMAT
,,,        ;
0CCF,C4,U8B,U8B:    SWAP    A               ;GET THE FORMAT RIGHT
0CD0,F5 17,,        MOV     FORMAT,A
,,,        ;
0CD2,91 EC,U8,U8:     ACALL   ERPAR
0CD4,81 47,,        AJMP    SP2             ;DONE
,,,        ;
0CD6,7F 00,U6,U6:     MOV     R7,#0           ;SET COUNTER
,,,        ;
0CD8,B4 23 0C,U7,U7:     CJNE    A,#'#',SP9A     ;EXIT IF NOT A #
0CDB,0F,,        INC     R7              ;BUMP COUNTER
0CDC,D1 D4,,        ACALL   IGC             ;GET THE NEXT CHARACTER
0CDE,80 F8,,        SJMP    U7              ;LOOP
,,,        ;
0CE0,D1 EC,SP9,SP9:    ACALL   DELTST+2        ;CHECK FOR DELIMITER
0CE2,50 03,,        JNC     SP9A            ;EXIT IF A DELIMITER
,,,        ;
0CE4,B4 A8 34,,        CJNE    A,#T_ELSE,SS
,,,        ;
0CE7,22,SP9A,SP9A:   RET                     ;EXIT IF ELSE TOKEN
,,,        ;
,,,        ;**************************************************************
,,,        ;
,,,        ; P_E - Evaluate an expression in parens ( )
,,,        ;
,,,        ;**************************************************************
,,,        ;
0CE8,7F E0,P_E,P_E:    MOV     R7,#T_LPAR
0CEA,F1 4A,,        ACALL   WE
,,,        ;
0CEC,7F 29,ERPAR,ERPAR:  MOV     R7,#')'         ;EAT A RIGHT PAREN
,,,        ;
0CEE,D1 DE,EATC,EATC:   ACALL   GCI             ;GET THE CHARACTER
0CF0,B5 07 D4,,        CJNE    A,R7B0,SE0      ;ERROR IF NOT THE SAME
0CF3,22,,        RET
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
0CF4,,S_ON,S_ON:   ; ON Statement
,,,        ;
,,,        ;***************************************************************
,,,        ;
0CF4,D1 97,,        ACALL   ONE             ;GET THE EXPRESSION
0CF6,D1 DE,,        ACALL   GCI             ;GET THE NEXT CHARACTER
0CF8,B4 83 04,,        CJNE    A,#T_GOTO,C0
0CFB,B1 06,,        ACALL   C1              ;EAT THE COMMAS
0CFD,41 7A,,        AJMP    SF3             ;DO GOTO
,,,        ;
0CFF,B4 9F C5,C0,C0:     CJNE    A,#T_GOSB,SE0
0D02,B1 06,,        ACALL   C1
0D04,61 37,,        AJMP    SGS0            ;DO GOSUB
,,,        ;
0D06,B9 00 06,C1,C1:     CJNE    R1,#0,C2
0D09,F1 39,,        ACALL   INTERR          ;GET THE LINE NUMBER
0D0B,D1 F5,,        ACALL   FINDCR
0D0D,41 FC,,        AJMP    RL1             ;FINISH UP THIS LINE
,,,        ;
0D0F,7F 2C,C2,C2:     MOV     R7,#','
0D11,D1 F7,,        ACALL   FINDC
0D13,B4 2C B1,,        CJNE    A,#',',SE0      ;ERROR IF NOT A COMMA
0D16,19,,        DEC     R1
0D17,D1 E0,,        ACALL   GCI1            ;BUMP PAST COMMA
0D19,80 EB,,        SJMP    C1
,,,        ;
,,,$EJECT
,,,        ;
0D1B,D1 C8,SS,SS:     ACALL   S_C             ;SEE IF A STRING
0D1D,40 05,,        JC      SA              ;NO STRING IF CARRY IS SET
0D1F,12 06 B7,,        LCALL   UPRNT           ;PUT POINTER IN DPTR
0D22,81 47,,        AJMP    SP2             ;SEE IF MORE
,,,        ;
0D24,F1 4C,SA,SA:     ACALL   EXPRB           ;MUST BE AN EXPRESSION
0D26,74 48,,        MOV     A,#72
0D28,B5 16 00,,        CJNE    A,PHEAD,$+3     ;CHECK PHEAD POSITION
0D2B,50 02,,        JNC     $+4
0D2D,91 44,,        ACALL   SP0             ;FORCE A CRLF
0D2F,30 37 14,,        JNB     HMODE,S13       ;HEX MODE?
0D32,12 11 F4,,        CALL    FCMP            ;SEE IF TOS IS < 0FFFH
0D35,40 0F,,        JC      S13             ;EXIT IF GREATER
0D37,12 13 81,,        CALL    AABS            ;GET THE SIGN
0D3A,70 07,,        JNZ     OOPS            ;WASTE IF NEGATIVE
0D3C,D1 99,,        ACALL   IFIXL
0D3E,12 19 A9,,        CALL    FP_BASE+22      ;PRINT HEXMODE
0D41,81 47,,        AJMP    SP2
0D43,12 13 93,OOPS,OOPS:   CALL    ANEG            ;MAKE IT NEGATIVE
,,,        ;
0D46,12 19 A1,S13,S13:    CALL    FP_BASE+14      ;DO FP OUTPUT
0D49,74 01,,        MOV     A,#1            ;OUTPUT A SPACE
0D4B,81 5F,,        AJMP    SP7
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; ANU -  Get variable name from text - set carry if not found
,,,        ;        if succeeds returns variable in R7:R6
,,,        ;        R6 = 0 if no digit in name
,,,        ;
,,,        ;***************************************************************
,,,        ;
0D4D,D1 D4,ANU,ANU:    ACALL   IGC             ;INCREMENT AND GET CHARACTER
0D4F,12 1F ED,,        LCALL   1FEDH           ;CHECK FOR DIGIT
0D52,40 0C,,        JC      $+14            ;EXIT IF VALID DIGIT
0D54,B4 5F 01,,        CJNE    A,#'_',$+4      ;SEE IF A _
0D57,22,,        RET
,,,        ;
0D58,B4 41 00,AL,AL:     CJNE    A,#'A',$+3      ;IS IT AN ASCII A?
0D5B,40 04,,        JC      $+6             ;EXIT IF CARRY IS SET
0D5D,B4 5B 00,,        CJNE    A,#'Z'+1,$+3    ;IS IT LESS THAN AN ASCII Z
0D60,B3,,        CPL     C               ;FLIP CARRY
0D61,22,,        RET
,,,        ;
0D62,30 D5 3E,,        JNB     F0,VAR2
,,,        ;
0D65,90 17 5F,SD0,SD0:    MOV     DPTR,#E6X
0D68,81 16,,        AJMP    EK
,,,        ;
0D6A,D2 D5,SDIMX,SDIMX:  SETB    F0              ;SAYS DOING A DIMENSION
0D6C,80 02,,        SJMP    VAR1
,,,        ;
0D6E,C2 D5,VAR,VAR:    CLR     F0              ;SAYS DOING A VARIABLE
,,,        ;
0D70,D1 D6,VAR1,VAR1:   ACALL   GC              ;GET THE CHARACTER
0D72,B1 58,,        ACALL   AL              ;CHECK FOR ALPHA
0D74,50 04,,        JNC     $+6             ;ERROR IF IN DIM
0D76,20 D5 EC,,        JB      F0,SD0
0D79,22,,        RET
0D7A,FF,,        MOV     R7,A            ;SAVE ALPHA CHARACTER
0D7B,E4,,        CLR     A               ;ZERO IN CASE OF FAILURE
0D7C,FD,,        MOV     R5,A            ;SAVE IT
,,,        ;
0D7D,FE,VY,VY:     MOV     R6,A
0D7E,B1 4D,,        ACALL   ANU             ;CHECK FOR ALPHA OR NUMBER
0D80,40 07,,        JC      VX              ;EXIT IF NO ALPHA OR NUM
,,,        ;
0D82,CF,,        XCH     A,R7
0D83,2D,,        ADD     A,R5            ;NUMBER OF CHARACTERS IN ALPHABET
0D84,CF,,        XCH     A,R7            ;PUT IT BACK
0D85,7D 1A,,        MOV     R5,#26          ;FOR THE SECOND TIME AROUND
0D87,80 F4,,        SJMP    VY
,,,        ;
0D89,C2 15,VX,VX:     CLR     LINEB           ;TELL EDITOR A VARIABLE IS DECLARED
0D8B,B4 E0 2F,,        CJNE    A,#T_LPAR,V4    ;SEE IF A LEFT PAREN
,,,        ;
0D8E,43 06 80,,        ORL     R6B0,#80H       ;SET BIT 7 TO SIGINIFY MATRIX
0D91,12 06 11,,        CALL    F_VAR           ;FIND THE VARIABLE
0D94,C0 02,,        PUSH    R2B0            ;SAVE THE LOCATION
0D96,C0 00,,        PUSH    R0B0
0D98,50 C8,,        JNC     SD0-3           ;DEFAULT IF NOT IN TABLE
0D9A,20 D5 28,,        JB      F0,SDI          ;NO DEFAULT FOR DIMENSION
0D9D,79 0A,,        MOV     R1,#10
0D9F,7B 00,,        MOV     R3,#0
0DA1,B1 D5,,        ACALL   D_CHK
,,,        ;
0DA3,D1 A0,VAR2,VAR2:   ACALL   PAREN_INT       ;EVALUATE INTEGER IN PARENS
0DA5,BB 00 BD,,        CJNE    R3,#0,SD0       ;ERROR IF R3<>0
0DA8,D0 82,,        POP     DPL             ;GET VAR FOR LOOKUP
0DAA,D0 83,,        POP     DPH
0DAC,E0,,        MOVX    A,@DPTR         ;GET DIMENSION
0DAD,14,,        DEC     A               ;BUMP OFFSET
0DAE,99,,        SUBB    A,R1            ;A MUST BE > R1
0DAF,40 B4,,        JC      SD0
0DB1,12 05 B8,,        LCALL   DECDP2          ;BUMP POINTER TWICE
0DB4,51 15,,        ACALL   VARB            ;CALCULATE THE BASE
,,,        ;
0DB6,C9,X3120,X3120:  XCH     A,R1            ;SWAP R2:R0, R3:R1
0DB7,C8,,        XCH     A,R0
0DB8,C9,,        XCH     A,R1
0DB9,CB,,        XCH     A,R3
0DBA,CA,,        XCH     A,R2
0DBB,CB,,        XCH     A,R3
0DBC,22,,        RET
,,,        ;
0DBD,20 D5 A5,V4,V4:     JB      F0,SD0          ;ERROR IF NO LPAR FOR DIM
0DC0,12 06 11,,        LCALL   F_VAR           ;GET SCALAR VARIABLE
0DC3,C3,,        CLR     C
0DC4,22,,        RET
,,,        ;
,,,$EJECT
,,,        ;
0DC5,D1 A0,SDI,SDI:    ACALL   PAREN_INT       ;EVALUATE PAREN EXPRESSION
0DC7,BB 00 9B,,        CJNE    R3,#0,SD0       ;ERROR IF NOT ZERO
0DCA,D0 00,,        POP     R0B0            ;SET UP R2:R0
0DCC,D0 02,,        POP     R2B0
0DCE,B1 D5,,        ACALL   D_CHK           ;DO DIM
0DD0,D1 CF,,        ACALL   C_TST           ;CHECK FOR COMMA
0DD2,50 96,,        JNC     SDIMX           ;LOOP IF COMMA
0DD4,22,,        RET                     ;RETURN IF NO COMMA
,,,        ;
0DD5,09,D_CHK,D_CHK:  INC     R1              ;BUMP FOR TABLE LOOKUP
0DD6,E9,,        MOV     A,R1
0DD7,60 8C,,        JZ      SD0             ;ERROR IF 0FFFFH
0DD9,FC,,        MOV     R4,A            ;SAVE FOR LATER
0DDA,90 01 08,,        MOV     DPTR,#MT_ALL    ;GET MATRIX ALLOCATION
0DDD,51 15,,        ACALL   VARB            ;DO THE CALCULATION
0DDF,AF 83,,        MOV     R7,DPH          ;SAVE MATRIX ALLOCATION
0DE1,AE 82,,        MOV     R6,DPL
0DE3,90 01 06,,        MOV     DPTR,#ST_ALL    ;SEE IF TOO MUCH MEMORY TAKEN
0DE6,12 15 A2,,        CALL    FUL1            ;ST_ALL SHOULD BE > R3:R1
0DE9,90 01 08,,        MOV     DPTR,#MT_ALL    ;SAVE THE NEW MATRIX POINTER
0DEC,12 05 FD,,        CALL    S31DP
0DEF,88 82,,        MOV     DPL,R0          ;GET VARIABLE ADDRESS
0DF1,8A 83,,        MOV     DPH,R2
0DF3,EC,,        MOV     A,R4            ;DIMENSION SIZE
0DF4,F0,,        MOVX    @DPTR,A         ;SAVE IT
0DF5,12 05 B8,,        CALL    DECDP2          ;SAVE TARGET ADDRESS
,,,        ;
0DF8,EF,R76S,R76S:   MOV     A,R7
0DF9,F0,,        MOVX    @DPTR,A
0DFA,A3,,        INC     DPTR
0DFB,EE,,        MOV     A,R6            ;ELEMENT SIZE
0DFC,F0,,        MOVX    @DPTR,A
0DFD,22,,        RET                     ;R2:R0 STILL HAS SYMBOL TABLE ADDRESS
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; The statement action routine - INPUT
,,,        ;
,,,        ;***************************************************************
,,,        ;
0DFE,D1 B2,SINPUT,SINPUT: ACALL   CPS             ;PRINT STRING IF THERE
,,,        ;
0E00,D1 CF,,        ACALL   C_TST           ;CHECK FOR A COMMA
0E02,50 07,,        JNC     IN2A            ;NO CRLF
0E04,91 44,,        ACALL   SP0             ;DO A CRLF
,,,        ;
0E06,7D 3F,IN2,IN2:    MOV     R5,#'?'         ;OUTPUT A ?
0E08,12 07 09,,        CALL    TEROT
,,,        ;
0E0B,D2 22,IN2A,IN2A:   SETB    INP_B           ;DOING INPUT
0E0D,12 06 D0,,        CALL    INLINE          ;INPUT THE LINE
0E10,C2 22,,        CLR     INP_B
0E12,75 0F 00,,        MOV     TEMP5,#HIGH IBUF
0E15,75 0E 07,,        MOV     TEMP4,#LOW IBUF
,,,        ;
0E18,D1 C8,IN3,IN3:    ACALL   S_C             ;SEE IF A STRING
0E1A,40 0D,,        JC      IN3A            ;IF CARRY IS SET, NO STRING
0E1C,B1 B6,,        ACALL   X3120           ;FLIP THE ADDRESSES
0E1E,AB 0F,,        MOV     R3,TEMP5
0E20,A9 0E,,        MOV     R1,TEMP4
0E22,31 A5,,        ACALL   SSOOP
0E24,D1 CF,,        ACALL   C_TST           ;SEE IF MORE TO DO
0E26,50 DE,,        JNC     IN2
0E28,22,,        RET
,,,        ;
0E29,12 18 4E,IN3A,IN3A:   CALL    DTEMP           ;GET THE USER LOCATION
0E2C,12 19 55,,        CALL    GET_NUM         ;GET THE USER SUPPLIED NUMBER
0E2F,70 18,,        JNZ     IN5             ;ERROR IF NOT ZERO
0E31,12 18 55,,        CALL    TEMPD           ;SAVE THE DATA POINTER
0E34,F1 0A,,        ACALL   VAR_ER          ;GET THE VARIABLE
0E36,F1 DA,,        ACALL   XPOP            ;SAVE THE VARIABLE
0E38,12 18 4E,,        CALL    DTEMP           ;GET DPTR BACK FROM VAR_ER
0E3B,D1 CF,,        ACALL   C_TST           ;SEE IF MORE TO DO
0E3D,40 13,,        JC      IN6             ;EXIT IF NO COMMA
0E3F,E0,,        MOVX    A,@DPTR         ;GET INPUT TERMINATOR
0E40,B4 2C 06,,        CJNE    A,#',',IN5      ;IF NOT A COMMA DO A CR AND TRY AGAIN
0E43,A3,,        INC     DPTR            ;BUMP PAST COMMA AND READ NEXT VALUE
0E44,12 18 55,,        CALL    TEMPD
0E47,80 CF,,        SJMP    IN3
,,,        ;
,,,$EJECT
,,,        ;
0E49,90 00 F1,IN5,IN5:    MOV     DPTR,#IAN       ;PRINT INPUT A NUMBER
0E4C,12 06 A5,,        CALL    CRP             ;DO A CR, THEN, PRINT FROM ROM
0E4F,02 18 45,,        LJMP    CC1             ;TRY IT AGAIN
,,,        ;
0E52,E0,IN6,IN6:    MOVX    A,@DPTR
0E53,B4 0D 01,,        CJNE    A,#CR,EIGP
0E56,22,,        RET
,,,        ;
0E57,90 03 69,EIGP,EIGP:   MOV     DPTR,#EIG
0E5A,12 06 A5,,        CALL    CRP             ;PRINT THE MESSAGE AND EXIT
0E5D,81 44,,        AJMP    SP0             ;EXIT WITH A CRLF
,,,        ;
,,,        ;***************************************************************
,,,        ;
0E5F,,SOT,SOT:    ; On timer interrupt
,,,        ;
,,,        ;***************************************************************
,,,        ;
0E5F,D1 8E,,        ACALL   TWO             ;GET THE NUMBERS
0E61,8B 4B,,        MOV     SP_H,R3
0E63,89 4C,,        MOV     SP_L,R1
0E65,90 01 26,,        MOV     DPTR,#TIV       ;SAVE THE NUMBER
0E68,D2 10,,        SETB    OTS
0E6A,A1 F8,,        AJMP    R76S            ;EXIT
,,,        ;
,,,        ;
,,,        ;***************************************************************
,,,        ;
0E6C,,SCALL,SCALL:  ; Call a user rountine
,,,        ;
,,,        ;***************************************************************
,,,        ;
0E6C,F1 39,,        ACALL   INTERR          ;CONVERT INTEGER
0E6E,BA 00 0A,,        CJNE    R2,#0,S_C_1     ;SEE IF TRAP
0E71,E8,,        MOV     A,R0
0E72,20 E7 06,,        JB      ACC.7,S_C_1
0E75,28,,        ADD     A,R0
0E76,90 41 00,,        MOV     DPTR,#4100H
0E79,F5 82,,        MOV     DPL,A
,,,        ;
0E7B,31 74,S_C_1,S_C_1:  ACALL   AC1             ;JUMP TO USER PROGRAM
0E7D,53 D0 E7,,        ANL     PSW,#11100111B  ;BACK TO BANK 0
0E80,22,,        RET                     ;EXIT
,,,        ;
,,,$EJECT
,,,        ;**************************************************************
,,,        ;
0E81,,THREE,THREE:  ; Save value for timer function
,,,        ;
,,,        ;**************************************************************
,,,        ;
0E81,D1 97,,        ACALL   ONE             ;GET THE FIRST INTEGER
0E83,12 16 79,,        CALL    CBIAS           ;BIAS FOR TIMER LOAD
0E86,8B 40,,        MOV     T_HH,R3
0E88,89 41,,        MOV     T_LL,R1
0E8A,7F 2C,,        MOV     R7,#','         ;WASTE A COMMA
0E8C,91 EE,,        ACALL   EATC            ;FALL THRU TO TWO
,,,        ;
,,,        ;**************************************************************
,,,        ;
0E8E,,TWO,TWO:    ; Get two values seperated by a comma off the stack
,,,        ;
,,,        ;**************************************************************
,,,        ;
0E8E,F1 4C,,        ACALL   EXPRB
0E90,7F 2C,,        MOV     R7,#','         ;WASTE THE COMMA
0E92,F1 4A,,        ACALL   WE
0E94,02 14 93,,        JMP     TWOL            ;EXIT
,,,        ;
,,,        ;*************************************************************
,,,        ;
0E97,,ONE,ONE:    ; Evaluate an expression and get an integer
,,,        ;
,,,        ;*************************************************************
,,,        ;
0E97,F1 4C,,        ACALL   EXPRB           ;EVALUATE EXPERSSION
,,,        ;
0E99,12 12 15,IFIXL,IFIXL:  CALL    IFIX            ;INTEGERS IN R3:R1
0E9C,E9,,        MOV     A,R1
0E9D,22,,        RET
,,,        ;
,,,        ;
,,,        ;*************************************************************
,,,        ;
0E9E,,I_PI,I_PI:   ; Increment text pointer then get an integer
,,,        ;
,,,        ;*************************************************************
,,,        ;
0E9E,D1 E0,,        ACALL   GCI1            ;BUMP TEXT, THEN GET INTEGER
,,,        ;
0EA0,,PAREN_INT,PAREN_INT:; Get an integer in parens ( )
,,,        ;
0EA0,91 E8,,        ACALL   P_E
0EA2,80 F5,,        SJMP    IFIXL
,,,        ;
,,,$EJECT
,,,        ;
0EA4,85 13 83,DP_B,DP_B:   MOV     DPH,BOFAH
0EA7,85 14 82,,        MOV     DPL,BOFAL
0EAA,22,,        RET
,,,        ;
0EAB,85 0A 83,DP_T,DP_T:   MOV     DPH,TXAH
0EAE,85 08 82,,        MOV     DPL,TXAL
0EB1,22,,        RET
,,,        ;
0EB2,D1 D6,CPS,CPS:    ACALL   GC              ;GET THE CHARACTER
0EB4,B4 22 73,,        CJNE    A,#'"',NOPASS   ;EXIT IF NO STRING
0EB7,D1 AB,,        ACALL   DP_T            ;GET TEXT POINTER
0EB9,A3,,        INC     DPTR            ;BUMP PAST "
0EBA,7C 22,,        MOV     R4,#'"'
0EBC,12 06 BB,,        CALL    PN0             ;DO THE PRINT
0EBF,A3,,        INC     DPTR            ;GO PAST QUOTE
0EC0,C3,,        CLR     C               ;PASSED TEST
,,,        ;
0EC1,85 83 0A,T_DP,T_DP:   MOV     TXAH,DPH        ;TEXT POINTER GETS DPTR
0EC4,85 82 08,,        MOV     TXAL,DPL
0EC7,22,,        RET
,,,        ;
,,,        ;*************************************************************
,,,        ;
0EC8,,S_C,S_C:    ; Check for a string
,,,        ;
,,,        ;*************************************************************
,,,        ;
0EC8,D1 D6,,        ACALL   GC              ;GET THE CHARACTER
0ECA,B4 24 5D,,        CJNE    A,#'$',NOPASS   ;SET CARRY IF NOT A STRING
0ECD,21 EF,,        AJMP    IST_CAL         ;CLEAR CARRY, CALCULATE OFFSET
,,,        ;
,,,        ;
,,,        ;
,,,        ;**************************************************************
,,,        ;
0ECF,D1 D6,C_TST,C_TST:  ACALL   GC              ;GET A CHARACTER
0ED1,B4 2C 56,,        CJNE    A,#',',NOPASS   ;SEE IF A COMMA
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ;GC AND GCI - GET A CHARACTER FROM TEXT (NO BLANKS)
,,,        ;             PUT CHARACTER IN THE ACC
,,,        ;
,,,        ;***************************************************************
,,,        ;
0ED4,D1 E0,IGC,IGC:    ACALL   GCI1            ;BUMP POINTER, THEN GET CHARACTER
,,,        ;
0ED6,D2 D3,GC,GC:     SETB    RS0             ;USE BANK 1
0ED8,8A A0,,        MOV     P2,R2           ;SET UP PORT 2
0EDA,E2,,        MOVX    A,@R0           ;GET EXTERNAL BYTE
0EDB,C2 D3,,        CLR     RS0             ;BACK TO BANK 0
0EDD,22,,        RET                     ;EXIT
,,,        ;
0EDE,D1 D6,GCI,GCI:    ACALL   GC
,,,        ;
,,,        ; This routine bumps txa by one and always clears the carry
,,,        ;
0EE0,D2 D3,GCI1,GCI1:   SETB    RS0             ;BANK 1
0EE2,08,,        INC     R0              ;BUMP TXA
0EE3,B8 00 01,,        CJNE    R0,#0,$+4
0EE6,0A,,        INC     R2
0EE7,C2 D3,,        CLR     RS0
0EE9,22,,        RET                     ;EXIT
,,,        ;
,,,$EJECT
,,,        ;**************************************************************
,,,        ;
,,,        ; Check delimiters
,,,        ;
,,,        ;**************************************************************
,,,        ;
0EEA,D1 D6,DELTST,DELTST: ACALL   GC              ;GET A CHARACTER
0EEC,B4 0D 02,,        CJNE    A,#CR,DT1       ;SEE IF A CR
0EEF,E4,,        CLR     A
0EF0,22,,        RET
,,,        ;
0EF1,B4 3A 36,DT1,DT1:    CJNE    A,#':',NOPASS   ;SET CARRY IF NO MATCH
,,,        ;
0EF4,22,L_RET,L_RET:  RET
,,,        ;
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,        ; FINDC - Find the character in R7, update TXA
,,,        ;
,,,        ;***************************************************************
,,,        ;
0EF5,7F 0D,FINDCR,FINDCR: MOV     R7,#CR          ;KILL A STATEMENT LINE
,,,        ;
0EF7,D1 EA,FINDC,FINDC:  ACALL   DELTST
0EF9,50 F9,,        JNC     L_RET
,,,        ;
0EFB,B5 07 01,,        CJNE    A,R7B0,FNDCL2   ;MATCH?
0EFE,22,,        RET
,,,        ;
0EFF,D1 E0,FNDCL2,FNDCL2: ACALL   GCI1
0F01,80 F4,,        SJMP    FINDC           ;LOOP
,,,        ;
0F03,D1 E0,,        ACALL   GCI1
,,,        ;
0F05,D1 EA,WCR,WCR:    ACALL   DELTST          ;WASTE UNTIL A "REAL" CR
0F07,70 FA,,        JNZ     WCR-2
0F09,22,,        RET
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; VAR_ER - Check for a variable, exit if error
,,,        ;
,,,        ;***************************************************************
,,,        ;
0F0A,B1 6E,VAR_ER,VAR_ER: ACALL   VAR
0F0C,80 2D,,        SJMP    INTERR+2
,,,        ;
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,        ; S_D0 - The Statement Action Routine DO
,,,        ;
,,,        ;***************************************************************
,,,        ;
0F0E,71 C5,S_DO,S_DO:   ACALL   CSC             ;FINISH UP THE LINE
0F10,7C 03,,        MOV     R4,#DTYPE       ;TYPE FOR STACK
0F12,71 3D,,        ACALL   SGS1            ;SAVE ON STACK
0F14,01 17,,        AJMP    ILOOP           ;EXIT
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; CLN_UP - Clean up the end of a statement, see if at end of
,,,        ;          file, eat character and line count after CR
,,,        ;
,,,        ;***************************************************************
,,,        ;
0F16,B4 3A 02,C_2,C_2:    CJNE    A,#':',C_1      ;SEE IF A TERMINATOR
0F19,C1 E0,,        AJMP    GCI1            ;BUMP POINTER AND EXIT, IF SO
,,,        ;
0F1B,B4 A8 6D,C_1,C_1:    CJNE    A,#T_ELSE,EP5
0F1E,F1 05,,        ACALL   WCR             ;WASTE UNTIL A CR
,,,        ;
0F20,D1 D6,CLN_UP,CLN_UP: ACALL   GC              ;GET THE CHARACTER
0F22,B4 0D F1,,        CJNE    A,#CR,C_2       ;SEE IF A CR
0F25,D1 D4,,        ACALL   IGC             ;GET THE NEXT CHARACTER
0F27,B4 01 02,,        CJNE    A,#EOF,B_TXA    ;SEE IF TERMINATOR
,,,        ;
0F2A,D3,NOPASS,NOPASS: SETB    C
0F2B,22,,        RET
,,,        ;
0F2C,C5 08,B_TXA,B_TXA:  XCH     A,TXAL          ;BUMP TXA BY THREE
0F2E,24 03,,        ADD     A,#3
0F30,C5 08,,        XCH     A,TXAL
0F32,10 D7 01,,        JBC     CY,$+4
0F35,22,,        RET
0F36,05 0A,,        INC     TXAH
0F38,22,,        RET
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ;         Get an INTEGER from the text
,,,        ;         sets CARRY if not found
,,,        ;         returns the INTGER value in DPTR and R2:R0
,,,        ;         returns the terminator in ACC
,,,        ;
,,,        ;***************************************************************
,,,        ;
0F39,F1 3E,INTERR,INTERR: ACALL   INTGER          ;GET THE INTEGER
0F3B,40 4E,,        JC      EP5             ;ERROR IF NOT FOUND
0F3D,22,,        RET                     ;EXIT IF FOUND
,,,        ;
0F3E,D1 AB,INTGER,INTGER: ACALL   DP_T
0F40,12 19 A5,,        CALL    FP_BASE+18      ;CONVERT THE INTEGER
0F43,D1 C1,,        ACALL   T_DP
0F45,8A 83,,        MOV     DPH,R2          ;PUT THE RETURNED VALUE IN THE DPTR
0F47,88 82,,        MOV     DPL,R0
,,,        ;
0F49,22,ITRET,ITRET:  RET                     ;EXIT
,,,        ;
,,,        ;
0F4A,91 EE,WE,WE:     ACALL   EATC            ;WASTE THE CHARACTER
,,,        ;
,,,        ; Fall thru to evaluate the expression
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; EXPRB - Evaluate an expression
,,,        ;
,,,        ;***************************************************************
,,,        ;
0F4C,7A CD,EXPRB,EXPRB:  MOV     R2,#LOW OPBOL   ;BASE PRECEDENCE
,,,        ;
0F4E,C0 02,EP1,EP1:    PUSH    R2B0            ;SAVE OPERATOR PRECEDENCE
0F50,C2 24,,        CLR     ARGF            ;RESET STACK DESIGNATOR
,,,        ;
0F52,E5 81,EP2,EP2:    MOV     A,SP            ;GET THE STACK POINTER
0F54,24 0C,,        ADD     A,#12           ;NEED AT LEAST 12 BYTES
0F56,50 03,,        JNC     $+5
0F58,02 18 8D,,        LJMP    ERROR-3
0F5B,E5 09,,        MOV     A,ASTKA         ;GET THE ARG STACK
0F5D,94 38,,        SUBB    A,#LOW TM_TOP+12;NEED 12 BYTES ALSO
0F5F,50 03,,        JNC     $+5
0F61,02 12 0C,,        LJMP    E4YY
0F64,20 24 13,,        JB      ARGF,EP4        ;MUST BE AN OPERATOR, IF SET
0F67,B1 6E,,        ACALL   VAR             ;IS THE VALUE A VARIABLE?
0F69,50 0D,,        JNC     EP3             ;PUT VARIABLE ON STACK
,,,        ;
0F6B,F1 F8,,        ACALL   CONST           ;IS THE VALUE A NUMERIC CONSTANT?
0F6D,50 0B,,        JNC     EP4             ;IF SO, CONTINUE, IF NOT, SEE WHAT
0F6F,D1 D6,,        CALL    GC              ;GET THE CHARACTER
0F71,B4 E0 06,,        CJNE    A,#T_LPAR,EP4   ;SEE IF A LEFT PAREN
0F74,74 CE,,        MOV     A,#(LOW OPBOL+1)
0F76,80 55,,        SJMP    XLPAR           ;PROCESS THE LEFT PAREN
,,,        ;
0F78,F1 E6,EP3,EP3:    ACALL   PUSHAS          ;SAVE VAR ON STACK
,,,        ;
0F7A,D1 D6,EP4,EP4:    ACALL   GC              ;GET THE OPERATOR
,,,        ;
0F7C,B4 E0 00,,        CJNE    A,#T_LPAR,$+3   ;IS IT AN OPERATOR
0F7F,50 0E,,        JNC     XOP             ;PROCESS OPERATOR
0F81,B4 B0 00,,        CJNE    A,#T_UOP,$+3    ;IS IT A UNARY OPERATOR
0F84,50 3B,,        JNC     XBILT           ;PROCESS UNARY (BUILT IN) OPERATOR
0F86,D0 02,,        POP     R2B0            ;GET BACK PREVIOUS OPERATOR PRECEDENCE
0F88,20 24 BE,,        JB      ARGF,ITRET      ;OK IF ARG FLAG IS SET
,,,        ;
0F8B,C3,EP5,EP5:    CLR     C               ;NO RECOVERY
0F8C,02 18 88,,        LJMP    E1XX+2
,,,        ;
,,,        ; Process the operator
,,,        ;
0F8F,54 1F,XOP,XOP:    ANL     A,#1FH          ;STRIP OFF THE TOKE BITS
0F91,20 24 05,,        JB      ARGF,XOP1       ;IF ARG FLAG IS SET, PROCESS
0F94,B4 05 3C,,        CJNE    A,#T_SUB-T_LPAR,XOP3
0F97,74 09,,        MOV     A,#T_NEG-T_LPAR
,,,        ;
,,,$EJECT
0F99,24 CE,XOP1,XOP1:   ADD     A,#LOW OPBOL+1  ;BIAS THE TABLE
0F9B,FA,,        MOV     R2,A
0F9C,90 00 00,,        MOV     DPTR,#00H
0F9F,93,,        MOVC    A,@A+DPTR       ;GET THE CURRENT PRECEDENCE
0FA0,FC,,        MOV     R4,A
0FA1,D0 E0,,        POP     ACC             ;GET THE PREVIOUS PRECEDENCE
0FA3,FD,,        MOV     R5,A            ;SAVE THE PREVIOUS PRECEDENCE
0FA4,93,,        MOVC    A,@A+DPTR       ;GET IT
0FA5,B5 04 04,,        CJNE    A,R4B0,$+7      ;SEE WHICH HAS HIGHER PRECEDENCE
0FA8,B4 0C 9E,,        CJNE    A,#12,ITRET     ;SEE IF ANEG
0FAB,D3,,        SETB    C
0FAC,50 9B,,        JNC     ITRET           ;PROCESS NON-INCREASING PRECEDENCE
,,,        ;
,,,        ; Save increasing precedence
,,,        ;
0FAE,C0 05,,        PUSH    R5B0            ;SAVE OLD PRECEDENCE ADDRESS
0FB0,C0 02,,        PUSH    R2B0            ;SAVE NEW PRECEDENCE ADDRESS
0FB2,D1 E0,,        ACALL   GCI1            ;EAT THE OPERATOR
0FB4,F1 4E,,        ACALL   EP1             ;EVALUATE REMAINING EXPRESSION
0FB6,D0 E0,,        POP     ACC
,,,        ;
,,,        ; R2 has the action address, now setup and perform operation
,,,        ;
0FB8,90 00 57,XOP2,XOP2:   MOV     DPTR,#OPTAB
0FBB,24 32,,        ADD     A,#LOW (NOT OPBOL)
0FBD,31 64,,        CALL    ISTA1           ;SET UP TO RETURN TO EP2
0FBF,E1 52,,        AJMP    EP2             ;JUMP TO EVALUATE EXPRESSION
,,,        ;
,,,        ; Built-in operator processing
,,,        ;
0FC1,D1 E0,XBILT,XBILT:  ACALL   GCI1            ;EAT THE TOKEN
0FC3,24 2E,,        ADD     A,#LOW (50H+LOW UOPBOL)
0FC5,20 24 C3,,        JB      ARGF,EP5        ;XBILT MUST COME AFTER AN OPERATOR
0FC8,B4 EC 00,,        CJNE    A,#STP,$+3
0FCB,50 EB,,        JNC     XOP2
,,,        ;
0FCD,C0 E0,XLPAR,XLPAR:  PUSH    ACC             ;PUT ADDRESS ON THE STACK
0FCF,91 E8,,        ACALL   P_E
0FD1,80 E3,,        SJMP    XOP2-2          ;PERFORM OPERATION
,,,        ;
0FD3,B4 03 B5,XOP3,XOP3:   CJNE    A,#T_ADD-T_LPAR,EP5
0FD6,D1 E0,,        ACALL   GCI1
0FD8,E1 52,,        AJMP    EP2             ;WASTE + SIGN
,,,        ;
,,,$EJECT
0FDA,B1 B6,XPOP,XPOP:   ACALL   X3120           ;FLIP ARGS THEN POP
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,        ; POPAS - Pop arg stack and copy variable to R3:R1
,,,        ;
,,,        ;***************************************************************
,,,        ;
0FDC,12 12 41,POPAS,POPAS:  LCALL   INC_ASTKA
0FDF,02 14 64,,        JMP     VARCOP          ;COPY THE VARIABLE
,,,        ;
0FE2,7A 01,AXTAL,AXTAL:  MOV     R2,#HIGH CXTAL
0FE4,78 13,,        MOV     R0,#LOW CXTAL
,,,        ;
,,,        ; fall thru
,,,        ;
,,,        ;***************************************************************
,,,        ;
0FE6,,PUSHAS,PUSHAS: ; Push the Value addressed by R2:R0 onto the arg stack
,,,        ;
,,,        ;***************************************************************
,,,        ;
0FE6,12 11 FD,,        CALL    DEC_ASTKA
0FE9,D2 24,,        SETB    ARGF            ;SAYS THAT SOMTHING IS ON THE STACK
0FEB,02 14 64,,        LJMP    VARCOP
,,,        ;
,,,        ;
,,,        ;***************************************************************
,,,        ;
0FEE,,ST_A,ST_A:   ; Store at expression
,,,        ;
,,,        ;***************************************************************
,,,        ;
0FEE,D1 97,,        ACALL   ONE             ;GET THE EXPRESSION
0FF0,80 EA,,        SJMP    POPAS           ;SAVE IT
,,,        ;
,,,        ;
,,,        ;***************************************************************
,,,        ;
0FF2,,LD_A,LD_A:   ; Load at expression
,,,        ;
,,,        ;***************************************************************
,,,        ;
0FF2,D1 97,,        ACALL   ONE             ;GET THE EXPRESSION
0FF4,B1 B6,,        ACALL   X3120           ;FLIP ARGS
0FF6,80 EE,,        SJMP    PUSHAS
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
0FF8,,CONST,CONST:  ; Get a constant fron the text
,,,        ;
,,,        ;***************************************************************
,,,        ;
0FF8,D1 D6,,        CALL    GC              ;FIRST SEE IF LITERAL
0FFA,B4 D1 14,,        CJNE    A,#T_ASC,C0C    ;SEE IF ASCII TOKEN
0FFD,D1 D4,,        CALL    IGC             ;GET THE CHARACTER AFTER TOKEN
0FFF,B4 24 06,,        CJNE    A,#'$',CN0      ;SEE IF A STRING
,,,        ;
1002,12 0A 26,CNX,CNX:    CALL    CSY             ;CALCULATE IT
1005,02 13 B2,,        JMP     AXBYTE+2        ;SAVE IT ON THE STACK
,,,        ;
1008,12 14 A3,CN0,CN0:    CALL    TWO_R2          ;PUT IT ON THE STACK
100B,12 0E E0,,        CALL    GCI1            ;BUMP THE POINTER
100E,02 0C EC,,        JMP     ERPAR           ;WASTE THE RIGHT PAREN
,,,        ;
,,,        ;
1011,12 0E AB,C0C,C0C:    CALL    DP_T            ;GET THE TEXT POINTER
1014,12 19 55,,        CALL    GET_NUM         ;GET THE NUMBER
1017,B4 FF 02,,        CJNE    A,#0FFH,C1C     ;SEE IF NO NUMBER
101A,D3,,        SETB    C
101B,22,C2C,C2C:    RET
,,,        ;
101C,70 06,C1C,C1C:    JNZ     FPTST
101E,C3,,        CLR     C
101F,D2 24,,        SETB    ARGF
,,,        ;
1021,02 0E C1,C3C,C3C:    JMP     T_DP
,,,        ;
1024,54 0B,FPTST,FPTST:  ANL     A,#00001011B    ;CHECK FOR ERROR
1026,60 F3,,        JZ      C2C             ;EXIT IF ZERO
,,,        ;
,,,        ; Handle the error condition
,,,        ;
1028,90 17 4F,,        MOV     DPTR,#E2X       ;DIVIDE BY ZERO
102B,30 E0 03,,        JNB     ACC.0,$+6       ;UNDERFLOW
102E,90 18 05,,        MOV     DPTR,#E7X
1031,30 E1 03,,        JNB     ACC.1,$+6       ;OVERFLOW
1034,90 1F 89,,        MOV     DPTR,#E11X
,,,        ;
1037,02 18 90,FPTS,FPTS:   JMP     ERROR
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; The Command action routine - LIST
,,,        ;
,,,        ;***************************************************************
,,,        ;
103A,12 0C 21,CLIST,CLIST:  CALL    NUMC            ;SEE IF TO LINE PORT
103D,71 BD,,        ACALL   FSTK            ;PUT 0FFFFH ON THE STACK
103F,12 0F 3E,,        CALL    INTGER          ;SEE IF USER SUPPLIES LN
1042,E4,,        CLR     A               ;LN = 0 TO START
1043,FB,,        MOV     R3,A
1044,F9,,        MOV     R1,A
1045,40 14,,        JC      CL1             ;START FROM ZERO
,,,        ;
1047,12 18 55,,        CALL    TEMPD           ;SAVE THE START ADDTESS
104A,12 0E DE,,        CALL    GCI             ;GET THE CHARACTER AFTER LIST
104D,B4 E5 07,,        CJNE    A,#T_SUB,$+10   ;CHECK FOR TERMINATION ADDRESS '-'
1050,51 41,,        ACALL   INC_ASTKA       ;WASTE 0FFFFH
1052,12 0F 39,,        LCALL   INTERR          ;GET TERMINATION ADDRESS
1055,91 A6,,        ACALL   TWO_EY          ;PUT TERMINATION ON THE ARG STACK
1057,AB 0F,,        MOV     R3,TEMP5        ;GET THE START ADDTESS
1059,A9 0E,,        MOV     R1,TEMP4
,,,        ;
105B,12 05 84,CL1,CL1:    CALL    GETLIN          ;GET THE LINE NO IN R3:R1
105E,60 1E,,        JZ      CL3             ;RET IF AT END
,,,        ;
1060,11 21,CL2,CL2:    ACALL   C3C             ;SAVE THE ADDRESS
1062,A3,,        INC     DPTR            ;POINT TO LINE NUMBER
1063,D1 44,,        ACALL   PMTOP+3         ;PUT LINE NUMBER ON THE STACK
1065,31 FA,,        ACALL   CMPLK           ;COMPARE LN TO END ADDRESS
1067,40 15,,        JC      CL3             ;EXIT IF GREATER
1069,12 07 85,,        CALL    BCK             ;CHECK FOR A CONTROL C
106C,31 FD,,        ACALL   DEC_ASTKA       ;SAVE THE COMPARE ADDRESS
106E,12 0E AB,,        CALL    DP_T            ;RESTORE ADDRESS
1071,11 8F,,        ACALL   UPPL            ;UN-PROCESS THE LINE
1073,11 21,,        ACALL   C3C             ;SAVE THE CR ADDRESS
1075,11 80,,        ACALL   CL6             ;PRINT IT
1077,A3,,        INC     DPTR            ;BUMP POINTER TO NEXT LINE
1078,E0,,        MOVX    A,@DPTR         ;GET LIN LENGTH
1079,D5 E0 E4,,        DJNZ    ACC,CL2         ;LOOP
107C,51 41,,        ACALL   INC_ASTKA       ;WASTE THE COMPARE BYTE
,,,        ;
107E,E1 85,CL3,CL3:    AJMP    CMND1           ;BACK TO COMMAND PROCESSOR
,,,        ;
1080,90 00 07,CL6,CL6:    MOV     DPTR,#IBUF      ;PRINT IBUF
1083,12 06 B9,,        CALL    PRNTCR          ;PRINT IT
1086,12 0E AB,,        CALL    DP_T
,,,        ;
1089,02 06 9D,CL7,CL7:    JMP     CRLF
,,,        ;
108C,12 05 71,,        LCALL   X31DP
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ;UPPL - UN PREPROCESS A LINE ADDRESSED BY DPTR INTO IBUF
,,,        ;       RETURN SOURCE ADDRESS OF CR IN DPTR ON RETURN
,,,        ;
,,,        ;***************************************************************
,,,        ;
108F,7B 00,UPPL,UPPL:   MOV     R3,#HIGH IBUF   ;POINT R3 AT HIGH IBUF
1091,79 07,,        MOV     R1,#LOW IBUF    ;POINT R1 AT IBUF
1093,A3,,        INC     DPTR            ;SKIP OVER LINE LENGTH
1094,11 21,,        ACALL   C3C             ;SAVE THE DPTR (DP_T)
1096,12 05 6B,,        CALL    L20DPI          ;PUT LINE NUMBER IN R2:R0
1099,12 19 A3,,        CALL    FP_BASE+16      ;CONVERT R2:R0 TO INTEGER
109C,12 0E AB,,        CALL    DP_T
109F,A3,,        INC     DPTR            ;BUMP DPTR PAST THE LINE NUMBER
,,,        ;
10A0,B9 0D 00,UPP0,UPP0:   CJNE    R1,#LOW IBUF+6,$+3
10A3,40 22,,        JC      UPP1A-4         ;PUT SPACES IN TEXT
10A5,A3,,        INC     DPTR            ;BUMP PAST LN HIGH
10A6,E0,,        MOVX    A,@DPTR         ;GET USER TEXT
10A7,FE,,        MOV     R6,A            ;SAVE A IN R6 FOR TOKE COMPARE
10A8,20 E7 24,,        JB      ACC.7,UPP1      ;IF TOKEN, PROCESS
10AB,B4 20 00,,        CJNE    A,#20H,$+3      ;TRAP THE USER TOKENS
10AE,50 03,,        JNC     $+5
10B0,B4 0D 1C,,        CJNE    A,#CR,UPP1      ;DO IT IF NOT A CR
10B3,B4 22 09,,        CJNE    A,#'"',UPP9     ;SEE IF STRING
10B6,31 13,,        ACALL   UPP7            ;SAVE IT
10B8,31 15,,        ACALL   UPP8            ;GET THE NEXT CHARACTER AND SAVE IT
10BA,B4 22 FB,,        CJNE    A,#'"',$-2      ;LOOP ON QUOTES
10BD,80 E1,,        SJMP    UPP0
,,,        ;
10BF,B4 3A 09,UPP9,UPP9:   CJNE    A,#':',UPP1A    ;PUT A SPACE IN DELIMITER
10C2,31 11,,        ACALL   UPP7A
10C4,EE,,        MOV     A,R6
10C5,31 13,,        ACALL   UPP7
10C7,31 11,,        ACALL   UPP7A
10C9,80 D5,,        SJMP    UPP0
,,,        ;
10CB,31 17,UPP1A,UPP1A:  ACALL   UPP8+2          ;SAVE THE CHARACTER, UPDATE POINTER
10CD,80 D1,,        SJMP    UPP0            ;EXIT IF A CR, ELSE LOOP
,,,        ;
10CF,11 21,UPP1,UPP1:   ACALL   C3C             ;SAVE THE TEXT POINTER
10D1,A2 2D,,        MOV     C,XBIT
10D3,92 D5,,        MOV     F0,C            ;SAVE XBIT IN F0
10D5,90 01 73,,        MOV     DPTR,#TOKTAB    ;POINT AT TOKEN TABLE
10D8,30 D5 03,,        JNB     F0,UPP2
10DB,12 20 78,,        LCALL   2078H           ;SET UP DPTR FOR LOOKUP
,,,        ;
10DE,E4,UPP2,UPP2:   CLR     A               ;ZERO A FOR LOOKUP
10DF,93,,        MOVC    A,@A+DPTR       ;GET TOKEN
10E0,A3,,        INC     DPTR            ;ADVANCE THE TOKEN POINTER
10E1,B4 FF 05,,        CJNE    A,#0FFH,UP_2    ;SEE IF DONE
10E4,10 D5 EE,,        JBC     F0,UPP2-9       ;NOW DO NORMAL TABLE
10E7,E1 85,,        AJMP    CMND1           ;EXIT IF NOT FOUND
,,,        ;
10E9,B5 06 F2,UP_2,UP_2:   CJNE    A,R6B0,UPP2     ;LOOP UNTIL THE SAME
,,,        ;
10EC,B4 B0 00,UP_3,UP_3:   CJNE    A,#T_UOP,$+3
10EF,50 02,,        JNC     UPP3
10F1,31 11,,        ACALL   UPP7A           ;PRINT THE SPACE IF OK
,,,        ;
10F3,E4,UPP3,UPP3:   CLR     A               ;DO LOOKUP
10F4,93,,        MOVC    A,@A+DPTR
10F5,20 E7 07,,        JB      ACC.7,UPP4      ;EXIT IF DONE, ELSE SAVE
10F8,60 05,,        JZ      UPP4            ;DONE IF ZERO
10FA,31 13,,        ACALL   UPP7            ;SAVE THE CHARACTER
10FC,A3,,        INC     DPTR
10FD,80 F4,,        SJMP    UPP3            ;LOOP
,,,        ;
10FF,12 0E AB,UPP4,UPP4:   CALL    DP_T            ;GET IT BACK
1102,EE,,        MOV     A,R6            ;SEE IF A REM TOKEN
1103,64 96,,        XRL     A,#T_REM
1105,70 04,,        JNZ     $+6
1107,31 15,,        ACALL   UPP8
1109,80 FC,,        SJMP    $-2
110B,50 93,,        JNC     UPP0            ;START OVER AGAIN IF NO TOKEN
110D,31 11,,        ACALL   UPP7A           ;PRINT THE SPACE IF OK
110F,80 8F,,        SJMP    UPP0            ;DONE
,,,        ;
1111,74 20,UPP7A,UPP7A:  MOV     A,#' '          ;OUTPUT A SPACE
,,,        ;
1113,C1 36,UPP7,UPP7:   AJMP    PPL9+1          ;SAVE A
,,,        ;
1115,A3,UPP8,UPP8:   INC     DPTR
1116,E0,,        MOVX    A,@DPTR
1117,B4 0D F9,,        CJNE    A,#CR,UPP7
111A,C1 22,,        AJMP    PPL7+1
,,,        ;
,,,$EJECT
,,,        ;**************************************************************
,,,        ;
,,,        ; This table contains all of the floating point constants
,,,        ;
,,,        ; The constants in ROM are stored "backwards" from the way
,,,        ; basic normally treats floating point numbers. Instead of
,,,        ; loading from the exponent and decrementing the pointer,
,,,        ; ROM constants pointers load from the most significant
,,,        ; digits and increment the pointers. This is done to 1) make
,,,        ; arg stack loading faster and 2) compensate for the fact that
,,,        ; no decrement data pointer instruction exsist.
,,,        ;
,,,        ; The numbers are stored as follows:
,,,        ;
,,,        ; BYTE X+5    = MOST SIGNIFICANT DIGITS IN BCD
,,,        ; BYTE X+4    = NEXT MOST SIGNIFICANT DIGITS IN BCD
,,,        ; BYTE X+3    = NEXT LEAST SIGNIFICANT DIGITS IN BCD
,,,        ; BYTE X+2    = LEAST SIGNIFICANT DIGITS IN BCD
,,,        ; BYTE X+1    = SIGN OF THE ABOVE MANTISSA 0 = +, 1 = -
,,,        ; BYTE X      = EXPONENT IN TWO'S COMPLEMENT BINARY
,,,        ;               ZERO EXPONENT = THE NUMBER ZERO
,,,        ;
,,,        ;**************************************************************
,,,        ;
111C,7E,ATTAB,ATTAB:  DB      128-2           ; ARCTAN LOOKUP
111D,00,,        DB      00H
111E,57,,        DB      57H
111F,22,,        DB      22H
1120,66,,        DB      66H
1121,28,,        DB      28H
,,,        ;
1122,7F,,        DB      128-1
1123,01,,        DB      01H
1124,37,,        DB      37H
1125,57,,        DB      57H
1126,16,,        DB      16H
1127,16,,        DB      16H
,,,        ;
1128,7F,,        DB      128-1
1129,00,,        DB      00H
112A,14,,        DB      14H
112B,96,,        DB      96H
112C,90,,        DB      90H
112D,42,,        DB      42H
,,,        ;
112E,7F,,        DB      128-1
112F,01,,        DB      01H
1130,40,,        DB      40H
1131,96,,        DB      96H
1132,28,,        DB      28H
1133,75,,        DB      75H
,,,        ;
1134,80,,        DB      128
1135,00,,        DB      00H
1136,64,,        DB      64H
1137,62,,        DB      62H
1138,65,,        DB      65H
1139,10,,        DB      10H
,,,        ;
113A,80,,        DB      128
113B,01,,        DB      01H
113C,99,,        DB      99H
113D,88,,        DB      88H
113E,20,,        DB      20H
113F,14,,        DB      14H
,,,        ;
1140,80,,        DB      128
1141,00,,        DB      00H
1142,51,,        DB      51H
1143,35,,        DB      35H
1144,99,,        DB      99H
1145,19,,        DB      19H
,,,        ;
1146,80,,        DB      128
1147,01,,        DB      01H
1148,45,,        DB      45H
1149,31,,        DB      31H
114A,33,,        DB      33H
114B,33,,        DB      33H
,,,        ;
114C,81,,        DB      129
114D,00,,        DB      00H
114E,00,,        DB      00H
114F,00,,        DB      00H
1150,00,,        DB      00H
1151,10,,        DB      10H
,,,        ;
1152,FF,,        DB      0FFH            ;END OF TABLE
,,,        ;
1153,81,NTWO,NTWO:   DB      129
1154,00,,        DB      0
1155,00,,        DB      0
1156,00,,        DB      0
1157,00,,        DB      0
1158,20,,        DB      20H
,,,        ;
1159,7C,TTIME,TTIME:  DB      128-4           ; CLOCK CALCULATION
115A,00,,        DB      00H
115B,00,,        DB      00H
115C,00,,        DB      00H
115D,04,,        DB      04H
115E,13,,        DB      13H
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; COSINE - Add pi/2 to stack, then fall thru to SIN
,,,        ;
,,,        ;***************************************************************
,,,        ;
115F,31 84,ACOS,ACOS:   ACALL   POTWO           ;PUT PI/2 ON THE STACK
1161,F1 3F,,        ACALL   AADD            ;TOS = TOS+PI/2
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,        ; SINE - use taylor series to calculate sin function
,,,        ;
,,,        ;***************************************************************
,,,        ;
1163,91 71,ASIN,ASIN:   ACALL   PIPI            ;PUT PI ON THE STACK
1165,31 A7,,        ACALL   RV              ;REDUCE THE VALUE
1167,E5 46,,        MOV     A,MT2           ;CALCULATE THE SIGN
1169,54 01,,        ANL     A,#01H          ;SAVE LSB
116B,62 45,,        XRL     MT1,A           ;SAVE SIGN IN MT1
116D,91 1E,,        ACALL   CSTAKA          ;NOW CONVERT TO ONE QUADRANT
116F,31 84,,        ACALL   POTWO
1171,31 FA,,        ACALL   CMPLK           ;DO COMPARE
1173,40 04,,        JC      $+6
1175,91 71,,        ACALL   PIPI
1177,F1 1A,,        ACALL   ASUB
1179,71 81,,        ACALL   AABS
117B,90 16 CC,,        MOV     DPTR,#SINTAB    ;SET UP LOOKUP TABLE
117E,31 8D,,        ACALL   POLYC           ;CALCULATE THE POLY
1180,31 CC,,        ACALL   STRIP
1182,21 EE,,        AJMP    SIN0
,,,        ;
,,,        ; Put PI/2 on the stack
,,,        ;
1184,91 71,POTWO,POTWO:  ACALL   PIPI            ;PUT PI ON THE STACK, NOW DIVIDE
,,,        ;
1186,90 11 53,DBTWO,DBTWO:  MOV     DPTR,#NTWO
1189,91 25,,        ACALL   PUSHC
,,,        ;MOV    A,#2            ;BY TWO
,,,        ;ACALL  TWO_R2
118B,61 FC,,        AJMP    ADIV
,,,        ;
,,,$EJECT
,,,        ;*************************************************************
,,,        ;
118D,,POLYC,POLYC:  ; Expand a power series to calculate a polynomial
,,,        ;
,,,        ;*************************************************************
,,,        ;
118D,91 1C,,        ACALL   CSTAKA2         ;COPY THE STACK
118F,31 A2,,        ACALL   AMUL            ;SQUARE THE STACK
1191,91 3A,,        ACALL   POP_T1          ;SAVE X*X
1193,91 25,,        ACALL   PUSHC           ;PUT CONSTANT ON STACK
,,,        ;
1195,91 41,POLY1,POLY1:  ACALL   PUSH_T1         ;PUT COMPUTED VALUE ON STACK
1197,31 A2,,        ACALL   AMUL            ;MULTIPLY CONSTANT AND COMPUTED VALUE
1199,91 25,,        ACALL   PUSHC           ;PUT NEXT CONSTANT ON STACK
119B,F1 3F,,        ACALL   AADD            ;ADD IT TO THE OLD VALUE
119D,E4,,        CLR     A               ;CHECK TO SEE IF DONE
119E,93,,        MOVC    A,@A+DPTR
119F,B4 FF F3,,        CJNE    A,#0FFH,POLY1   ;LOOP UNTIL DONE
,,,        ;
11A2,12 19 99,AMUL,AMUL:   LCALL   FP_BASE+6
11A5,01 24,,        AJMP    FPTST
,,,        ;
,,,        ;*************************************************************
,,,        ;
11A7,,RV,RV:     ; Reduce a value for Trig and A**X functions
,,,        ;
,,,        ; value = (value/x - INT(value/x)) * x
,,,        ;
,,,        ;*************************************************************
,,,        ;
11A7,91 5E,,        ACALL   C_T2            ;COPY TOS TO T2
11A9,71 FC,,        ACALL   ADIV            ;TOS = TOS/TEMP2
11AB,71 81,,        ACALL   AABS            ;MAKE THE TOS A POSITIVE NUMBER
11AD,F5 45,,        MOV     MT1,A           ;SAVE THE SIGN
11AF,91 1C,,        ACALL   CSTAKA2         ;COPY THE STACK TWICE
11B1,51 15,,        ACALL   IFIX            ;PUT THE NUMBER IN R3:R1
11B3,C0 03,,        PUSH    R3B0            ;SAVE R3
11B5,89 46,,        MOV     MT2,R1          ;SAVE THE LS BYTE IN MT2
11B7,71 5F,,        ACALL   AINT            ;MAKE THE TOS AN INTEGER
11B9,F1 1A,,        ACALL   ASUB            ;TOS = TOS/T2 - INT(TOS/T2)
11BB,91 48,,        ACALL   P_T2            ;TOS = T2
11BD,31 A2,,        ACALL   AMUL            ;TOS = T2*(TOS/T2 - INT(TOS/T2)
11BF,D0 03,,        POP     R3B0            ;RESTORE R3
11C1,22,,        RET                     ;EXIT
,,,        ;
,,,$EJECT
,,,        ;**************************************************************
,,,        ;
,,,        ; TAN
,,,        ;
,,,        ;**************************************************************
,,,        ;
11C2,91 1E,ATAN,ATAN:   ACALL   CSTAKA          ;DUPLACATE STACK
11C4,31 63,,        ACALL   ASIN            ;TOS = SIN(X)
11C6,91 4C,,        ACALL   SWAP_ASTKA      ;TOS = X
11C8,31 5F,,        ACALL   ACOS            ;TOS = COS(X)
11CA,61 FC,,        AJMP    ADIV            ;TOS = SIN(X)/COS(X)
,,,        ;
11CC,51 45,STRIP,STRIP:  ACALL   SETREG          ;SETUP R0
11CE,7B 01,,        MOV     R3,#1           ;LOOP COUNT
11D0,61 73,,        AJMP    AI2-1           ;WASTE THE LSB
,,,        ;
,,,        ;************************************************************
,,,        ;
,,,        ; ARC TAN
,,,        ;
,,,        ;************************************************************
,,,        ;
11D2,71 81,AATAN,AATAN:  ACALL   AABS
11D4,F5 45,,        MOV     MT1,A           ;SAVE THE SIGN
11D6,51 45,,        ACALL   SETREG          ;GET THE EXPONENT
11D8,24 7F,,        ADD     A,#7FH          ;BIAS THE EXPONENT
11DA,92 2A,,        MOV     UBIT,C          ;SAVE CARRY STATUS
11DC,50 02,,        JNC     $+4             ;SEE IF > 1
11DE,51 6E,,        ACALL   RECIP           ;IF > 1, TAKE RECIP
11E0,90 11 1C,,        MOV     DPTR,#ATTAB     ;SET UP TO CALCULATE THE POLY
11E3,31 8D,,        ACALL   POLYC           ;CALCULATE THE POLY
11E5,30 2A 06,,        JNB     UBIT,SIN0       ;JUMP IF NOT SET
11E8,71 93,,        ACALL   ANEG            ;MAKE X POLY NEGATIVE
11EA,31 84,,        ACALL   POTWO           ;SUBTRACT PI/2
11EC,F1 3F,,        ACALL   AADD
,,,        ;
11EE,E5 45,SIN0,SIN0:   MOV     A,MT1           ;GET THE SIGN
11F0,60 19,,        JZ      SRT
11F2,61 93,,        AJMP    ANEG
,,,        ;
,,,$EJECT
,,,        ;*************************************************************
,,,        ;
,,,        ; FCOMP - COMPARE 0FFFFH TO TOS
,,,        ;
,,,        ;*************************************************************
,,,        ;
11F4,91 1E,FCMP,FCMP:   ACALL   CSTAKA          ;COPY THE STACK
11F6,71 BD,,        ACALL   FSTK            ;MAKE THE TOS = 0FFFFH
11F8,91 4C,,        ACALL   SWAP_ASTKA      ;NOW COMPARE IS 0FFFFH - X
,,,        ;
11FA,02 19 97,CMPLK,CMPLK:  JMP     FP_BASE+4       ;DO THE COMPARE
,,,        ;
,,,        ;*************************************************************
,,,        ;
11FD,,DEC_ASTKA,DEC_ASTKA:      ;Push ARG STACK and check for underflow
,,,        ;
,,,        ;*************************************************************
,,,        ;
11FD,74 FA,,        MOV     A,#-FPSIZ
11FF,25 09,,        ADD     A,ASTKA
1201,B4 32 00,,        CJNE    A,#LOW TM_TOP+6,$+3
1204,40 06,,        JC      E4YY
1206,F5 09,,        MOV     ASTKA,A
1208,F9,,        MOV     R1,A
1209,7B 01,,        MOV     R3,#ASTKAH
,,,        ;
120B,22,SRT,SRT:    RET
,,,        ;
120C,90 03 77,E4YY,E4YY:   MOV     DPTR,#EXA
120F,01 37,,        AJMP    FPTS            ;ARG STACK ERROR
,,,        ;
,,,        ;
1211,91 25,AXTAL3,AXTAL3: ACALL   PUSHC           ;PUSH CONSTANT, THEN MULTIPLY
1213,31 A2,,        ACALL   AMUL
,,,        ;
,,,        ; Fall thru to IFIX
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
1215,,IFIX,IFIX:   ; Convert a floating point number to an integer, put in R3:R1
,,,        ;
,,,        ;***************************************************************
,,,        ;
1215,E4,,        CLR     A               ;RESET THE START
1216,FB,,        MOV     R3,A
1217,F9,,        MOV     R1,A
1218,A8 09,,        MOV     R0,ASTKA        ;GET THE ARG STACK
121A,75 A0 01,,        MOV     P2,#ASTKAH
121D,E2,,        MOVX    A,@R0           ;READ EXPONENT
121E,C3,,        CLR     C
121F,94 81,,        SUBB    A,#81H          ;BASE EXPONENT
1221,FC,,        MOV     R4,A            ;SAVE IT
1222,18,,        DEC     R0              ;POINT AT SIGN
1223,E2,,        MOVX    A,@R0           ;GET THE SIGN
1224,70 56,,        JNZ     SQ_ERR          ;ERROR IF NEGATIVE
1226,40 19,,        JC      INC_ASTKA       ;EXIT IF EXPONENT IS < 81H
1228,0C,,        INC     R4              ;ADJUST LOOP COUNTER
1229,E8,,        MOV     A,R0            ;BUMP THE POINTER REGISTER
122A,94 05,,        SUBB    A,#FPSIZ-1
122C,F8,,        MOV     R0,A
,,,        ;
122D,08,I2,I2:     INC     R0              ;POINT AT DIGIT
122E,E2,,        MOVX    A,@R0           ;GET DIGIT
122F,C4,,        SWAP    A               ;FLIP
1230,12 19 A7,,        CALL    FP_BASE+20      ;ACCUMULATE
1233,40 47,,        JC      SQ_ERR
1235,DC 02,,        DJNZ    R4,$+4
1237,80 08,,        SJMP    INC_ASTKA
1239,E2,,        MOVX    A,@R0           ;GET DIGIT
123A,12 19 A7,,        CALL    FP_BASE+20
123D,40 3D,,        JC      SQ_ERR
123F,DC EC,,        DJNZ    R4,I2
,,,        ;
,,,$EJECT
,,,        ;************************************************************
,,,        ;
1241,,INC_ASTKA,INC_ASTKA:      ; Pop the ARG STACK and check for overflow
,,,        ;
,,,        ;************************************************************
,,,        ;
1241,74 06,,        MOV     A,#FPSIZ        ;NUMBER TO POP
1243,80 01,,        SJMP    SETREG+1
,,,        ;
1245,E4,SETREG,SETREG: CLR     A               ;DON'T POP ANYTHING
1246,A8 09,,        MOV     R0,ASTKA
1248,7A 01,,        MOV     R2,#ASTKAH
124A,8A A0,,        MOV     P2,R2
124C,28,,        ADD     A,R0
124D,40 BD,,        JC      E4YY
124F,F5 09,,        MOV     ASTKA,A
1251,E2,,        MOVX    A,@R0
1252,22,A_D,A_D:    RET
,,,        ;
,,,        ;************************************************************
,,,        ;
,,,        ; EBIAS - Bias a number for E to the X calculations
,,,        ;
,,,        ;************************************************************
,,,        ;
1253,91 35,EBIAS,EBIAS:  ACALL   PUSH_ONE
1255,31 A7,,        ACALL   RV
1257,BB 00 22,,        CJNE    R3,#00H,SQ_ERR  ;ERROR IF R3 <> 0
125A,91 5E,,        ACALL   C_T2            ;TEMP 2 GETS FRACTIONS
125C,51 41,,        ACALL   INC_ASTKA
125E,91 3A,,        ACALL   POP_T1
1260,91 35,,        ACALL   PUSH_ONE
,,,        ;
1262,E5 46,AELP,AELP:   MOV     A,MT2
1264,70 0E,,        JNZ     AEL1
,,,        ;
1266,E5 45,,        MOV     A,MT1
1268,60 E8,,        JZ      A_D
126A,90 01 1E,,        MOV     DPTR,#FPT2-1
126D,F0,,        MOVX    @DPTR,A         ;MAKE THE FRACTIONS NEGATIVE
,,,        ;
126E,91 35,RECIP,RECIP:  ACALL   PUSH_ONE
1270,91 4C,,        ACALL   SWAP_ASTKA
1272,61 FC,,        AJMP    ADIV
,,,        ;
1274,15 46,AEL1,AEL1:   DEC     MT2
1276,91 41,,        ACALL   PUSH_T1
1278,31 A2,,        ACALL   AMUL
127A,80 E6,,        SJMP    AELP
,,,        ;
127C,02 09 C5,SQ_ERR,SQ_ERR: LJMP    E3XX            ;LINK TO BAD ARG
,,,        ;
,,,$EJECT
,,,        ;************************************************************
,,,        ;
,,,        ; SQUARE ROOT
,,,        ;
,,,        ;************************************************************
,,,        ;
127F,71 81,ASQR,ASQR:   ACALL   AABS            ;GET THE SIGN
1281,70 F9,,        JNZ     SQ_ERR          ;ERROR IF NEGATIVE
1283,91 5E,,        ACALL   C_T2            ;COPY VARIABLE TO T2
1285,91 3A,,        ACALL   POP_T1          ;SAVE IT IN T1
1287,78 19,,        MOV     R0,#LOW FPT1
1289,E2,,        MOVX    A,@R0           ;GET EXPONENT
128A,60 24,,        JZ      ALN-2           ;EXIT IF ZERO
128C,24 80,,        ADD     A,#128          ;BIAS THE EXPONENT
128E,50 05,,        JNC     SQR1            ;SEE IF < 80H
1290,03,,        RR      A
1291,54 7F,,        ANL     A,#127
1293,80 07,,        SJMP    SQR2
,,,        ;
1295,F4,SQR1,SQR1:   CPL     A               ;FLIP BITS
1296,04,,        INC     A
1297,03,,        RR      A
1298,54 7F,,        ANL     A,#127          ;STRIP MSB
129A,F4,,        CPL     A
129B,04,,        INC     A
,,,        ;
129C,24 80,SQR2,SQR2:   ADD     A,#128          ;BIAS EXPONENT
129E,F2,,        MOVX    @R0,A           ;SAVE IT
,,,        ;
,,,        ; NEWGUESS = ( X/OLDGUESS + OLDGUESS) / 2
,,,        ;
129F,91 48,SQR4,SQR4:   ACALL   P_T2            ;TOS = X
12A1,91 41,,        ACALL   PUSH_T1         ;PUT NUMBER ON STACK
12A3,71 FC,,        ACALL   ADIV            ;TOS = X/GUESS
12A5,91 41,,        ACALL   PUSH_T1         ;PUT ON AGAIN
12A7,F1 3F,,        ACALL   AADD            ;TOS = X/GUESS + GUESS
12A9,31 86,,        ACALL   DBTWO           ;TOS = ( X/GUESS + GUESS ) / 2
12AB,71 0E,,        ACALL   TEMP_COMP       ;SEE IF DONE
12AD,30 D5 EF,,        JNB     F0,SQR4
,,,        ;
12B0,81 41,,        AJMP    PUSH_T1         ;PUT THE ANSWER ON THE STACK
,,,        ;
,,,$EJECT
,,,        ;*************************************************************
,,,        ;
,,,        ; NATURAL LOG
,,,        ;
,,,        ;*************************************************************
,,,        ;
12B2,71 81,ALN,ALN:    ACALL   AABS            ;MAKE SURE THAT NUM IS POSITIVE
12B4,70 C6,,        JNZ     SQ_ERR          ;ERROR IF NOT
12B6,F5 46,,        MOV     MT2,A           ;CLEAR FOR LOOP
12B8,08,,        INC     R0              ;POINT AT EXPONENT
12B9,E2,,        MOVX    A,@R0           ;READ THE EXPONENT
12BA,60 C0,,        JZ      SQ_ERR          ;ERROR IF EXPONENT IS ZERO
12BC,B4 81 00,,        CJNE    A,#81H,$+3      ;SEE IF NUM >= 1
12BF,92 2A,,        MOV     UBIT,C          ;SAVE CARRY STATUS
12C1,40 02,,        JC      $+4             ;TAKE RECIP IF >= 1
12C3,51 6E,,        ACALL   RECIP
,,,        ;
,,,        ; Loop to reduce
,,,        ;
12C5,91 1E,ALNL,ALNL:   ACALL   CSTAKA          ;COPY THE STACK FOR COMPARE
12C7,91 35,,        ACALL   PUSH_ONE        ;COMPARE NUM TO ONE
12C9,31 FA,,        ACALL   CMPLK
12CB,50 1D,,        JNC     ALNO            ;EXIT IF DONE
12CD,51 45,,        ACALL   SETREG          ;GET THE EXPONENT
12CF,24 85,,        ADD     A,#85H          ;SEE HOW BIG IT IS
12D1,50 0E,,        JNC     ALN11           ;BUMP BY EXP(11) IF TOO SMALL
12D3,91 22,,        ACALL   PLNEXP          ;PUT EXP(1) ON STACK
12D5,74 01,,        MOV     A,#1            ;BUMP COUNT
,,,        ;
12D7,25 46,ALNE,ALNE:   ADD     A,MT2
12D9,40 A1,,        JC      SQ_ERR
12DB,F5 46,,        MOV     MT2,A
12DD,31 A2,,        ACALL   AMUL            ;BIAS THE NUMBER
12DF,80 E4,,        SJMP    ALNL
,,,        ;
12E1,90 17 ED,ALN11,ALN11:  MOV     DPTR,#EXP11     ;PUT EXP(11) ON STACK
12E4,91 25,,        ACALL   PUSHC
12E6,74 0B,,        MOV     A,#11
12E8,80 ED,,        SJMP    ALNE
,,,        ;
,,,$EJECT
12EA,91 5E,ALNO,ALNO:   ACALL   C_T2            ;PUT NUM IN TEMP 2
12EC,91 35,,        ACALL   PUSH_ONE        ;TOS = 1
12EE,F1 1A,,        ACALL   ASUB            ;TOS = X - 1
12F0,91 48,,        ACALL   P_T2            ;TOS = X
12F2,91 35,,        ACALL   PUSH_ONE        ;TOS = 1
12F4,F1 3F,,        ACALL   AADD            ;TOS = X + 1
12F6,71 FC,,        ACALL   ADIV            ;TOS = (X-1)/(X+1)
12F8,90 16 A7,,        MOV     DPTR,#LNTAB     ;LOG TABLE
12FB,31 8D,,        ACALL   POLYC
12FD,A3,,        INC     DPTR            ;POINT AT LN(10)
12FE,91 25,,        ACALL   PUSHC
1300,31 A2,,        ACALL   AMUL
1302,E5 46,,        MOV     A,MT2           ;GET THE COUNT
1304,91 A3,,        ACALL   TWO_R2          ;PUT IT ON THE STACK
1306,F1 1A,,        ACALL   ASUB            ;INT - POLY
1308,31 CC,,        ACALL   STRIP
130A,30 2A 74,,        JNB     UBIT,AABS
,,,        ;
130D,22,LN_D,LN_D:   RET
,,,        ;
,,,        ;*************************************************************
,,,        ;
130E,,TEMP_COMP,TEMP_COMP:      ; Compare FPTEMP1 to TOS, FPTEMP1 gets TOS
,,,        ;
,,,        ;*************************************************************
,,,        ;
130E,91 41,,        ACALL   PUSH_T1         ;SAVE THE TEMP
1310,91 4C,,        ACALL   SWAP_ASTKA      ;TRADE WITH THE NEXT NUMBER
1312,91 1E,,        ACALL   CSTAKA          ;COPY THE STACK
1314,91 3A,,        ACALL   POP_T1          ;SAVE THE NEW NUMBER
1316,02 19 97,,        JMP     FP_BASE+4       ;DO THE COMPARE
,,,        ;
,,,$EJECT
1319,91 22,AETOX,AETOX:  ACALL   PLNEXP          ;EXP(1) ON TOS
131B,91 4C,,        ACALL   SWAP_ASTKA      ;X ON TOS
,,,        ;
131D,,AEXP,AEXP:   ;EXPONENTIATION
,,,        ;
131D,51 53,,        ACALL   EBIAS           ;T1=BASE,T2=FRACTIONS,TOS=INT MULTIPLIED
131F,90 01 1F,,        MOV     DPTR,#FPT2      ;POINT AT FRACTIONS
1322,E0,,        MOVX    A,@DPTR         ;READ THE EXP OF THE FRACTIONS
1323,60 E8,,        JZ      LN_D            ;EXIT IF ZERO
1325,91 48,,        ACALL   P_T2            ;TOS = FRACTIONS
1327,91 41,,        ACALL   PUSH_T1         ;TOS = BASE
1329,51 45,,        ACALL   SETREG          ;SEE IF BASE IS ZERO
132B,60 02,,        JZ      $+4
132D,51 B2,,        ACALL   ALN             ;TOS = LN(BASE)
132F,31 A2,,        ACALL   AMUL            ;TOS = FRACTIONS * LN(BASE)
1331,91 22,,        ACALL   PLNEXP          ;TOS = EXP(1)
1333,91 4C,,        ACALL   SWAP_ASTKA      ;TOS = FRACTIONS * LN(BASE)
1335,51 53,,        ACALL   EBIAS           ;T2 = FRACTIONS, TOS = INT MULTIPLIED
1337,75 46 00,,        MOV     MT2,#00H        ;NOW CALCULATE E**X
133A,91 35,,        ACALL   PUSH_ONE
133C,91 1E,,        ACALL   CSTAKA
133E,91 3A,,        ACALL   POP_T1          ;T1 = 1
,,,        ;
1340,91 48,AEXL,AEXL:   ACALL   P_T2            ;TOS = FRACTIONS
1342,31 A2,,        ACALL   AMUL            ;TOS = FRACTIONS * ACCUMLATION
1344,05 46,,        INC     MT2             ;DO THE DEMONIATOR
1346,E5 46,,        MOV     A,MT2
1348,91 A3,,        ACALL   TWO_R2
134A,71 FC,,        ACALL   ADIV
134C,91 1E,,        ACALL   CSTAKA          ;SAVE THE ITERATION
134E,91 41,,        ACALL   PUSH_T1         ;NOW ACCUMLATE
1350,F1 3F,,        ACALL   AADD            ;ADD ACCUMLATION
1352,71 0E,,        ACALL   TEMP_COMP
1354,30 D5 E9,,        JNB     F0,AEXL         ;LOOP UNTIL DONE
,,,        ;
1357,51 41,,        ACALL   INC_ASTKA
1359,91 41,,        ACALL   PUSH_T1
135B,31 A2,,        ACALL   AMUL            ;LAST INT MULTIPLIED
,,,        ;
135D,21 A2,MU1,MU1:    AJMP    AMUL            ;FIRST INT MULTIPLIED
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; integer operator - INT
,,,        ;
,,,        ;***************************************************************
,,,        ;
135F,51 45,AINT,AINT:   ACALL   SETREG          ;SET UP THE REGISTERS, CLEAR CARRY
1361,94 81,,        SUBB    A,#129          ;SUBTRACT EXPONENT BIAS
1363,50 07,,        JNC     AI1             ;JUMP IF ACC > 81H
,,,        ;
,,,        ; Force the number to be a zero
,,,        ;
1365,51 41,,        ACALL   INC_ASTKA       ;BUMP THE STACK
,,,        ;
1367,90 04 E0,P_Z,P_Z:    MOV     DPTR,#ZRO       ;PUT ZERO ON THE STACK
136A,81 25,,        AJMP    PUSHC
,,,        ;
136C,94 07,AI1,AI1:    SUBB    A,#7
136E,50 10,,        JNC     AI3
1370,F4,,        CPL     A
1371,04,,        INC     A
1372,FB,,        MOV     R3,A
1373,18,,        DEC     R0              ;POINT AT SIGN
,,,        ;
1374,18,AI2,AI2:    DEC     R0              ;NOW AT LSB'S
1375,E2,,        MOVX    A,@R0           ;READ BYTE
1376,54 F0,,        ANL     A,#0F0H         ;STRIP NIBBLE
1378,F2,,        MOVX    @R0,A           ;WRITE BYTE
1379,DB 01,,        DJNZ    R3,$+3
137B,22,,        RET
137C,E4,,        CLR     A
137D,F2,,        MOVX    @R0,A           ;CLEAR THE LOCATION
137E,DB F4,,        DJNZ    R3,AI2
,,,        ;
1380,22,AI3,AI3:    RET                     ;EXIT
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
1381,,AABS,AABS:   ; Absolute value - Make sign of number positive
,,,        ;                  return sign in ACC
,,,        ;
,,,        ;***************************************************************
,,,        ;
1381,71 93,,        ACALL   ANEG            ;CHECK TO SEE IF + OR -
1383,70 19,,        JNZ     ALPAR           ;EXIT IF NON ZERO, BECAUSE THE NUM IS
1385,F2,,        MOVX    @R0,A           ;MAKE A POSITIVE SIGN
1386,22,,        RET
,,,        ;
,,,        ;***************************************************************
,,,        ;
1387,,ASGN,ASGN:   ; Returns the sign of the number 1 = +, -1 = -
,,,        ;
,,,        ;***************************************************************
,,,        ;
1387,51 41,,        ACALL   INC_ASTKA       ;POP STACK, GET EXPONENT
1389,60 DC,,        JZ      P_Z             ;EXIT IF ZERO
138B,18,,        DEC     R0              ;BUMP TO SIGN
138C,E2,,        MOVX    A,@R0           ;GET THE SIGN
138D,FF,,        MOV     R7,A            ;SAVE THE SIGN
138E,91 35,,        ACALL   PUSH_ONE        ;PUT A ONE ON THE STACK
1390,EF,,        MOV     A,R7            ;GET THE SIGN
1391,60 0B,,        JZ      ALPAR           ;EXIT IF ZERO
,,,        ;
,,,        ; Fall thru to ANEG
,,,        ;
,,,        ;***************************************************************
,,,        ;
1393,,ANEG,ANEG:   ; Flip the sign of the number on the tos
,,,        ;
,,,        ;***************************************************************
,,,        ;
1393,51 45,,        ACALL   SETREG
1395,18,,        DEC     R0              ;POINT AT THE SIGN OF THE NUMBER
1396,60 06,,        JZ      ALPAR           ;EXIT IF ZERO
1398,E2,,        MOVX    A,@R0
1399,64 01,,        XRL     A,#01H          ;FLIP THE SIGN
139B,F2,,        MOVX    @R0,A
139C,64 01,,        XRL     A,#01H          ;RESTORE THE SIGN
,,,        ;
139E,22,ALPAR,ALPAR:  RET
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
139F,,ACBYTE,ACBYTE: ; Read the ROM
,,,        ;
,,,        ;***************************************************************
,,,        ;
139F,51 15,,        ACALL   IFIX            ;GET EXPRESSION
13A1,12 05 71,,        CALL    X31DP           ;PUT R3:R1 INTO THE DP
13A4,E4,,        CLR     A
13A5,93,,        MOVC    A,@A+DPTR
13A6,81 A3,,        AJMP    TWO_R2
,,,        ;
,,,        ;***************************************************************
,,,        ;
13A8,,ADBYTE,ADBYTE: ; Read internal memory
,,,        ;
,,,        ;***************************************************************
,,,        ;
13A8,51 15,,        ACALL   IFIX            ;GET THE EXPRESSION
13AA,12 09 DD,,        CALL    R3CK            ;MAKE SURE R3 = 0
13AD,E7,,        MOV     A,@R1
13AE,81 A3,,        AJMP    TWO_R2
,,,        ;
,,,        ;***************************************************************
,,,        ;
13B0,,AXBYTE,AXBYTE: ; Read external memory
,,,        ;
,,,        ;***************************************************************
,,,        ;
13B0,51 15,,        ACALL   IFIX            ;GET THE EXPRESSION
13B2,8B A0,,        MOV     P2,R3
13B4,E3,,        MOVX    A,@R1
13B5,81 A3,,        AJMP    TWO_R2
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; The relational operators - EQUAL                        (=)
,,,        ;                            GREATER THAN                 (>)
,,,        ;                            LESS THAN                    (<)
,,,        ;                            GREATER THAN OR EQUAL        (>=)
,,,        ;                            LESS THAN OR EQUAL           (<=)
,,,        ;                            NOT EQUAL                    (<>)
,,,        ;
,,,        ;***************************************************************
,,,        ;
13B7,31 FA,AGT,AGT:    ACALL   CMPLK
13B9,72 D5,,        ORL     C,F0            ;SEE IF EITHER IS A ONE
13BB,40 AA,,        JC      P_Z
,,,        ;
13BD,90 13 C2,FSTK,FSTK:   MOV     DPTR,#FS
13C0,81 25,,        AJMP    PUSHC
,,,        ;
13C2,85,FS,FS:     DB      85H
13C3,00,,        DB      00H
13C4,00,,        DB      00H
13C5,50,,        DB      50H
13C6,53,,        DB      53H
13C7,65,,        DB      65H
,,,        ;
13C8,31 FA,ALT,ALT:    ACALL   CMPLK
13CA,B3,,        CPL     C
13CB,80 EE,,        SJMP    AGT+4
,,,        ;
13CD,31 FA,AEQ,AEQ:    ACALL   CMPLK
13CF,A2 D5,,        MOV     C,F0
13D1,80 F7,,        SJMP    ALT+2
,,,        ;
13D3,31 FA,ANE,ANE:    ACALL   CMPLK
13D5,B2 D5,,        CPL     F0
13D7,80 F6,,        SJMP    AEQ+2
,,,        ;
13D9,31 FA,AGE,AGE:    ACALL   CMPLK
13DB,80 DE,,        SJMP    AGT+4
,,,        ;
13DD,31 FA,ALE,ALE:    ACALL   CMPLK
13DF,72 D5,,        ORL     C,F0
13E1,80 E7,,        SJMP    ALT+2
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
13E3,,ARND,ARND:   ; Generate a random number
,,,        ;
,,,        ;***************************************************************
,,,        ;
13E3,90 01 0C,,        MOV     DPTR,#RCELL     ;GET THE BINARY SEED
13E6,12 05 B2,,        CALL    L31DPI
13E9,E9,,        MOV     A,R1
13EA,C3,,        CLR     C
13EB,13,,        RRC     A
13EC,F8,,        MOV     R0,A
13ED,74 06,,        MOV     A,#6
13EF,13,,        RRC     A
13F0,29,,        ADD     A,R1
13F1,C8,,        XCH     A,R0
13F2,3B,,        ADDC    A,R3
13F3,FA,,        MOV     R2,A
13F4,15 82,,        DEC     DPL             ;SAVE THE NEW SEED
13F6,91 16,,        ACALL   S20DP
13F8,91 A6,,        ACALL   TWO_EY
13FA,71 BD,,        ACALL   FSTK
,,,        ;
13FC,12 19 9B,ADIV,ADIV:   LCALL   FP_BASE+8
13FF,01 24,,        AJMP    FPTST
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
1401,,SONERR,SONERR: ; ON ERROR Statement
,,,        ;
,,,        ;***************************************************************
,,,        ;
1401,12 0F 39,,        LCALL   INTERR          ;GET THE LINE NUMBER
1404,D2 13,,        SETB    ON_ERR
1406,90 01 02,,        MOV     DPTR,#ERRNUM    ;POINT AT THR ERROR LOCATION
1409,80 0B,,        SJMP    S20DP
,,,        ;
,,,        ;
,,,        ;**************************************************************
,,,        ;
140B,,SONEXT,SONEXT: ; ON EXT1 Statement
,,,        ;
,,,        ;**************************************************************
,,,        ;
140B,12 0F 39,,        LCALL   INTERR
140E,D2 12,,        SETB    INTBIT
1410,43 A8 84,,        ORL     IE,#10000100B   ;ENABLE INTERRUPTS
1413,90 01 20,,        MOV     DPTR,#INTLOC
,,,        ;
1416,EA,S20DP,S20DP:  MOV     A,R2            ;SAVE R2:R0 @DPTR
1417,F0,,        MOVX    @DPTR,A
1418,A3,,        INC     DPTR
1419,E8,,        MOV     A,R0
141A,F0,,        MOVX    @DPTR,A
141B,22,,        RET
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; CASTAK - Copy and push another top of arg stack
,,,        ;
,,,        ;***************************************************************
,,,        ;
141C,91 1E,CSTAKA2,CSTAKA2:ACALL   CSTAKA          ;COPY STACK TWICE
,,,        ;
141E,51 45,CSTAKA,CSTAKA: ACALL   SETREG          ;SET UP R2:R0
1420,80 23,,        SJMP    PUSH_T1+4
,,,        ;
1422,90 17 F3,PLNEXP,PLNEXP: MOV     DPTR,#EXP1
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,        ; PUSHC - Push constant on to the arg stack
,,,        ;
,,,        ;***************************************************************
,,,        ;
1425,31 FD,PUSHC,PUSHC:  ACALL   DEC_ASTKA
1427,8B A0,,        MOV     P2,R3
1429,7B 06,,        MOV     R3,#FPSIZ       ;LOOP COUNTER
,,,        ;
142B,E4,PCL,PCL:    CLR     A               ;SET UP A
142C,93,,        MOVC    A,@A+DPTR       ;LOAD IT
142D,F3,,        MOVX    @R1,A           ;SAVE IT
142E,A3,,        INC     DPTR            ;BUMP POINTERS
142F,19,,        DEC     R1
1430,DB F9,,        DJNZ    R3,PCL          ;LOOP
,,,        ;
1432,D2 24,,        SETB    ARGF
1434,22,,        RET                     ;EXIT
,,,        ;
1435,,PUSH_ONE,PUSH_ONE:;
,,,        ;
1435,90 16 F0,,        MOV     DPTR,#FPONE
1438,81 25,,        AJMP    PUSHC
,,,        ;
,,,$EJECT
,,,        ;
143A,,POP_T1,POP_T1:
,,,        ;
143A,7B 01,,        MOV     R3,#HIGH FPT1
143C,79 19,,        MOV     R1,#LOW FPT1
143E,02 0F DC,,        JMP     POPAS
,,,        ;
1441,,PUSH_T1,PUSH_T1:
,,,        ;
1441,78 19,,        MOV     R0,#LOW FPT1
1443,7A 01,,        MOV     R2,#HIGH FPT1
1445,02 0F E6,,        LJMP    PUSHAS
,,,        ;
1448,78 1F,P_T2,P_T2:   MOV     R0,#LOW FPT2
144A,80 F7,,        SJMP    $-7                     ;JUMP TO PUSHAS
,,,        ;
,,,        ;****************************************************************
,,,        ;
144C,,SWAP_ASTKA,SWAP_ASTKA:     ; SWAP TOS<>TOS-1
,,,        ;
,,,        ;****************************************************************
,,,        ;
144C,51 45,,        ACALL   SETREG          ;SET UP R2:R0 AND P2
144E,74 06,,        MOV     A,#FPSIZ        ;PUT TOS+1 IN R1
1450,FA,,        MOV     R2,A
1451,28,,        ADD     A,R0
1452,F9,,        MOV     R1,A
,,,        ;
1453,E2,S_L,S_L:    MOVX    A,@R0
1454,FB,,        MOV     R3,A
1455,E3,,        MOVX    A,@R1
1456,F2,,        MOVX    @R0,A
1457,EB,,        MOV     A,R3
1458,F3,,        MOVX    @R1,A
1459,19,,        DEC     R1
145A,18,,        DEC     R0
145B,DA F6,,        DJNZ    R2,S_L
145D,22,,        RET
,,,        ;
,,,$EJECT
,,,        ;
145E,51 45,C_T2,C_T2:   ACALL   SETREG          ;SET UP R2:R0
1460,7B 01,,        MOV     R3,#HIGH FPT2
1462,79 1F,,        MOV     R1,#LOW FPT2    ;TEMP VALUE
,,,        ;
,,,        ; Fall thru
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,        ; VARCOP - Copy a variable from R2:R0 to R3:R1
,,,        ;
,,,        ;***************************************************************
,,,        ;
1464,7C 06,VARCOP,VARCOP: MOV     R4,#FPSIZ       ;LOAD THE LOOP COUNTER
,,,        ;
1466,8A A0,V_C,V_C:    MOV     P2,R2           ;SET UP THE PORTS
1468,E2,,        MOVX    A,@R0           ;READ THE VALUE
1469,8B A0,,        MOV     P2,R3           ;PORT TIME AGAIN
146B,F3,,        MOVX    @R1,A           ;SAVE IT
146C,B1 7D,,        ACALL   DEC3210         ;BUMP POINTERS
146E,DC F6,,        DJNZ    R4,V_C          ;LOOP
1470,22,,        RET                     ;EXIT
,,,        ;
1471,90 17 FF,PIPI,PIPI:   MOV     DPTR,#PIE
1474,81 25,,        AJMP    PUSHC
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; The logical operators ANL, ORL, XRL, NOT
,,,        ;
,,,        ;***************************************************************
,,,        ;
1476,91 93,AANL,AANL:   ACALL   TWOL            ;GET THE EXPRESSIONS
1478,EB,,        MOV     A,R3            ;DO THE AND
1479,5F,,        ANL     A,R7
147A,FA,,        MOV     R2,A
147B,E9,,        MOV     A,R1
147C,5E,,        ANL     A,R6
147D,80 26,,        SJMP    TWO_EX
,,,        ;
147F,91 93,AORL,AORL:   ACALL   TWOL            ;SAME THING FOR OR
1481,EB,,        MOV     A,R3
1482,4F,,        ORL     A,R7
1483,FA,,        MOV     R2,A
1484,E9,,        MOV     A,R1
1485,4E,,        ORL     A,R6
1486,80 1D,,        SJMP    TWO_EX
,,,        ;
1488,71 BD,ANOT,ANOT:   ACALL   FSTK            ;PUT 0FFFFH ON THE STACK
,,,        ;
148A,91 93,AXRL,AXRL:   ACALL   TWOL
148C,EB,,        MOV     A,R3
148D,6F,,        XRL     A,R7
148E,FA,,        MOV     R2,A
148F,E9,,        MOV     A,R1
1490,6E,,        XRL     A,R6
1491,80 12,,        SJMP    TWO_EX
,,,        ;
1493,51 15,TWOL,TWOL:   ACALL   IFIX
1495,AF 03,,        MOV     R7,R3B0
1497,AE 01,,        MOV     R6,R1B0
1499,41 15,,        AJMP    IFIX
,,,        ;
,,,$EJECT
,,,        ;*************************************************************
,,,        ;
149B,,AGET,AGET:   ; READ THE BREAK BYTE AND PUT IT ON THE ARG STACK
,,,        ;
,,,        ;*************************************************************
,,,        ;
149B,90 01 00,,        MOV     DPTR,#GTB       ;GET THE BREAK BYTE
149E,E0,,        MOVX    A,@DPTR
149F,10 18 01,,        JBC     GTRD,TWO_R2
14A2,E4,,        CLR     A
,,,        ;
14A3,7A 00,TWO_R2,TWO_R2: MOV     R2,#00H         ;ACC GOES TO STACK
,,,        ;
,,,        ;
14A5,F8,TWO_EX,TWO_EX: MOV     R0,A            ;R2:ACC GOES TO STACK
,,,        ;
,,,        ;
14A6,D2 24,TWO_EY,TWO_EY: SETB    ARGF            ;R2:R0 GETS PUT ON THE STACK
14A8,02 19 AB,,        JMP     FP_BASE+24      ;DO IT
,,,        ;
,,,$EJECT
,,,        ;*************************************************************
,,,        ;
,,,        ; Put directs onto the stack
,,,        ;
,,,        ;**************************************************************
,,,        ;
14AB,E5 A8,A_IE,A_IE:   MOV     A,IE            ;IE
14AD,80 F4,,        SJMP    TWO_R2
,,,        ;
14AF,E5 B8,A_IP,A_IP:   MOV     A,IP            ;IP
14B1,80 F0,,        SJMP    TWO_R2
,,,        ;
14B3,AA 8C,ATIM0,ATIM0:  MOV     R2,TH0          ;TIMER 0
14B5,A8 8A,,        MOV     R0,TL0
14B7,80 ED,,        SJMP    TWO_EY
,,,        ;
14B9,AA 8D,ATIM1,ATIM1:  MOV     R2,TH1          ;TIMER 1
14BB,A8 8B,,        MOV     R0,TL1
14BD,80 E7,,        SJMP    TWO_EY
,,,        ;
14BF,AA,ATIM2,ATIM2:  DB      0AAH            ;MOV R2 DIRECT OP CODE
14C0,CD,,        DB      0CDH            ;T2 HIGH
14C1,A8,,        DB      0A8H            ;MOV R0 DIRECT OP CODE
14C2,CC,,        DB      0CCH            ;T2 LOW
14C3,80 E1,,        SJMP    TWO_EY          ;TIMER 2
,,,        ;
14C5,E5,AT2CON,AT2CON: DB      0E5H            ;MOV A,DIRECT OPCODE
14C6,C8,,        DB      0C8H            ;T2CON LOCATION
14C7,80 DA,,        SJMP    TWO_R2
,,,        ;
14C9,E5 88,ATCON,ATCON:  MOV     A,TCON          ;TCON
14CB,80 D6,,        SJMP    TWO_R2
,,,        ;
14CD,E5 89,ATMOD,ATMOD:  MOV     A,TMOD          ;TMOD
14CF,80 D2,,        SJMP    TWO_R2
,,,        ;
14D1,AA,ARCAP2,ARCAP2: DB      0AAH            ;MOV R2, DIRECT OP CODE
14D2,CB,,        DB      0CBH            ;RCAP2H LOCATION
14D3,A8,,        DB      0A8H            ;MOV R0, DIRECT OP CODE
14D4,CA,,        DB      0CAH            ;R2CAPL LOCATION
14D5,80 CF,,        SJMP    TWO_EY
,,,        ;
14D7,E5 90,AP1,AP1:    MOV     A,P1            ;GET P1
14D9,80 C8,,        SJMP    TWO_R2          ;PUT IT ON THE STACK
,,,        ;
14DB,E5,APCON,APCON:  DB      0E5H            ;MOV A, DIRECT OP CODE
14DC,87,,        DB      87H             ;ADDRESS OF PCON
14DD,80 C4,,        SJMP    TWO_R2          ;PUT PCON ON THE STACK
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ;THIS IS THE LINE EDITOR
,,,        ;
,,,        ;TAKE THE PROCESSED LINE IN IBUF AND INSERT IT INTO THE
,,,        ;BASIC TEXT FILE.
,,,        ;
,,,        ;***************************************************************
,,,        ;
14DF,02 05 66,,        LJMP    NOGO            ;CAN'T EDIT A ROM
,,,        ;
14E2,E5 13,LINE,LINE:   MOV     A,BOFAH
14E4,B4 02 F8,,        CJNE    A,#HIGH PSTART,LINE-3
14E7,12 05 A1,,        CALL    G4              ;GET END ADDRESS FOR EDITING
14EA,AC 82,,        MOV     R4,DPL
14EC,AD 83,,        MOV     R5,DPH
14EE,AB 0F,,        MOV     R3,TEMP5        ;GET HIGH ORDER IBLN
14F0,A9 0E,,        MOV     R1,TEMP4        ;LOW ORDER IBLN
,,,        ;
14F2,12 05 84,,        CALL    GETLIN          ;FIND THE LINE
14F5,70 12,,        JNZ     INSR            ;INSERT IF NOT ZERO, ELSE APPEND
,,,        ;
,,,        ;APPEND THE LINE AT THE END
,,,        ;
14F7,E5 0D,,        MOV     A,TEMP3         ;PUT IBCNT IN THE ACC
14F9,B4 04 01,,        CJNE    A,#4H,$+4       ;SEE IF NO ENTRY
14FC,22,,        RET                     ;RET IF NO ENTRY
,,,        ;
14FD,B1 9A,,        ACALL   FULL            ;SEE IF ENOUGH SPACE LEFT
14FF,AA 05,,        MOV     R2,R5B0         ;PUT END ADDRESS A INTO TRANSFER
1501,A8 04,,        MOV     R0,R4B0         ;REGISTERS
1503,B1 58,,        ACALL   IMOV            ;DO THE BLOCK MOVE
,,,        ;
1505,74 01,UE,UE:     MOV     A,#EOF          ;SAVE EOF CHARACTER
1507,A1 8B,,        AJMP    TBR
,,,        ;
,,,        ;INSERT A LINE INTO THE FILE
,,,        ;
1509,FF,INSR,INSR:   MOV     R7,A            ;SAVE IT IN R7
150A,12 18 55,,        CALL    TEMPD           ;SAVE INSERATION ADDRESS
150D,E5 0D,,        MOV     A,TEMP3         ;PUT THE COUNT LENGTH IN THE ACC
150F,40 09,,        JC      LTX             ;JUMP IF NEW LINE # NOT = OLD LINE #
1511,B4 04 01,,        CJNE    A,#04H,$+4      ;SEE IF NULL
1514,E4,,        CLR     A
,,,        ;
1515,9F,,        SUBB    A,R7            ;SUBTRACT LINE COUNT FROM ACC
1516,60 36,,        JZ      LIN1            ;LINE LENGTHS EQUAL
1518,40 1F,,        JC      GTX             ;SMALLER LINE
,,,        ;
,,,$EJECT
,,,        ;
,,,        ;EXPAND FOR A NEW LINE OR A LARGER LINE
,,,        ;
151A,FF,LTX,LTX:    MOV     R7,A            ;SAVE A IN R7
151B,E5 0D,,        MOV     A,TEMP3         ;GET THE COUNT IN THE ACC
151D,B4 04 01,,        CJNE    A,#04H,$+4      ;DO NO INSERTATION IF NULL LINE
1520,22,,        RET                     ;EXIT IF IT IS
,,,        ;
1521,EF,,        MOV     A,R7            ;GET THE COUNT BACK - DELTA IN A
1522,B1 9A,,        ACALL   FULL            ;SEE IF ENOUGH MEMORY NEW EOFA IN R3:R1
1524,12 18 4E,,        CALL    DTEMP           ;GET INSERATION ADDRESS
1527,B1 8F,,        ACALL   NMOV            ;R7:R6 GETS (EOFA)-DPTR
1529,12 0D B6,,        CALL    X3120
152C,A9 04,,        MOV     R1,R4B0         ;EOFA LOW
152E,AB 05,,        MOV     R3,R5B0         ;EOFA HIGH
1530,0E,,        INC     R6              ;INCREMENT BYTE COUNT
1531,BE 00 01,,        CJNE    R6,#00,$+4      ;NEED TO BUMP HIGH BYTE?
1534,0F,,        INC     R7
,,,        ;
1535,B1 73,,        ACALL   RMOV            ;GO DO THE INSERTION
1537,80 15,,        SJMP    LIN1            ;INSERT THE CURRENT LINE
,,,        ;
1539,F4,GTX,GTX:    CPL     A               ;FLIP ACC
153A,04,,        INC     A               ;TWOS COMPLEMENT
153B,12 05 D6,,        CALL    ADDPTR          ;DO THE ADDITION
153E,B1 8F,,        ACALL   NMOV            ;R7:R6 GETS (EOFA)-DPTR
1540,A9 82,,        MOV     R1,DPL          ;SET UP THE REGISTERS
1542,AB 83,,        MOV     R3,DPH
1544,AA 0F,,        MOV     R2,TEMP5        ;PUT INSERTATION ADDRESS IN THE RIGHT REG
1546,A8 0E,,        MOV     R0,TEMP4
1548,60 02,,        JZ      $+4             ;IF ACC WAS ZERO FROM NMOV, JUMP
154A,B1 5F,,        ACALL   LMOV            ;IF NO ZERO DO A LMOV
,,,        ;
154C,B1 05,,        ACALL   UE              ;SAVE NEW END ADDRESS
,,,        ;
154E,AA 0F,LIN1,LIN1:   MOV     R2,TEMP5        ;GET THE INSERTATION ADDRESS
1550,A8 0E,,        MOV     R0,TEMP4
1552,E5 0D,,        MOV     A,TEMP3         ;PUT THE COUNT LENGTH IN ACC
1554,B4 04 01,,        CJNE    A,#04H,IMOV     ;SEE IF NULL
1557,22,,        RET                     ;EXIT IF NULL
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ;INSERT A LINE AT ADDRESS R2:R0
,,,        ;
,,,        ;***************************************************************
,,,        ;
1558,E4,IMOV,IMOV:   CLR     A               ;TO SET UP
1559,79 04,,        MOV     R1,#LOW IBCNT   ;INITIALIZE THE REGISTERS
155B,FB,,        MOV     R3,A
155C,AE 0D,,        MOV     R6,TEMP3        ;PUT THE BYTE COUNT IN R6 FOR LMOV
155E,FF,,        MOV     R7,A            ;PUT A 0 IN R7 FOR LMOV
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,        ;COPY A BLOCK FROM THE BEGINNING
,,,        ;
,,,        ;R2:R0 IS THE DESTINATION ADDRESS
,,,        ;R3:R1 IS THE SOURCE ADDRESS
,,,        ;R7:R6 IS THE COUNT REGISTER
,,,        ;
,,,        ;***************************************************************
,,,        ;
155F,B1 88,LMOV,LMOV:   ACALL   TBYTE           ;TRANSFER THE BYTE
1561,B1 68,,        ACALL   INC3210         ;BUMP THE POINTER
1563,D1 39,,        ACALL   DEC76           ;BUMP R7:R6
1565,70 F8,,        JNZ     LMOV            ;LOOP
1567,22,,        RET                     ;GO BACK TO CALLING ROUTINE
,,,        ;
1568,08,INC3210,INC3210:INC     R0
1569,B8 00 01,,        CJNE    R0,#00H,$+4
156C,0A,,        INC     R2
,,,        ;
156D,09,,        INC     R1
156E,B9 00 01,,        CJNE    R1,#00H,$+4
1571,0B,,        INC     R3
1572,22,,        RET
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ;COPY A BLOCK STARTING AT THE END
,,,        ;
,,,        ;R2:R0 IS THE DESTINATION ADDRESS
,,,        ;R3:R1 IS THE SOURCE ADDRESS
,,,        ;R6:R7 IS THE COUNT REGISTER
,,,        ;
,,,        ;***************************************************************
,,,        ;
1573,B1 88,RMOV,RMOV:   ACALL   TBYTE           ;TRANSFER THE BYTE
1575,B1 7D,,        ACALL   DEC3210         ;DEC THE LOCATIONS
1577,D1 39,,        ACALL   DEC76           ;BUMP THE COUNTER
1579,70 F8,,        JNZ     RMOV            ;LOOP
,,,        ;
157B,00,DEC_R,DEC_R:  NOP                     ;CREATE EQUAL TIMING
157C,22,,        RET                     ;EXIT
,,,        ;
157D,18,DEC3210,DEC3210:DEC     R0              ;BUMP THE POINTER
157E,B8 FF 01,,        CJNE    R0,#0FFH,$+4    ;SEE IF OVERFLOWED
1581,1A,,        DEC     R2              ;BUMP THE HIGH BYTE
1582,19,,        DEC     R1              ;BUMP THE POINTER
1583,B9 FF F5,,        CJNE    R1,#0FFH,DEC_R  ;SEE IF OVERFLOWED
1586,1B,,        DEC     R3              ;CHANGE THE HIGH BYTE
1587,22,,        RET                     ;EXIT
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,        ;TBYTE - TRANSFER A BYTE
,,,        ;
,,,        ;***************************************************************
,,,        ;
1588,8B A0,TBYTE,TBYTE:  MOV     P2,R3           ;OUTPUT SOURCE REGISTER TO PORT
158A,E3,,        MOVX    A,@R1           ;PUT BYTE IN ACC
,,,        ;
158B,8A A0,TBR,TBR:    MOV     P2,R2           ;OUTPUT DESTINATION TO PORT
158D,F2,,        MOVX    @R0,A           ;SAVE THE BYTE
158E,22,,        RET                     ;EXIT
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ;NMOV - R7:R6 = END ADDRESS - DPTR
,,,        ;
,,,        ;ACC GETS CLOBBERED
,,,        ;
,,,        ;***************************************************************
,,,        ;
158F,EC,NMOV,NMOV:   MOV     A,R4            ;THE LOW BYTE OF EOFA
1590,C3,,        CLR     C               ;CLEAR THE CARRY FOR SUBB
1591,95 82,,        SUBB    A,DPL           ;SUBTRACT DATA POINTER LOW
1593,FE,,        MOV     R6,A            ;PUT RESULT IN R6
1594,ED,,        MOV     A,R5            ;HIGH BYTE OF EOFA
1595,95 83,,        SUBB    A,DPH           ;SUBTRACT DATA POINTER HIGH
1597,FF,,        MOV     R7,A            ;PUT RESULT IN R7
1598,4E,,        ORL     A,R6            ;SEE IF ZERO
1599,22,,        RET                     ;EXIT
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,        ;CHECK FOR A FILE OVERFLOW
,,,        ;LEAVES THE NEW END ADDRESS IN R3:R1
,,,        ;A HAS THE INCREASE IN SIZE
,,,        ;
,,,        ;***************************************************************
,,,        ;
159A,2C,FULL,FULL:   ADD     A,R4            ;ADD A TO END ADDRESS
159B,F9,,        MOV     R1,A            ;SAVE IT
159C,E4,,        CLR     A
159D,3D,,        ADDC    A,R5            ;ADD THE CARRY
159E,FB,,        MOV     R3,A
159F,90 01 04,,        MOV     DPTR,#VARTOP    ;POINT AT VARTOP
,,,        ;
15A2,12 05 C4,FUL1,FUL1:   CALL    DCMPX           ;COMPARE THE TWO
15A5,40 F2,,        JC      FULL-1          ;OUT OF ROOM
,,,        ;
15A7,90 18 17,TB,TB:     MOV     DPTR,#E5X       ;OUT OF MEMORY
15AA,01 37,,        AJMP    FPTS
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; PP - Preprocesses the line in IBUF back into IBUF
,,,        ;      sets F0 if no line number
,,,        ;      leaves the correct length of processed line in IBCNT
,,,        ;      puts the line number in IBLN
,,,        ;      wastes the text address TXAL and TXAH
,,,        ;
,,,        ;***************************************************************
,,,        ;
15AC,F1 6A,PP,PP:     ACALL   T_BUF           ;TXA GETS IBUF
15AE,12 0F 3E,,        CALL    INTGER          ;SEE IF A NUMBER PRESENT
15B1,12 18 55,,        CALL    TEMPD           ;SAVE THE INTEGER IN TEMP5:TEMP4
15B4,92 D5,,        MOV     F0,C            ;SAVE INTEGER IF PRESENT
15B6,90 00 05,,        MOV     DPTR,#IBLN      ;SAVE THE LINE NUMBER, EVEN IF NONE
15B9,91 16,,        ACALL   S20DP
15BB,A8 08,,        MOV     R0,TXAL         ;TEXT POINTER
15BD,79 07,,        MOV     R1,#LOW IBUF    ;STORE POINTER
,,,        ;
,,,        ; Now process the line back into IBUF
,,,        ;
15BF,C2 24,PPL,PPL:    CLR     ARGF            ;FIRST PASS DESIGNATOR
15C1,90 01 73,,        MOV     DPTR,#TOKTAB    ;POINT DPTR AT LOOK UP TABLE
,,,        ;
15C4,88 05,PPL1,PPL1:   MOV     R5B0,R0         ;SAVE THE READ POINTER
15C6,E4,,        CLR     A               ;ZERO A FOR LOOKUP
15C7,93,,        MOVC    A,@A+DPTR       ;GET THE TOKEN
15C8,FF,,        MOV     R7,A            ;SAVE TOKEN IN CASE OF MATCH
,,,        ;
15C9,E2,PPL2,PPL2:   MOVX    A,@R0           ;GET THE USER CHARACTER
15CA,FB,,        MOV     R3,A            ;SAVE FOR REM
15CB,B4 61 00,,        CJNE    A,#'a',$+3
15CE,40 07,,        JC      PPX             ;CONVERT LOWER TO UPPER CASE
15D0,B4 7B 00,,        CJNE    A,#('z'+1),$+3
15D3,50 02,,        JNC     PPX
15D5,C2 E5,,        CLR     ACC.5
,,,        ;
15D7,FA,PPX,PPX:    MOV     R2,A
15D8,F2,,        MOVX    @R0,A           ;SAVE UPPER CASE
15D9,A3,,        INC     DPTR            ;BUMP THE LOOKUP POINTER
15DA,E4,,        CLR     A
15DB,93,,        MOVC    A,@A+DPTR
15DC,B5 02 03,,        CJNE    A,R2B0,PPL3     ;LEAVE IF NOT THE SAME
15DF,08,,        INC     R0              ;BUMP THE USER POINTER
15E0,80 E7,,        SJMP    PPL2            ;CONTINUE TO LOOP
,,,        ;
15E2,20 E7 2F,PPL3,PPL3:   JB      ACC.7,PPL6      ;JUMP IF FOUND MATCH
15E5,60 2D,,        JZ      PPL6            ;USER MATCH
,,,        ;
,,,        ;
,,,        ; Scan to the next TOKTAB entry
,,,        ;
15E7,A3,PPL4,PPL4:   INC     DPTR            ;ADVANCE THE POINTER
15E8,E4,,        CLR     A               ;ZERO A FOR LOOKUP
15E9,93,,        MOVC    A,@A+DPTR       ;LOAD A WITH TABLE
15EA,20 E7 03,,        JB      ACC.7,$+6       ;KEEP SCANNING IF NOT A RESERVED WORD
15ED,70 F8,,        JNZ     PPL4
15EF,A3,,        INC     DPTR
,,,        ;
,,,        ; See if at the end of TOKTAB
,,,        ;
15F0,A8 05,,        MOV     R0,R5B0         ;RESTORE THE POINTER
15F2,B4 FF CF,,        CJNE    A,#0FFH,PPL1    ;SEE IF END OF TABLE
,,,        ;
,,,        ; Character not in TOKTAB, so see what it is
,,,        ;
15F5,BA 20 03,,        CJNE    R2,#' ',PPLX    ;SEE IF A SPACE
15F8,08,,        INC     R0              ;BUMP USER POINTER
15F9,80 C4,,        SJMP    PPL             ;TRY AGAIN
,,,        ;
15FB,30 2D 0A,PPLX,PPLX:   JNB     XBIT,PPLY       ;EXTERNAL TRAP
15FE,20 24 07,,        JB      ARGF,PPLY
1601,D2 24,,        SETB    ARGF            ;SAYS THAT THE USER HAS TABLE
1603,12 20 78,,        LCALL   2078H           ;SET UP POINTER
1606,A1 C4,,        AJMP    PPL1
,,,        ;
1608,D1 21,PPLY,PPLY:   ACALL   PPL7            ;SAVE CHARACTER, EXIT IF A CR
160A,B4 22 B2,,        CJNE    A,#'"',PPL      ;SEE IF QUOTED STRING, START AGAIN IF NOT
,,,        ;
,,,        ; Just copy a quoted string
,,,        ;
160D,D1 21,,        ACALL   PPL7            ;SAVE THE CHARACTER, TEST FOR CR
160F,B4 22 FB,,        CJNE    A,#'"',$-2      ;IS THERE AN ENDQUOTE, IF NOT LOOP
1612,80 AB,,        SJMP    PPL             ;DO IT AGAIN IF ENDQUOTE
,,,        ;
1614,EF,PPL6,PPL6:   MOV     A,R7            ;GET THE TOKEN
1615,D1 36,,        ACALL   PPL9+1          ;SAVE THE TOKEN
1617,B4 96 A5,,        CJNE    A,#T_REM,PPL    ;SEE IF A REM TOKEN
161A,EB,,        MOV     A,R3
161B,D1 22,,        ACALL   PPL7+1          ;WASTE THE REM STATEMENT
161D,D1 21,,        ACALL   PPL7            ;LOOP UNTIL A CR
161F,80 FC,,        SJMP    $-2
,,,        ;
1621,E2,PPL7,PPL7:   MOVX    A,@R0           ;GET THE CHARACTER
1622,B4 0D 10,,        CJNE    A,#CR,PPL9      ;FINISH IF A CR
1625,D0 00,,        POP     R0B0            ;WASTE THE CALLING STACK
1627,D0 00,,        POP     R0B0
1629,F3,,        MOVX    @R1,A           ;SAVE CR IN MEMORY
162A,09,,        INC     R1              ;SAVE A TERMINATOR
162B,74 01,,        MOV     A,#EOF
162D,F3,,        MOVX    @R1,A
162E,E9,,        MOV     A,R1            ;SUBTRACT FOR LENGTH
162F,94 04,,        SUBB    A,#4
1631,F5 0D,,        MOV     TEMP3,A         ;SAVE LENGTH
1633,79 04,,        MOV     R1,#LOW IBCNT   ;POINT AT BUFFER COUNT
,,,        ;
1635,08,PPL9,PPL9:   INC     R0
1636,F3,,        MOVX    @R1,A           ;SAVE THE CHARACTER
1637,09,,        INC     R1              ;BUMP THE POINTERS
1638,22,,        RET                     ;EXIT TO CALLING ROUTINE
,,,        ;
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,        ;DEC76 - DECREMENT THE REGISTER PAIR R7:R6
,,,        ;
,,,        ;ACC = ZERO IF R7:R6 = ZERO ; ELSE ACC DOES NOT
,,,        ;
,,,        ;***************************************************************
,,,        ;
1639,1E,DEC76,DEC76:  DEC     R6              ;BUMP R6
163A,BE FF 01,,        CJNE    R6,#0FFH,$+4    ;SEE IF RAPPED AROUND
163D,1F,,        DEC     R7
163E,EF,,        MOV     A,R7            ;SEE IF ZERO
163F,4E,,        ORL     A,R6
1640,22,,        RET                     ;EXIT
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,        ; MTOP - Get or Put the top of assigned memory
,,,        ;
,,,        ;***************************************************************
,,,        ;
1641,90 01 0A,PMTOP,PMTOP:  MOV     DPTR,#MEMTOP
1644,12 05 6B,,        CALL    L20DPI
1647,81 A6,,        AJMP    TWO_EY          ;PUT R2:R0 ON THE STACK
,,,        ;
,,,$EJECT
,,,        ;*************************************************************
,,,        ;
,,,        ; AXTAL - Crystal value calculations
,,,        ;
,,,        ;*************************************************************
,,,        ;
1649,90 17 E7,AXTAL0,AXTAL0: MOV     DPTR,#XTALV     ;CRYSTAL VALUE
164C,91 25,,        ACALL   PUSHC
,,,        ;
164E,91 1C,AXTAL1,AXTAL1: ACALL   CSTAKA2         ;COPY CRYSTAL VALUE TWICE
1650,91 1E,,        ACALL   CSTAKA
1652,90 07 01,,        MOV     DPTR,#PTIME     ;PROM TIMER
1655,D1 77,,        ACALL   AXTAL2
1657,90 01 28,,        MOV     DPTR,#PROGS
165A,F1 0C,,        ACALL   S31L
165C,90 17 F9,,        MOV     DPTR,#IPTIME    ;IPROM TIMER
165F,D1 77,,        ACALL   AXTAL2
1661,90 01 2A,,        MOV     DPTR,#IPROGS
1664,F1 0C,,        ACALL   S31L
1666,90 11 59,,        MOV     DPTR,#TTIME     ;CLOCK CALCULATION
1669,51 11,,        ACALL   AXTAL3
166B,E9,,        MOV     A,R1
166C,F4,,        CPL     A
166D,04,,        INC     A
166E,F5 4A,,        MOV     SAVE_T,A
1670,7B 01,,        MOV     R3,#HIGH CXTAL
1672,79 13,,        MOV     R1,#LOW CXTAL
1674,02 0F DC,,        JMP     POPAS
,,,        ;
1677,51 11,AXTAL2,AXTAL2: ACALL   AXTAL3
,,,        ;
1679,,CBIAS,CBIAS:  ;Bias the crystal calculations
,,,        ;
1679,E9,,        MOV     A,R1            ;GET THE LOW COUNT
167A,F4,,        CPL     A               ;FLIP IT FOR TIMER LOAD
167B,24 0F,,        ADD     A,#15           ;BIAS FOR CALL AND LOAD TIMES
167D,F9,,        MOV     R1,A            ;RESTORE IT
167E,EB,,        MOV     A,R3            ;GET THE HIGH COUNT
167F,F4,,        CPL     A               ;FLIP IT
1680,34 00,,        ADDC    A,#00H          ;ADD THE CARRY
1682,FB,,        MOV     R3,A            ;RESTORE IT
1683,22,,        RET
,,,        ;
,,,$EJECT
,,,;$INCLUDE(:F2:BAS52.PWM)
,,,;BEGINNING
,,,        ;**************************************************************
,,,        ;
1684,,STONE,STONE:  ; Toggle the I/O port
,,,        ;
,,,        ;**************************************************************
,,,        ;
1684,12 0E 81,,        CALL    THREE           ;GET THE NUMBERS
1687,D1 79,,        ACALL   CBIAS           ;BIAS R3:R1 FOR COUNT LOOP
,,,        ;
1689,C2 92,STONE1,STONE1: CLR     T_BIT           ;TOGGLE THE BIT
168B,C2 8E,,        CLR     TR1             ;STOP THE TIMER
168D,8B 8D,,        MOV     TH1,R3          ;LOAD THE TIMER
168F,89 8B,,        MOV     TL1,R1
1691,C2 8F,,        CLR     TF1             ;CLEAR THE OVERFLOW FLAG
1693,D2 8E,,        SETB    TR1             ;TURN IT ON
1695,D1 39,,        ACALL   DEC76
1697,30 8F FD,,        JNB     TF1,$           ;WAIT
169A,71 9E,,        ACALL   ALPAR
169C,D2 92,,        SETB    T_BIT           ;BACK TO A ONE
169E,12 05 29,,        CALL    TIMER_LOAD+2    ;LOAD THE HIGH VALUE
16A1,30 8F FD,,        JNB     TF1,$           ;WAIT
16A4,70 E3,,        JNZ     STONE1          ;LOOP
16A6,22,,        RET
,,,        ;
,,,
,,,;END
,,,;$INCLUDE(:F2:BAS52.PWM)
,,,$EJECT
,,,        ;LNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLN
,,,        ;
16A7,,LNTAB,LNTAB:  ; Natural log lookup table
,,,        ;
,,,        ;LNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLN
,,,        ;
16A7,80,,        DB      80H
16A8,00,,        DB      00H
16A9,71,,        DB      71H
16AA,37,,        DB      37H
16AB,13,,        DB      13H
16AC,19,,        DB      19H
,,,        ;
16AD,7F,,        DB      7FH
16AE,00,,        DB      00H
16AF,76,,        DB      76H
16B0,64,,        DB      64H
16B1,37,,        DB      37H
16B2,94,,        DB      94H
,,,        ;
16B3,80,,        DB      80H
16B4,00,,        DB      00H
16B5,07,,        DB      07H
16B6,22,,        DB      22H
16B7,75,,        DB      75H
16B8,17,,        DB      17H
,,,        ;
16B9,80,,        DB      80H
16BA,00,,        DB      00H
16BB,52,,        DB      52H
16BC,35,,        DB      35H
16BD,93,,        DB      93H
16BE,28,,        DB      28H
,,,        ;
16BF,80,,        DB      80H
16C0,00,,        DB      00H
16C1,71,,        DB      71H
16C2,91,,        DB      91H
16C3,85,,        DB      85H
16C4,86,,        DB      86H
,,,        ;
16C5,FF,,        DB      0FFH
,,,        ;
16C6,81,,        DB      81H
16C7,00,,        DB      00H
16C8,51,,        DB      51H
16C9,58,,        DB      58H
16CA,02,,        DB      02H
16CB,23,,        DB      23H
,,,        ;
,,,$EJECT
,,,        ;SINSINSINSINSINSINSINSINSINSINSINSINSINSINSINSINSIN
,,,        ;
16CC,,SINTAB,SINTAB: ; Sin lookup table
,,,        ;
,,,        ;SINSINSINSINSINSINSINSINSINSINSINSINSINSINSINSINSIN
,,,        ;
16CC,77,,        DB      128-9
16CD,00,,        DB      00H
16CE,44,,        DB      44H
16CF,90,,        DB      90H
16D0,05,,        DB      05H
16D1,16,,        DB      16H
,,,        ;
16D2,79,,        DB      128-7
16D3,01,,        DB      01H
16D4,08,,        DB      08H
16D5,21,,        DB      21H
16D6,05,,        DB      05H
16D7,25,,        DB      25H
,,,        ;
16D8,7B,,        DB      128-5
16D9,00,,        DB      00H
16DA,19,,        DB      19H
16DB,73,,        DB      73H
16DC,55,,        DB      55H
16DD,27,,        DB      27H
,,,        ;
,,,$EJECT
,,,        ;
16DE,7D,,        DB      128-3
16DF,01,,        DB      01H
16E0,70,,        DB      70H
16E1,12,,        DB      12H
16E2,84,,        DB      84H
16E3,19,,        DB      19H
,,,        ;
16E4,7E,,        DB      128-2
16E5,00,,        DB      00H
16E6,33,,        DB      33H
16E7,33,,        DB      33H
16E8,33,,        DB      33H
16E9,83,,        DB      83H
,,,        ;
16EA,80,,        DB      128
16EB,01,,        DB      01H
16EC,67,,        DB      67H
16ED,66,,        DB      66H
16EE,66,,        DB      66H
16EF,16,,        DB      16H
,,,        ;
16F0,81,FPONE,FPONE:  DB      128+1
16F1,00,,        DB      00H
16F2,00,,        DB      00H
16F3,00,,        DB      00H
16F4,00,,        DB      00H
16F5,10,,        DB      10H
,,,        ;
16F6,FF,,        DB      0FFH            ;END OF TABLE
,,,        ;
,,,$EJECT
,,,        ;
16F7,12 0F E2,SBAUD,SBAUD:  CALL    AXTAL           ;PUT CRYSTAL ON THE STACK
16FA,12 0F 4C,,        CALL    EXPRB           ;PUT THE NUMBER AFTER BAUD ON STACK
16FD,74 0C,,        MOV     A,#12
16FF,91 A3,,        ACALL   TWO_R2          ;TOS = 12
1701,31 A2,,        ACALL   AMUL            ;TOS = 12*BAUD
1703,71 FC,,        ACALL   ADIV            ;TOS = XTAL/(12*BAUD)
1705,51 15,,        ACALL   IFIX
1707,D1 79,,        ACALL   CBIAS
1709,90 01 24,,        MOV     DPTR,#SPV
,,,        ;
170C,02 05 FD,S31L,S31L:   JMP     S31DP
,,,        ;
170F,D1 41,AFREE,AFREE:  CALL    PMTOP           ;PUT MTOP ON STACK
1711,12 05 A1,,        CALL    G4              ;GET END ADDRESS
1714,A8 82,,        MOV     R0,DPL
1716,AA 83,,        MOV     R2,DPH
1718,91 A6,,        ACALL   TWO_EY
,,,        ;
171A,12 19 95,ASUB,ASUB:   LCALL   FP_BASE+2       ;DO FP SUB
171D,01 24,,        AJMP    FPTST
,,,        ;
171F,12 05 16,ALEN,ALEN:   CALL    CCAL            ;CALCULATE THE LEN OF THE SELECTED PROGRAM
1722,AA 07,,        MOV     R2,R7B0         ;SAVE THE HIGH BYTE
1724,EE,,        MOV     A,R6            ;SAVE THE LOW BYTE
1725,81 A5,,        AJMP    TWO_EX          ;PUT IT ON THE STACK
,,,        ;
1727,A2 AF,ATIME,ATIME:  MOV     C,EA            ;SAVE INTERRUTS
1729,C2 AF,,        CLR     EA
172B,C0 47,,        PUSH    MILLIV          ;SAVE MILLI VALUE
172D,AA 48,,        MOV     R2,TVH          ;GET THE TIMER
172F,E5 49,,        MOV     A,TVL
1731,92 AF,,        MOV     EA,C            ;SAVE INTERRUPTS
1733,91 A5,,        ACALL   TWO_EX          ;PUT TIMER ON THE STACK
1735,D0 E0,,        POP     ACC             ;GET MILLI
1737,91 A3,,        ACALL   TWO_R2          ;PUT MILLI ON STACK
1739,74 C8,,        MOV     A,#200
173B,91 A3,,        ACALL   TWO_R2          ;DIVIDE MILLI BY 200
173D,71 FC,,        ACALL   ADIV
,,,        ;
173F,12 19 93,AADD,AADD:   LCALL   FP_BASE         ;DO FP ADDITION
1742,01 24,,        AJMP    FPTST           ;CHECK FOR ERRORS
,,,        ;
,,,$EJECT
,,,        ;**************************************************************
,,,        ;
,,,        ; Here are some error messages that were moved
,,,        ;
,,,        ;**************************************************************
,,,        ;
,,,        ;
1744,42 41 44 20,E1X,E1X:    DB      'BAD SYNTAX"'
174F,8A,E2X,E2X:    DB      128+10
1750,44 49 56 49,,        DB      'DIVIDE BY ZERO"'
,,,        ;
175F,41 52 52 41,E6X,E6X:    DB      'ARRAY SIZE"'
,,,        ;
,,,$EJECT
,,,        ;**************************************************************
,,,        ;
176A,,T_BUF,T_BUF:  ; TXA gets IBUF
,,,        ;
,,,        ;**************************************************************
,,,        ;
176A,75 0A 00,,        MOV     TXAH,#HIGH IBUF
176D,75 08 07,,        MOV     TXAL,#LOW IBUF
1770,22,,        RET
,,,        ;
,,,        ;
,,,        ;***************************************************************
,,,        ;
1771,,CXFER,CXFER:  ; Transfer a program from rom to ram
,,,        ;
,,,        ;***************************************************************
,,,        ;
1771,12 05 16,,        CALL    CCAL            ;GET EVERYTHING SET UP
1774,7A 02,,        MOV     R2,#HIGH PSTART
1776,78 00,,        MOV     R0,#LOW PSTART
1778,B1 5F,,        ACALL   LMOV            ;DO THE TRANSFER
177A,12 06 5C,,        CALL    RCLEAR          ;CLEAR THE MEMORY
,,,        ;
,,,        ; Fall thru to CRAM
,,,        ;
,,,        ;***************************************************************
,,,        ;
177D,,CRAM,CRAM:   ; The command action routine - RAM - Run out of ram
,,,        ;
,,,        ;***************************************************************
,,,        ;
177D,C2 17,,        CLR     CONB            ;CAN'T CONTINUE IF MODE CHANGE
177F,75 13 02,,        MOV     BOFAH,#HIGH PSTART
1782,75 14 00,,        MOV     BOFAL,#LOW PSTART
,,,        ;
,,,        ; Fall thru to Command Processor
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
1785,,CMND1,CMND1:  ; The entry point for the command processor
,,,        ;
,,,        ;***************************************************************
,,,        ;
1785,12 0C 39,,        LCALL   SPRINT+4        ;WASTE AT AND HEX
1788,C2 2D,,        CLR     XBIT            ;TO RESET IF NEEDED
178A,E4,,        CLR     A
178B,90 20 02,,        MOV     DPTR,#2002H     ;CHECK FOR EXTERNAL TRAP PACKAGE
178E,93,,        MOVC    A,@A+DPTR
178F,B4 5A 03,,        CJNE    A,#5AH,$+6
1792,12 20 48,,        LCALL   2048H           ;IF PRESENT JUMP TO LOCATION 200BH
1795,90 00 FB,,        MOV     DPTR,#RDYS      ;PRINT THE READY MESSAGE
1798,12 06 A5,,        CALL    CRP             ;DO A CR, THEN, PRINT FROM THE ROM
,,,        ;
179B,D2 2F,CMNDR,CMNDR:  SETB    DIRF            ;SET THE DIRECT INPUT BIT
179D,85 3E 81,,        MOV     SP,SPSAV        ;LOAD THE STACK
17A0,11 89,,        ACALL   CL7             ;DO A CRLF
,,,        ;
17A2,C2 18,CMNX,CMNX:   CLR     GTRD            ;CLEAR BREAK
17A4,90 00 5E,,        MOV     DPTR,#5EH       ;DO RUN TRAP
17A7,E0,,        MOVX    A,@DPTR
17A8,64 34,,        XRL     A,#52
17AA,70 03,,        JNZ     $+5
17AC,02 08 06,,        LJMP    CRUN
17AF,7D 3E,,        MOV     R5,#'>'         ;OUTPUT A PROMPT
17B1,12 07 09,,        LCALL   TEROT
17B4,12 06 D0,,        CALL    INLINE          ;INPUT A LINE INTO IBUF
17B7,B1 AC,,        CALL    PP              ;PRE-PROCESS THE LINE
17B9,20 D5 0F,,        JB      F0,CMND3        ;NO LINE NUMBER
17BC,91 E2,,        CALL    LINE            ;PROCESS THE LINE
17BE,12 05 DF,,        LCALL   LCLR
17C1,20 15 DE,,        JB      LINEB,CMNX      ;DON'T CLEAR MEMORY IF NO NEED
17C4,D2 15,,        SETB    LINEB
17C6,12 06 5C,,        LCALL   RCLEAR          ;CLEAR THE MEMORY
17C9,80 D7,,        SJMP    CMNX            ;LOOP BACK
,,,        ;
17CB,F1 6A,CMND3,CMND3:  CALL    T_BUF           ;SET UP THE TEXT POINTER
17CD,12 0E EA,,        CALL    DELTST          ;GET THE CHARACTER
17D0,60 C9,,        JZ      CMNDR           ;IF CR, EXIT
17D2,90 01 0D,,        MOV     DPTR,#CMNDD     ;POINT AT THE COMMAND LOOKUP
17D5,B4 F0 00,,        CJNE    A,#T_CMND,$+3   ;PROCESS STATEMENT IF NOT A COMMAND
17D8,40 0A,,        JC      CMND5
17DA,12 0E E0,,        CALL    GCI1            ;BUMP TXA
17DD,54 0F,,        ANL     A,#0FH          ;STRIP MSB'S FOR LOOKUP
17DF,12 09 64,,        LCALL   ISTA1           ;PROCESS COMMAND
17E2,80 B7,,        SJMP    CMNDR
,,,        ;
17E4,02 08 17,CMND5,CMND5:  LJMP    ILOOP           ;CHECK FOR A POSSIBLE BREAK
,,,        ;
,,,        ;
,,,        ;
,,,        ;CONSTANTS
,,,        ;
17E7,88,XTALV,XTALV:  DB      128+8           ; DEFAULT CRYSTAL VALUE
17E8,00,,        DB      00H
17E9,00,,        DB      00H
17EA,92,,        DB      92H
17EB,05,,        DB      05H
17EC,11,,        DB      11H
,,,        ;
17ED,85,EXP11,EXP11:  DB      85H
17EE,00,,        DB      00H
17EF,42,,        DB      42H
17F0,41,,        DB      41H
17F1,87,,        DB      87H
17F2,59,,        DB      59H
,,,        ;
17F3,81,EXP1,EXP1:   DB      128+1           ; EXP(1)
17F4,00,,        DB      00H
17F5,18,,        DB      18H
17F6,28,,        DB      28H
17F7,18,,        DB      18H
17F8,27,,        DB      27H
,,,        ;
17F9,7C,IPTIME,IPTIME: DB      128-4           ;FPROG TIMING
17FA,00,,        DB      00H
17FB,00,,        DB      00H
17FC,00,,        DB      00H
17FD,75,,        DB      75H
17FE,83,,        DB      83H
,,,        ;
17FF,81,PIE,PIE:    DB      128+1           ;PI
1800,00,,        DB      00H
1801,26,,        DB      26H
1802,59,,        DB      59H
1803,41,,        DB      41H
1804,31,,        DB      31H             ; 3.1415926
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; The error messages, some have been moved
,,,        ;
,,,        ;***************************************************************
,,,        ;
1805,9E,E7X,E7X:    DB      128+30
1806,41 52 49 54,,        DB      'ARITH. UNDERFLOW"'
,,,        ;
1817,4D 45 4D 4F,E5X,E5X:    DB      'MEMORY ALLOCATION"'
,,,        ;
1829,A8,E3X,E3X:    DB      128+40
182A,42 41 44 20,,        DB      'BAD ARGUMENT"'
,,,        ;
1837,49 2D 53 54,EXI,EXI:    DB      'I-STACK"'
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        ; The command action routine - CONTINUE
,,,        ;
,,,        ;***************************************************************
,,,        ;
183F,90 1F A6,CCONT,CCONT:  MOV     DPTR,#E15X
1842,30 17 4B,,        JNB     CONB,ERROR      ;ERROR IF CONTINUE IS NOT SET
,,,        ;
1845,,CC1,CC1:    ;used for input statement entry
,,,        ;
1845,85 42 0A,,        MOV     TXAH,INTXAH     ;RESTORE TXA
1848,85 43 08,,        MOV     TXAL,INTXAL
184B,02 08 13,,        JMP     CILOOP          ;EXECUTE
,,,        ;
184E,85 0F 83,DTEMP,DTEMP:  MOV     DPH,TEMP5       ;RESTORE DPTR
1851,85 0E 82,,        MOV     DPL,TEMP4
1854,22,,        RET
,,,        ;
1855,85 83 0F,TEMPD,TEMPD:  MOV     TEMP5,DPH
1858,85 82 0E,,        MOV     TEMP4,DPL
185B,22,,        RET
,,,        ;
,,,$EJECT
,,,        ;**************************************************************
,,,        ;
185C,,I_DL,I_DL:   ; IDLE
,,,        ;
,,,        ;**************************************************************
,,,        ;
185C,20 2F 27,,        JB      DIRF,E1XX       ;SYNTAX ERROR IN DIRECT INPUT
185F,C2 96,,        CLR     DACK            ;ACK IDLE
,,,        ;
1861,43,U_ID1,U_ID1:  DB      01000011B       ;ORL DIRECT OP CODE
1862,87,,        DB      87H             ;PCON ADDRESS
1863,01,,        DB      01H             ;SET IDLE BIT
1864,20 16 0B,,        JB      INTPEN,I_RET    ;EXIT IF EXTERNAL INTERRUPT
1867,10 21 08,,        JBC     U_IDL,I_RET     ;EXIT IF USER WANTS TO
186A,30 10 F4,,        JNB     OTS,U_ID1       ;LOOP IF TIMER NOT ENABLED
186D,12 07 E7,,        LCALL   T_CMP           ;CHECK THE TIMER
1870,40 EF,,        JC      U_ID1           ;LOOP IF TIME NOT BIG ENOUGH
,,,        ;
1872,D2 96,I_RET,I_RET:  SETB    DACK            ;RESTORE EXECUTION
1874,22,,        RET                     ;EXIT IF IT IS
,,,        ;
,,,        ;
,,,        ;
1875,A3,ER0,ER0:    INC     DPTR            ;BUMP TO TEXT
1876,20 2F 23,,        JB      DIRF,ERROR0     ;CAN'T GET OUT OF DIRECT MODE
1879,30 13 20,,        JNB     ON_ERR,ERROR0   ;IF ON ERROR ISN'T SET, GO BACK
187C,90 01 01,,        MOV     DPTR,#ERRLOC    ;SAVE THE ERROR CODE
187F,12 06 6B,,        CALL    RC2             ;SAVE ERROR AND SET UP THE STACKS
1882,A3,,        INC     DPTR            ;POINT AT ERRNUM
1883,02 08 48,,        JMP     ERL4            ;LOAD ERR NUM AND EXIT
,,,        ;
,,,$EJECT
,,,        ;
,,,        ; Syntax error
,,,        ;
1886,A2 2F,E1XX,E1XX:   MOV     C,DIRF          ;SEE IF IN DIRECT MODE
1888,90 17 44,,        MOV     DPTR,#E1X       ;ERROR MESSAGE
188B,80 04,,        SJMP    ERROR+1         ;TRAP ON SET DIRF
,,,        ;
188D,90 18 37,,        MOV     DPTR,#EXI       ;STACK ERROR
,,,        ;
,,,        ; Falls through
,,,        ;
,,,        ;***************************************************************
,,,        ;
,,,        ;ERROR PROCESSOR - PRINT OUT THE ERROR TYPE, CHECK TO SEE IF IN
,,,        ;                  RUN OR COMMAND MODE, FIND AND PRINT OUT THE
,,,        ;                  LINE NUMBER IF IN RUN MODE
,,,        ;
,,,        ;***************************************************************
,,,        ;
1890,C3,ERROR,ERROR:  CLR     C               ;RESET STACK
1891,85 3E 81,,        MOV     SP,SPSAV        ;RESET THE STACK
1894,12 0C 39,,        LCALL   SPRINT+4        ;CLEAR LINE AND AT MODE
1897,E4,,        CLR     A               ;SET UP TO GET ERROR CODE
1898,93,,        MOVC    A,@A+DPTR
1899,10 E7 D9,,        JBC     ACC.7,ER0       ;PROCESS ERROR
,,,        ;
189C,11 55,ERROR0,ERROR0: ACALL   TEMPD           ;SAVE THE DATA POINTER
189E,40 03,,        JC      $+5             ;NO RESET IF CARRY IS SET
18A0,12 06 67,,        LCALL   RC1             ;RESET THE STACKS
18A3,12 06 9B,,        CALL    CRLF2           ;DO TWO CARRIAGE RET - LINE FEED
18A6,90 1F F8,,        MOV     DPTR,#ERS       ;OUTPUT ERROR MESSAGE
18A9,12 06 A7,,        CALL    ROM_P
18AC,11 4E,,        CALL    DTEMP           ;GET THE ERROR MESSAGE BACK
,,,        ;
18AE,12 06 A7,ERRS,ERRS:   CALL    ROM_P           ;PRINT ERROR TYPE
18B1,30 2F 05,,        JNB     DIRF,ER1        ;DO NOT PRINT IN LINE IF DIRF=1
,,,        ;
18B4,C2 20,SERR1,SERR1:  CLR     STOPBIT         ;PRINT STOP THEN EXIT, FOR LIST
18B6,02 17 85,,        JMP     CMND1
,,,        ;
18B9,90 01 01,ER1,ER1:    MOV     DPTR,#INS       ;OUTPUT IN LINE
18BC,12 06 A7,,        CALL    ROM_P
,,,        ;
,,,        ;NOW, FIND THE LINE NUMBER
,,,        ;
,,,        ;
,,,$EJECT
,,,        ;
,,,        ;
18BF,12 0E A4,,        CALL    DP_B            ;GET THE FIRST ADDRESS OF THE PROGRAM
18C2,E4,,        CLR     A               ;FOR INITIALIZATION
,,,        ;
18C3,11 55,ER2,ER2:    ACALL   TEMPD           ;SAVE THE DPTR
18C5,12 05 D6,,        CALL    ADDPTR          ;ADD ACC TO DPTR
18C8,11 FC,,        ACALL   ER4             ;R3:R1 = TXA-DPTR
18CA,40 06,, JC     ER3             ;EXIT IF DPTR>TXA
18CC,60 04,,        JZ      ER3             ;EXIT IF DPTR=TXA
18CE,E0,,        MOVX    A,@DPTR         ;GET LENGTH
18CF,B4 01 F1,,        CJNE    A,#EOF,ER2      ;SEE IF AT THE END
,,,        ;
18D2,11 4E,ER3,ER3:    ACALL   DTEMP           ;PUT THE LINE IN THE DPTR
18D4,11 FC,,        ACALL   ER4             ;R3:R1 = TXA - BEGINNING OF LINE
18D6,E9,,        MOV     A,R1            ;GET LENGTH
18D7,24 0A,,        ADD     A,#10           ;ADD 10 TO LENGTH, DPTR STILL HAS ADR
18D9,F5 45,,        MOV     MT1,A           ;SAVE THE COUNT
18DB,A3,,        INC     DPTR            ;POINT AT LINE NUMBER HIGH BYTE
18DC,12 16 44,,        CALL    PMTOP+3         ;LOAD R2:R0, PUT IT ON THE STACK
18DF,31 A1,,        ACALL   FP_BASE+14      ;OUTPUT IT
18E1,20 20 D0,,        JB      STOPBIT,SERR1   ;EXIT IF STOP BIT SET
18E4,12 06 9B,,        CALL    CRLF2           ;DO SOME CRLF'S
18E7,11 4E,,        CALL    DTEMP
18E9,12 10 8F,,        CALL    UPPL            ;UNPROCESS THE LINE
18EC,12 10 80,,        CALL    CL6             ;PRINT IT
18EF,7D 2D,,        MOV     R5,#'-'         ;OUTPUT DASHES, THEN AN X
18F1,31 90,,        ACALL   T_L             ;PRINT AN X IF ERROR CHARACTER FOUND
18F3,D5 45 F9,,        DJNZ    MT1,$-4         ;LOOP UNTIL DONE
18F6,7D 58,,        MOV     R5,#'X'
18F8,31 90,,        ACALL   T_L
18FA,01 B4,,        AJMP    SERR1
,,,        ;
18FC,AB 0A,ER4,ER4:    MOV     R3,TXAH         ;GET TEXT POINTER AND PERFORM SUBTRACTION
18FE,A9 08,,        MOV     R1,TXAL
1900,02 0A 0A,,        JMP     DUBSUB
,,,        ;
,,,$EJECT
,,,        ;**************************************************************
,,,        ;
,,,        ; Interrupt driven timer
,,,        ;
,,,        ;**************************************************************
,,,        ;
1903,85 4A 8C,I_DR,I_DR:   MOV     TH0,SAVE_T      ;LOAD THE TIMER
1906,C5 47,,        XCH     A,MILLIV        ;SAVE A, GET MILLI COUNTER
1908,04,,        INC     A               ;BUMP COUNTER
1909,B4 C8 08,,        CJNE    A,#200,TR       ;CHECK OUT TIMER VALUE
190C,E4,,        CLR     A               ;FORCE ACC TO BE ZERO
190D,05 49,,        INC     TVL             ;INCREMENT LOW TIMER
190F,B5 49 02,,        CJNE    A,TVL,TR        ;CHECK LOW VALUE
1912,05 48,,        INC     TVH             ;BUMP TIMER HIGH
,,,        ;
1914,C5 47,TR,TR:     XCH     A,MILLIV
1916,D0 D0,,        POP     PSW
1918,32,,        RETI
,,,        ;
,,,$EJECT
,,,;$INCLUDE(:F2:BAS52.CLK)
,,,;BEGINNING
,,,        ;**************************************************************
,,,        ;
,,,        ; The statement action routine - CLOCK
,,,        ;
,,,        ;**************************************************************
,,,        ;
1919,31 36,SCLOCK,SCLOCK: ACALL   OTST            ;GET CHARACTER AFTER CLOCK TOKEN
191B,C2 A9,,        CLR     ET0
191D,C2 2E,,        CLR     C_BIT
191F,50 0A,,        JNC     SC_R            ;EXIT IF A ZERO
1921,53 89 F0,,        ANL     TMOD,#0F0H      ;SET UP THE MODE
1924,D2 2E,,        SETB    C_BIT           ;USER INTERRUPTS
1926,43 A8 82,,        ORL     IE,#82H         ;ENABLE ET0 AND EA
1929,D2 8C,,        SETB    TR0             ;TURN ON THE TIMER
,,,        ;
192B,22,SC_R,SC_R:   RET
,,,        ;
,,,
,,,;END
,,,;$INCLUDE(:F2:BAS52.CLK)
,,,        ;***************************************************************
,,,        ;
192C,,SUI,SUI:    ; Statement USER IN action routine
,,,        ;
,,,        ;***************************************************************
,,,        ;
192C,31 36,,        ACALL   OTST
192E,92 1E,,        MOV     CIUB,C          ;SET OR CLEAR CIUB
1930,22,,        RET
,,,        ;
,,,        ;***************************************************************
,,,        ;
1931,,SUO,SUO:    ; Statement USER OUT action routine
,,,        ;
,,,        ;***************************************************************
,,,        ;
1931,31 36,,        ACALL   OTST
1933,92 1C,,        MOV     COUB,C
1935,22,,        RET
,,,        ;
1936,,OTST,OTST:   ; Check for a one
,,,        ;
1936,12 0E DE,,        LCALL   GCI             ;GET THE CHARACTER, CLEARS CARRY
1939,94 31,,        SUBB    A,#'1'          ;SEE IF A ONE
193B,B3,,        CPL     C               ;SETS CARRY IF ONE, CLEARS IT IF ZERO
193C,22,,        RET
,,,        ;
,,,$EJECT
,,,        ;**************************************************************
,,,        ;
,,,        ; IBLK - EXECUTE USER SUPPLIED TOKEN
,,,        ;
,,,        ;**************************************************************
,,,        ;
193D,20 D4 FC,IBLK,IBLK:   JB      PSW.4,IBLK-1    ;EXIT IF REGISTER BANK <> 0
1940,20 D3 F9,,        JB      PSW.3,IBLK-1
1943,10 E7 06,,        JBC     ACC.7,$+9       ;SEE IF BIT SEVEN IS SET
1946,90 00 47,,        MOV     DPTR,#USENT     ;USER ENTRY LOCATION
1949,02 09 64,,        LJMP    ISTA1
,,,        ;
194C,20 E0 50,,        JB      ACC.0,199FH     ;FLOATING POINT INPUT
194F,60 3F,,        JZ      T_L             ;DO OUTPUT ON 80H
1951,90 19 91,,        MOV     DPTR,#FP_BASE-2
1954,73,,        JMP     @A+DPTR
,,,        ;
,,,        ;
,,,        ;**************************************************************
,,,        ;
,,,        ; GET_NUM - GET A NUMBER, EITHER HEX OR FLOAT
,,,        ;
,,,        ;**************************************************************
,,,        ;
1955,31 9D,GET_NUM,GET_NUM:ACALL   FP_BASE+10      ;SCAN FOR HEX
1957,50 46,,        JNC     FP_BASE+12      ;DO FP INPUT
,,,        ;
1959,31 A5,,        ACALL   FP_BASE+18      ;ASCII STRING TO R2:R0
195B,70 36,,        JNZ     H_RET
195D,C0 83,,        PUSH    DPH             ;SAVE THE DATA_POINTER
195F,C0 82,,        PUSH    DPL
1961,31 AB,,        ACALL   FP_BASE+24      ;PUT R2:R0 ON THE STACK
1963,D0 82,,        POP     DPL             ;RESTORE THE DATA_POINTER
1965,D0 83,,        POP     DPH
1967,E4,,        CLR     A               ;NO ERRORS
1968,22,,        RET                     ;EXIT
,,,        ;
,,,$EJECT
,,,        ;**************************************************************
,,,        ;
,,,        ; WB - THE EGO MESSAGE
,,,        ;
,,,        ;**************************************************************
,,,        ;
1969,D7 D2,WB,WB:     DB      'W'+80H,'R'+80H
196B,C9 D4 54 C5,,        DB      'I'+80H,'T'+80H,'T','E'+80H,'N'+80H
1970,20 C2 D9 20,,        DB      ' ','B'+80H,'Y'+80H,' '
1974,CA CF C8 CE,,        DB      'J'+80H,'O'+80H,'H'+80H,'N'+80H,' '+80H
1979,4B C1 D4 C1,,        DB      'K','A'+80H,'T'+80H,'A'+80H,'U'+80H
197E,53 CB D9,,        DB      'S','K'+80H,'Y'+80H
1981,2C 20 49 CE,,        DB      ', I','N'+80H,'T'+80H,'E'+80H,'L'+80H
1988,A0 C3 CF D2,,        DB      ' '+80H,'C'+80H,'O'+80H,'R'+80H,'P'+80H
198D,2E 20 31 B9,,        DB      '. 1','9'+80H,'85'
1993,22,H_RET,H_RET:  RET
,,,        ;
,,,$EJECT
,,,        ORG     1990H
,,,        ;
1990,02 07 09,T_L,T_L:    LJMP    TEROT
,,,        ;
,,,        ORG     1F78H
,,,        ;
1F78,20 1A 03,CKS_I,CKS_I:  JB      CKS_B,CS_I
1F7B,02 40 1B,,        LJMP    401BH
,,,        ;
1F7E,02 20 88,CS_I,CS_I:   LJMP    2088H
,,,        ;
1F81,4E 4F 20 44,E14X,E14X:   DB      'NO DATA"'
,,,        ;
1F89,94,E11X,E11X:   DB      128+20
1F8A,41 52 49 54,,        DB      'ARITH. OVERFLOW"'
,,,        ;
1F9A,50 52 4F 47,E16X,E16X:   DB      'PROGRAMMING"'
,,,        ;
1FA6,43 41 4E,E15X,E15X:   DB      'CAN'
1FA9,27,,        DB      27H
1FAA,54 20 43 4F,,        DB      'T CONTINUE"'
,,,        ;
1FB5,49 4E 56 41,E10X,E10X:   DB      'INVALID LINE NUMBER"'
,,,        ;
1FC9,50 52 4F 4D,NOROM,NOROM:  DB      'PROM MODE"'
,,,        ;
1FD3,2A 4D 43 53,S_N,S_N:    DB      '*MCS-51(tm) BASIC V1.1*"'
,,,        ;
,,,        ORG     1FF8H
,,,        ;
1FF8,45 52 52 4F,ERS,ERS:    DB      'ERROR: "'
,,,        ;
,,,$EJECT
,,,        ;***************************************************************
,,,        ;
,,,        XSEG    ;External Ram
,,,        ;
,,,        ;***************************************************************
,,,        ;
0000,,,        DS      4
0004,,IBCNT,IBCNT:  DS      1               ;LENGTH OF A LINE
0005,,IBLN,IBLN:   DS      2               ;THE LINE NUMBER
0007,,IBUF,IBUF:   DS      LINLEN          ;THE INPUT BUFFER
0050,,CONVT,CONVT:  DS      15              ;CONVERSION LOCATION FOR FPIN
,,,        ;
,,,        ORG     100H
,,,        ;
0100,,GTB,GTB:    DS      1               ;GET LOCATION
0101,,ERRLOC,ERRLOC: DS      1               ;ERROR TYPE
0102,,ERRNUM,ERRNUM: DS      2               ;WHERE TO GO ON AN ERROR
0104,,VARTOP,VARTOP: DS      2               ;TOP OF VARIABLE STORAGE
0106,,ST_ALL,ST_ALL: DS      2               ;STORAGE ALLOCATION
0108,,MT_ALL,MT_ALL: DS      2               ;MATRIX ALLOCATION
010A,,MEMTOP,MEMTOP: DS      2               ;TOP OF MEMORY
010C,,RCELL,RCELL:  DS      2               ;RANDOM NUMBER CELL
010E,,,        DS      FPSIZ-1
0113,,CXTAL,CXTAL:  DS      1               ;CRYSTAL
0114,,,        DS      FPSIZ-1
0119,,FPT1,FPT1:   DS      1               ;FLOATINP POINT TEMP 1
011A,,,        DS      FPSIZ-1
011F,,FPT2,FPT2:   DS      1               ;FLOATING POINT TEMP 2
0120,,INTLOC,INTLOC: DS      2               ;LOCATION TO GO TO ON INTERRUPT
0122,,STR_AL,STR_AL: DS      2               ;STRING ALLOCATION
0124,,SPV,SPV:    DS      2               ;SERIAL PORT BAUD RATE
0126,,TIV,TIV:    DS      2               ;TIMER INTERRUPT NUM AND LOC
0128,,PROGS,PROGS:  DS      2               ;PROGRAM A PROM TIME OUT
012A,,IPROGS,IPROGS: DS      2               ;INTELLIGENT PROM PROGRAMMER TIMEOUT
012C,,TM_TOP,TM_TOP: DS      1
,,,
000E,,,        END
