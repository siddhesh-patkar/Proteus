File BASIC11.ASM  þ By ASM11 v1.84b [Sunday, December 17, 2000  9:10 pm]

    1                           *
    2                           ;        OPT    NOL
    3                           *
    4      0001                 HC11     EQU  1
    5                           *
    6                           #Include  'DEFINES.Asm'
*** BEGIN INCLUDE FILE: DEFINES.ASM ***
    1                           *        title    DEFINES
    2                           
    3                                   $IFDEF     HC11
    4                           
    5                           */***** HC11EVB defines *****/
    6                           
    7      E000                 ROMBEG: EQU    $E000
    8      2000                 ROMSIZE:        EQU    $2000
    9      9800                 ACIAST: EQU    $9800
   10      9801                 ACIADT: EQU    ACIAST+1
   11      4000                 DFLOP:  EQU    $4000
   12      0002                 SWPRE:  EQU    02           ; SOFTWARE PRESCALER VALUE.
   13                           *
   14                           *
   15                           *
   16      0000                 SBASBEG:        equ    0
   17      0002                 SBASEND:        equ    2
   18      0004                 SVARBEG:        equ    4
   19      0006                 SVAREND:        equ    6
   20      0008                 SHILINE:        equ    8
   21      000A                 AUTOSTF:        equ    10
   22      000B                 SSTART: equ    11
   23                           
   49                                   $ENDIF
   50                           
   51                           */***** hc11 (device dependant) defines *****/
   52                           
   53      B600                 EEPBASAD:       EQU    $B600   ; /* EEPROM base address */
   54      00FF                 MAXEESUB:       EQU    255     ; /* maximum EEP subscript */
   55                           *
   56                           *       I/O Register Offsets From The Base Address
   57                           *
   58      003B                 PPROG:  EQU    $3B  ; /* EEPROM programing control register */
   59      0030                 ADCTL:  EQU    $30  ; /* A-TO-D control/status register */
   60      0031                 ADR1:   EQU    $31  ; /* A/D result register 1 */
   61      0032                 ADR2:   EQU    $32       ; /* A/D result register 2 */
   62      0033                 ADR3:   EQU    $33       ; /* A/D result register 3 */
   63      0034                 ADR4:   EQU    $34       ; /* A/D result register 4 */
   64      0000                 PORTAIO:        EQU    $00       ; /* PORTA I/O register */
   65      0004                 PORTBIO:        EQU    $04       ; /* PORTB I/O register */
   66      0003                 PORTCIO:        EQU    $03       ; /* PORTC I/O register */
   67      0007                 DDRC:           EQU    $07       ; Portc direction register
   68      0008                 PORTDIO:        EQU    $08       ; /* PORTD I/O register */
   69      000A                 PORTEIO:        EQU    $0A       ; /* PORTE I/O register */
   70      000E                 TCNT:   EQU    $0E       ; /* TIMER/COUNTER register */
   71      0016                 TOC1REG:        EQU    $16       ; /* TIMER Output Compare 1 register */
   72      0023                 TFLAG1: EQU    $23       ; /* TIMER Flag #1 register */
   73      0022                 TMSK1:  EQU    $22       ; /* TIMER Mask #1 register */
   74      0024                 TMSK2:  EQU    $24       ; /* TIMER Mask #2 register */
   75      0039                 OPTION: EQU    $39       ; /* OPTION select register */
   76      002B                 BAUD:   EQU    $2B       ; /* SCI baud rate select register */
   77      002C                 SCCR1:  EQU    $2C       ; /* SCI control register #1 */
   78      002D                 SCCR2:  EQU    $2D       ; /* SCI control register #2 */
   79      002E                 SCSR:   EQU    $2E       ; /* SCI status register */
   80      002F                 SCDR:   EQU    $2F       ; /* SCI transmit/recieve data register */
   81      0027                 PACNT:  EQU    $27       ; /* PACC count register */
   82      0026                 PACTL:  EQU    $26       ; /* PACC control register */
   83      0025                 TFLG2:  EQU    $25       ; /* TIMER Flag #2 register */
   84      003D                 INIT:   EQU    $3D       ; /* INIT (Base address of RAM & I/O Regs) Register */
   85                           
   86                           */***** misc. defines *****/
   87                           
   88      000D                 EOL:    EQU    13      ; /* end of line marker */
   89      000D                 CR:     EQU    13      ; /* same as EOL */
   90      000A                 LF:     EQU    10      ; /* linefeed character */
   91      0008                 BS:     EQU    8       ; /* backspace character */
   92      0020                 SPC:    EQU    32      ; /* space character */
   93      003A                 MIDEOL: EQU    ':'     ; /* mid EOL character */
   94      002C                 COMMA:  EQU    ','     ; /* comma */
   95      003B                 SEMI:   EQU    ';'     ; /* semicolin */
   96      0001                 NUM:    EQU    1       ; /* getvar return flag */
   97      0002                 STRING: EQU    2       ; /* getvar return flag */
   98      0000                 NULL:   EQU    0       ; /* null value */
   99      0003                 CNTRLC: EQU    3       ; /* control-c (break character) */
  100                           *
  101                           *
  102      0050                 IBUFLEN:        EQU    80      ; /* input buffer max length */
  103      0080                 TBUFLEN:        EQU    128     ; /* token buffer max length */
  104      0250                 SWSTKSize:      EQU     592
  105                           *
  106      001E                 OPSLEN:          EQU    30      ; /* operator stack length */
  107      003C                 NUMSLEN:                 EQU    60      ; /* operand stack length */
  108      0050                 FORSLEN:        EQU     80      ; /* FOR..NEXT stack length */
  109      0010                 WHSLEN:          EQU    16      ; /* WHILE..ENDWH stack length */
  110      0010                 GOSLEN:          EQU    16      ; /* GOSUB stack length */
  111                           *
  112                           */***** define error codes *****/
  113                           
  114      0001                 LINRANG:        EQU    1       ; /* line number range error */
  115      0002                 SYTXERR:        EQU    2       ; /* syntax error */
  116      0003                 IVEXPERR:       EQU    3       ; /* invalid expression error */
  117      0004                 UPARNERR:       EQU    4       ; /* unbalanced parentheses error */
  118      0005                 DTMISERR:       EQU    5       ; /* data type mismatch error */
  119      0006                 OPRTRERR:       EQU    6       ; /* illegal operator error */
  120      0007                 ILVARERR:       EQU    7       ; /* illegal variable error */
  121      0008                 ILTOKERR:       EQU    8       ; /* illegal token error */
  122      0009                 OMEMERR:        EQU    9       ; /* out of memory error */
  123      000A                 INTOVERR:       EQU    10      ; /* integer overflow error */
  124      000B                 IVHEXERR:       EQU    11      ; /* invalid hex digit error */
  125      000C                 HEXOVERR:       EQU    12      ; /* hex number overflow */
  126      000D                 MISQUERR:       EQU    13      ; /* missing quote error */
  127      000E                 MPARNERR:       EQU    14      ; /* missing open or closing parenthisis */
  128      000F                 IONSYERR:       EQU    15      ; /* "ON" syntax error */
  129      0010                 MTHENERR:       EQU    16      ; /* missing "THEN" in "IF" statement */
  130      0011                 MTOERR: EQU    17      ; /* missing "TO" in "FOR" statement */
  131      0012                 LINENERR:       EQU    18      ; /* line number error */
  132      0013                 IDTYERR:        EQU    19      ; /* illegal data type error */
  133      0014                 EXPCXERR:       EQU    20      ; /* expression too complex (xlator token buff ovf.) */
  134      0015                 MCOMAERR:       EQU    21      ; /* missing comma */
  135      0016                 MCMSMERR:       EQU    22      ; /* missing comma or semicolin */
  136      0017                 MSTKOERR:       EQU    23      ; /* math stack overflow error */
  137      0018                 UNDIMERR:       EQU    24      ; /* undimentioned array error */
  138      0019                 SUBORERR:       EQU    25      ; /* subscript out of range error */
  139      001A                 ZDIVERR:        EQU    26      ; /* divide by zero error */
  140      001B                 LNFERR: EQU    27      ; /* line not found error */
  141      001C                 GOSOVERR:       EQU    28      ; /* too many nested GOSUB's */
  142      001D                 RWOGERR:        EQU    29      ; /* RETURN w/o GOSUB error */
  143      001E                 WHSOVERR:       EQU    30      ; /* too many active WHILE's */
  144      001F                 ENDWHERR:       EQU    31      ; /* ENDWH statement w/o WHILE */
  145      0020                 ONARGERR:       EQU    32      ; /* ON argument is negative, zero, or too large */
  146      0021                 NOSUBERR:       EQU    33      ; /* non-subscriptable variable found in DIM statem. */
  147      0022                 REDIMERR:       EQU    34      ; /* variable has already been DIMensioned */
  148      0023                 FORNXERR:       EQU    35      ; /* too many active FOR -- NEXT loops active */
  149      0024                 MFRNXERR:       EQU    36      ; /* mismatched FOR -- NEXT statements. */
  150      0025                 CNTCNERR:       EQU    37      ; /* can't continue */
  151      0026                 ODRDERR:        EQU    38      ; /* out of data in read or restore statement */
  152      0027                 NEGSUBER:       EQU    39      ; /* negative subscripts not allowed */
  153      0028                 EESUBERR:       EQU    40      ; /* EEP() subscript negative or > 200 */
  154      0029                 PRFUNERR:       EQU    41      ; /* function only allowed in print statement */
  155      002A                 TABARGER:       EQU    42      ; /* argument <0 or >255 in TAB() function */
  156      002B                 CHRARGER:       EQU    43      ; /* argument <0 or >255 in CHR$() function */
  157      002C                 OVDV0ERR:       EQU    44      ; /* overflow or /0 error in FDIV() function */
  158      002D                 INVCHERR:       EQU    45      ; /* invalid channel number in ADC() function */
  159      002E                 PRTASERR:       EQU    46      ; /* tried to assign a value <0 or >255 to PORT(X) */
  160      002F                 ILPRTERR:       EQU    47      ; /* illegal port error */
  161      0030                 ILLIOERR:       EQU    48      ; /* illegal I/O vector number <0 or >7 */
  162      0031                 UNINIERR:       EQU    49      ; /* uninitalized I/O vector */
  163      0032                 HEX2AERR:       EQU    50      ; /* argument <0 or >255 in HEX2 function */
  164      0033                 NOTALERR:       EQU    51      ; /* statement not allowed in direct mode */
  165      0034                 NOTINTER:       EQU    52      ; /* an RETI statement executed when not in interrupt */
  166      0035                 PACCARGE:       EQU    53      ; /* tried to assign a value of <0 or >255 to PACC */
  167      0036                 INTMODER:       EQU    54      ; /* interrupt or count mode error in ONPACC */
  168      0037                 EETOSMAL:       EQU    55      ; /* program storage EEPROM is Too Small */
  169                           
  170                           */* mathematical operator tokens */
  171                           
  172      0010                 OPARNTOK:       EQU    $10     ; /* '(' */
  173      0011                 CPARNTOK:       EQU    $11     ; /* ')' */
  174      0020                 ANDTOK: EQU    $20     ; /* 'AND' */
  175      0021                 ORTOK:  EQU    $21     ; /* 'OR' */
  176      0022                 EORTOK: EQU    $22     ; /* 'EOR' */
  177      0030                 LTTOK:  EQU    $30     ; /* '<' */
  178      0031                 GTTOK:  EQU    $31     ; /* '> */
  179      0032                 LTEQTOK:        EQU    $32     ; /* '<=' */
  180      0033                 GTEQTOK:        EQU    $33     ; /* '>=' */
  181      0034                 EQTOK:  EQU    $34     ; /* '=' */
  182      0035                 NOTEQTOK:       EQU    $35     ; /* '<>' */
  183      0040                 PLUSTOK:        EQU    $40     ; /* '+' */
  184      0041                 MINUSTOK:       EQU    $41     ; /* '-' */
  185      0042                 SPLUSTOK:       EQU    $42     ; /* '+' */
  186      0050                 MULTTOK:        EQU    $50     ; /* '*' */
  187      0051                 DIVTOK: EQU    $51     ; /* '/' */
  188      0052                 MODTOK: EQU    $52     ; /* '%' */
  189      0060                 PWRTOK: EQU    $60     ; /* '^' */
  190      0070                 INDIRTOK:       EQU    $70     ; /* '@' */
  191      0071                 NOTTOK: EQU    $71     ; /* 'NOT' */
  192      0072                 NEGTOK: EQU    $72     ; /* '-' (uniary minus) */
  193                           
  194                           */* keyword tokens */
  195                           
  196      0001                 LETTOK: EQU    $01     ; /* LET */
  197      0002                 IMLETTOK:       EQU    $02     ; /* implied LET */
  198      0003                 PRINTTOK:       EQU    $03     ; /* PRINT */
  199      0004                 FORTOK: EQU    $04     ; /* FOR */
  200      0005                 NEXTTOK:        EQU    $05     ; /* NEXT */
  201      0006                 TRONTOK:        EQU    $06     ; /* TRON */
  202      0007                 TROFFTOK:       EQU    $07     ; /* TROFF */
  203      0008                 POKETOK:        EQU    $08     ; /* POKE */
  204      0009                 DIMTOK: EQU    $09     ; /* DIM */
  205      000A                 REMTOK: EQU    $0A     ; /* REM */
  206      000B                 PACCTOK:        EQU    $0B     ; /* PACC */
  207      000C                 DATATOK:        EQU    $0C     ; /* DATA */
  208      000D                 READTOK:        EQU    $0D     ; /* READ */
  209      000E                 RESTRTOK:       EQU    $0E     ; /* RESTORE */
  210      000F                 GOSUBTOK:       EQU    $0F     ; /* GOSUB */
  211      0012                 GOTOTOK:        EQU    $12     ; /* GOTO */
  212      0013                 ONTOK:  EQU    $13     ; /* ON */
  213      0014                 RETNTOK:        EQU    $14     ; /* RETURN */
  214      0015                 IFTOK:  EQU    $15     ; /* IF */
  215      0016                 INPUTTOK:       EQU    $16     ; /* INPUT */
  216      0017                 STOPTOK:        EQU    $17     ; /* STOP */
  217      0018                 ENDTOK: EQU    $18     ; /* END */
  218      0019                 WHILETOK:       EQU    $19     ; /* WHILE */
  219      001A                 ENDWHTOK:       EQU    $1A     ; /* ENDWH */
  220      001B                 EEPTOK: EQU    $1B     ; /* EEP */
  221      001C                 PORTATOK:       EQU    $1C     ; /* PORTA */
  222      001D                 PORTBTOK:       EQU    $1D     ; /* PORTB */
  223      001E                 PORTCTOK:       EQU    $1E     ; /* PORTC */
  224      001F                 PORTDTOK:       EQU    $1F     ; /* PORTD */
  225      0023                 INBYTTOK:       EQU    $23     ; /* INBYTE */
  226      0024                 TIMETOK:        EQU    $24     ; /* TIME */
  227      0025                 ONTIMTOK:       EQU    $25     ; /* ONTIME */
  228      0026                 ONIRQTOK:       EQU    $26     ; /* ONIRQ */
  229      0027                 RETITOK:        EQU    $27     ; /* RETI */
  230      0028                 ONPACTOK:       EQU    $28     ; /* ONPACC */
  231      0029                 SLEEPTOK:       EQU    $29     ; /* SLEEP */
  232      002A                 RTIMETOK:       EQU    $2A     ; /* RTIME */
  233      0036                 FUNCTFLG:       EQU    $36     ; /* function flag byte */
  234      0037                 TOTOK:  EQU    $37     ; /* TO */
  235      0038                 THENTOK:        EQU    $38     ; /* THEN */
  236      0039                 ELSETOK:        EQU    $39     ; /* ELSE */
  237      003A                 STEPTOK:        EQU    $3A     ; /* STEP */
  238                           
  239                           */* function tokens */
  240                           
  241      0001                 FDIVTOK:        EQU    $01     ; /* FDIV */
  242      0002                 CHRTOK: EQU    $02     ; /* CHR$ */
  243      0003                 ADCTOK: EQU    $03     ; /* ADC */
  244      0004                 ABSTOK: EQU    $04     ; /* ABS */
  245      0005                 RNDTOK: EQU    $05     ; /* RND */
  246      0006                 SGNTOK: EQU    $06     ; /* SGN */
  247      0007                 TABTOK: EQU    $07     ; /* TAB */
  248      0008                 CALLTOK:        EQU    $08     ; /* CALL */
  249      0009                 PEEKTOK:        EQU    $09     ; /* PEEK */
  250      000A                 FEEPTOK:        EQU    $0A     ; /* EEP */
  251      000B                 HEXTOK: EQU    $0B     ; /* HEX */
  252      000C                 FPRTATOK:       EQU    $0C     ; /* PORTA */
  253      000D                 FPRTBTOK:       EQU    $0D     ; /* PORTB */
  254      000E                 FPRTCTOK:       EQU    $0E     ; /* PORTC */
  255      000F                 FPRTDTOK:       EQU    $0F     ; /* PORTD */
  256      0010                 FPRTETOK:       EQU    $10     ; /* PORTE */
  257      0011                 FTIMETOK:       EQU    $11     ; /* TIME */
  258      0012                 HEX2TOK:        EQU    $12     ; /* HEX2 */
  259      0013                 FPACCTOK:       EQU    $13     ; /* PACC */
  260                           
  261                           */* numerical/variable tokens */
  262                           
  263      0081                 FVARTOK:        EQU    $81     ; /* floating point variable address */
  264      0082                 SVARTOK:        EQU    $82     ; /* string variable address */
  265      0084                 IVARTOK:        EQU    $84     ; /* integer variable address */
  266                           
  267      0091                 FAVARTOK:       EQU    $91     ; /* floating point array */
  268      0092                 SAVARTOK:       EQU    $92     ; /* string array */
  269      0094                 IAVARTOK:       EQU    $94     ; /* integer array */
  270                           
  271      00A1                 FCONTOK:        EQU    $A1     ; /* floating point constant */
  272      00A2                 SCONTOK:        EQU    $A2     ; /* string constant */
  273      00A8                 LCONTOK:        EQU    $A8     ; /* line # constant */
  274      00A4                 ICONTOK:        EQU    $A4     ; /* integer constant */
  275                           
  276      0002                 ISIZ:   EQU    2       ; /* number of bytes in integer variable */
  277      0003                 SSIZ:   EQU    3       ; /* number of bytes in string variable */
  278      0005                 FSIZ:   EQU    5       ; /* number of bytes in f.p. variable */
  279      0002                 ASIZ:   EQU    2       ; /* number of bytes for array variable in dictionary */
  280                           */* misc. tokens */
  281                           
  282      007F                 MSCNTOK:        EQU    $7F     ; /* multiple space count token */
  283      007E                 SSCNTOK:        EQU    $7E     ; /* single space token */
  284      007D                 EOLTOK: EQU    $7D     ; /* end of line token */
  285      007C                 COMMATOK:       EQU    $7C     ; /* , */
  286      007B                 SEMITOK:        EQU    $7B     ; /* ; */
  287      007A                 MEOLTOK:        EQU    $7A     ; /* : */
  288      0079                 EQUALTOK:       EQU    $79     ; /* '=' */
  289      0078                 PNUMTOK:        EQU    $78     ; /* '#' */
  290                           *
  291                           *
  292      007E                 JMPOP:  EQU    $7E     ; OP-CODE FOR "JMP" (USED TO INITALIZE INTERRUPT TABLE)
  293                           
  294                           *         /*********** define variables ***********/
  295                           
  296      0000                          ORG    $0000
  297                           *
  298                           *               char
  299                           *
  300 0000+0002                 IBUFPTR:        RMB    2        ; /* input buffer pointer */
  301 0002+0002                 TBUFPTR:        RMB    2        ; /* token buffer pointer */
  302                           *
  303                           *       the next 5 variables must remain grouped togeather
  304                           *
  305 0004+0002                 BASBEG: RMB    2        ; /* start of basic program area */
  306 0006+0002                 BASEND: RMB    2        ; /* end of basic program */
  307 0008+0002                 VARBEGIN:       RMB    2        ; /* start of variable storage area */
  308 000A+0002                 VAREND: RMB    2        ; /* end of variable storage area */
  309 000C+0002                 HILINE: RMB    2        ; /* highest line number in program buffer */
  310                           *
  311                           *
  312                           *
  313 000E+0002                 BASMEND:        RMB    2        ; /* physical end of basic program memory */
  314 0010+0002                 VARMEND:        RMB    2        ; /* physical end of variable memory */
  315                           *
  316                           *               int
  317                           *
  318 0012+0002                 FIRSTLIN:       RMB    2        ; /* first line to list */
  319 0014+0002                 LASTLIN:        RMB    2        ; /* last line to list */
  320 0016+0002                 INTPTR: RMB    2        ; /* integer pointer */
  321                           *
  322                           *               short
  323                           *
  324 0018+0001                 ERRCODE:        RMB    1        ; /* error code status byte */
  325 0019+0001                 IMMID:  RMB    1        ; /* immidiate mode flag */
  326      001A                 BREAKCNT:       EQU    *        ; /* also use for break check count */
  327      001A                 COUNT:  EQU    *        ; /* count used in ESAVE & ELOAD routines */
  328 001A+0001                 IFWHFLAG:       RMB    1        ; /* translating IF flag */
  329 001B+0001                 TRFLAG: RMB    1        ; /* trace mode flag */
  330 001C+0001                 CONTFLAG:       RMB    1        ; /* continue flag */
  331 001D+0001                 RUNFLAG:        RMB    1        ; /* indicates we are in the run mode */
  332 001E+0001                 PRINTPOS:       RMB    1        ; /* current print position */
  333 001F+0002                 NUMSTACK:       RMB    2        ; /* numeric operand stack pointer */
  334 0021+0002                 OPSTACK:        RMB    2        ; /* operator stack pointer */
  335 0023+0002                 FORSTACK:       RMB    2        ; /* FOR stack pointer */
  336 0025+0002                 WHSTACK:        RMB    2        ; /* WHILE stack pointer */
  337 0027+0002                 GOSTACK:        RMB    2        ; /* GOSUB stack pointer */
  338 0029+0002                 CURLINE:        RMB    2        ; /* line # that we are currently interpreting */
  339 002B+0002                 ADRNXLIN:       RMB    2        ; /* address of the next line */
  340 002D+0002                 STRASTG:        RMB    2        ; /* dynamic string/array pool pointer */
  341 002F+0002                 FENCE:  RMB    2        ; /* varend fence in case of an error in xlation */
  342 0031+0002                 IPSAVE: RMB    2        ; /* interpretive pointer save for "BREAK" */
  343 0033+0002                 DATAPTR:        RMB    2        ; /* pointer to data for read statement */
  344 0035+0002                 RANDOM: RMB    2        ; /* random number/seed */
  345 0037+0001                 DEVNUM: RMB    1        ; /* I/O device number */
  346 0038+0002                 TIMEREG:        RMB    2        ; /* TIME register */
  347 003A+0002                 TIMECMP:        RMB    2        ; /* TIME compare register */
  348 003C+0001                 TIMEPRE:        RMB    1        ; /* software prescaler for TIME */
  349 003D+0002                 ONTIMLIN:       RMB    2        ; /* ONTIME line number to goto */
  350 003F+0002                 ONIRQLIN:       RMB    2        ; /* ONIRQ line number to goto */
  351 0041+0002                 ONPACLIN:       RMB    2        ; /* ONPACC line number to goto */
  352 0043+0001                 XONCH:  RMB    1        ; /* XON character for printer */
  353 0044+0001                 XOFFCH: RMB    1        ; /* XOFF character for printer */
  354 0045+0002                 SCURLINE:       RMB    2        ; /* used to save CURLINE during int. processing */
  355 0047+0002                 SADRNXLN:       RMB    2        ; /* used to save ADRNXLIN during int. processing */
  356 0049+0002                 INBUFFS:        rmb    2        ; /* pointer to the start of the input buffer */
  357 004B+0002                 TKNBUFS:        rmb    2        ; /* pointer to the start of the token buffer */
  358                           *
  359 004D+0002                 EOPSTK: RMB    2        ; /* end of operator stack */
  360 004F+0002                 STOPS:  RMB    2        ; /* start of operator stack */
  361 0051+0002                 ENUMSTK:        RMB    2        ; /* end of operand stack */
  362 0053+0002                 STNUMS: RMB    2        ; /* start of operand stack */
  363 0055+0002                 EFORSTK:        RMB    2        ; /* end of FOR - NEXT stack */
  364 0057+0002                 STFORSTK:       RMB    2        ; /* start of FOR - NEXT stack */
  365 0059+0002                 EWHSTK: RMB    2        ; /* end of WHILE stack */
  366 005B+0002                 STWHSTK:        RMB    2        ; /* start of WHILE stack */
  367 005D+0002                 EGOSTK: RMB    2        ; /* end of GOSUB stack */
  368 005F+0002                 STGOSTK:        RMB    2        ; /* start of GOSUB stack */
  369 0061+0002                 IOBaseV:        RMB    2        ; /* Address vector for I/O Registers */
  370 0063+0003                 DNAME:  RMB    3        ; /* Place to put the variable name when doing a dump command */
  371 0066+0002                 SUBMAX:   RMB    2        ; /*  */
  372 0068+0002                 SUBCNT: RMB    2        ; /*  */
  373 006A+0002                 TOKPTR: rmb    2        ; /* token pointer (used for list command) */
  374 006C+0002                 VarSize:        rmb    2        ; /* used by the line editor. size of the variable table */
  375                           *
  376                           *
  377                                    $if     * > $9E
  379                                    $endif
  380                           *
  381                           *
  382                           *
  383      009E                          ORG    $009E
  384                           *
  385 009E+0003                 CONSTAT:        RMB    3        ; GET CONSOLE STATUS FOR BREAK ROUTINE.
  386 00A1+0003                 INCONNE:        RMB    3        ; GET BYTE DIRECTLY FROM CONSOLE FOR BREAK ROUTINE.
  387                           *
  388      00A4                          ORG    $00A4
  389                           *
  390 00A4+0010                 INTABLE:        RMB    16       ; RESERVE SPACE FOR 8 DIFFERENT INPUT ROUTINES.
  391 00B4+0010                 OUTABLE:        RMB    16       ; RESERVE SPACE FOR 8 DIFFERENT OUTPUT ROUTINES.
  392                           *
  393                           *
  394                           *
  395                           *
  396      00C4                          ORG    $00C4    ; START OF RAM INTERRUPT VECTORS.
  397                           *
  398      00C4                 RAMVECTS:       EQU    *
  399 00C4+0003                 SCISS:  RMB    3        ; SCI SERIAL SYSTEM.
  400 00C7+0003                 SPITC:  RMB    3        ; SPI TRANSFER COMPLETE.
  401 00CA+0003                 PACCIE: RMB    3        ; PULSE ACCUMULATOR INPUT EDGE.
  402 00CD+0003                 PACCOVF:        RMB    3        ; PULSE ACCUMULATOR OVERFLOW.
  403 00D0+0003                 TIMEROVF:       RMB    3        ; TIMER OVERFLOW.
  404 00D3+0003                 TOC5:   RMB    3        ; TIMER OUTPUT COMPARE 5.
  405 00D6+0003                 TOC4:   RMB    3        ; TIMER OUTPUT COMPARE 4.
  406 00D9+0003                 TOC3:   RMB    3        ; TIMER OUTPUT COMPARE 3.
  407 00DC+0003                 TOC2:   RMB    3        ; TIMER OUTPUT COMPARE 2.
  408 00DF+0003                 TOC1:   RMB    3        ; TIMER OUTPUT COMPARE 1.
  409 00E2+0003                 TIC3:   RMB    3        ; TIMER INPUT CAPTURE 3.
  410 00E5+0003                 TIC2:   RMB    3        ; TIMER INPUT CAPTURE 2.
  411 00E8+0003                 TIC1:   RMB    3        ; TIMER INPUT CAPTURE 1.
  412 00EB+0003                 REALTIMI:       RMB    3        ; REAL TIME INTERRUPT.
  413 00EE+0003                 IRQI:   RMB    3        ; IRQ INTERRUPT.
  414 00F1+0003                 XIRQ:   RMB    3        ; XIRQ INTERRUPT.
  415 00F4+0003                 SWII:   RMB    3        ; SOFTWARE INTERRUPT.
  416 00F7+0003                 ILLOP:  RMB    3        ; ILLEGAL OPCODE TRAP.
  417 00FA+0003                 COP:    RMB    3        ; WATCH DOG TIMER FAIL.
  418 00FD+0003                 CMF:    RMB    3        ; CLOCK MONITOR FAIL.
  419                           *
  420                           *
*** END   INCLUDE FILE: DEFINES.ASM *** (RESUMING FILE: BASIC11.ASM)
    7                           #Include 'BASICLB1.Asm'
*** BEGIN INCLUDE FILE: BASICLB1.ASM ***
    1      E000                         ORG    ROMBEG
    2                           *        title    BASICLB1
    3                           ******************************************************************************
    4                           *                                                                            *
    5                           *                      MC68HC11 BASIC INTERPRETER                            *
    6                           *                                                                            *
    7                           *                             WRITTEN BY:                                    *
    8                           *                                                                            *
    9                           *                           GORDON DOUGHMAN                                  *
   10                           *                                                                            *
   11                           *                        COPYRIGHT 1985-1990 BY                              *
   12                           *                                                                            *
   13                           *                           GORDON DOUGHMAN                                  *
   14                           *                                                                            *
   15                           ******************************************************************************
   16                           *
   17                           *
   18                           */
   19                           *       include "1.DEFINES.C"
   20                           *
   21                           *main()
   22                           *{
   23                           * initvars();            /* initalize all variables & pointers */
   24                           * outheader();           /* send startup message to console */
   25                           * outrdy();              /* output ready message */
   26                           *
   27 E000:7EED 72         [ 3]         JMP    POWERUP
   28      E003                 MAIN:   EQU    *
   29 E003:BDEC FA         [ 6] MAINC:  JSR    INITVARS     ; INITALIZE ALL INTERNAL VARIABLES.
   30 E006:FEFF C4         [ 5]         LDX    EEStart
   31 E009:A60A            [ 4]         LDAA   AUTOSTF,X    ; get the auto start flag.
   32 E00B:8155            [ 2]         CMPA   #$55
   33 E00D:2604 (E013)     [ 3]         BNE    MAIN9
   34 E00F:0E              [ 2]         CLI             ; ALLOW ALL INTERRUPTS TO BE SERVICED.
   35 E010:BDF1 59         [ 6]         JSR    CRUN
   36 E013:BDE0 68         [ 6] MAIN9:  JSR    OUTHEADR     ; PRINT HEADER.
   37      E016                 MAINW:  EQU    *
   38 E016:FCFF C0         [ 5] MAIN2:  LDD    RAMStart     ; RESET STACK VALUE.
   39 E019:F3FF C2         [ 6]         ADDD   RAMSize
   40 E01C:8F              [ 3]         XGDX
   41 E01D:35              [ 3]         TXS
   42 E01E:0E              [ 2]         CLI                 ; (J.I.C.)
   43 E01F:4F              [ 2]         CLRA                ; CLEAR D.
   44 E020:5F              [ 2]         CLRB
   45 E021:DD3A            [ 4]         STD    TIMECMP      ; DON'T ALLOW "ONTIME" INTERRUPTS TO OCCUR.
   46 E023:DD3F            [ 4]         STD    ONIRQLIN     ; DON'T ALLOW "ONIRQ" INTERRUPTS TO OCCUR.
   47 E025:DD41            [ 4]         STD    ONPACLIN     ; DON'T ALLOW "PACC" INTERRUPTS TO OCCUR.
   48 E027:BDE0 AB         [ 6]         JSR    OUTRDY       ; PRINT READY MESSAGE.
   49                           *
   50                           * while(1)               /* do forever */
   51                           * {
   52                           *  outprmpt();           /* output prompt */
   53                           *  getline();            /* getline from console */
   54                           *  skipspcs();           /* ignore leading spaces in input buffer */
   55                           *  if(chckcmds()) continue;           /* check for commands */
   56                           *  parse();              /* translate/execute line */
   57                           *  if(errcode) rpterr(); /* if an error occured somewhere, report it. */
   58                           *  errcode=0;            /* clear error status */
   59                           * }
   60                           *}
   61                           *
   62      E02A                 MAIN1:  EQU    *
   63 E02A:7F00 19         [ 6]         CLR    IMMID        ; CLEAR THE IMMIDIATE MODE FLAG.
   64 E02D:7F00 18         [ 6]         CLR    ERRCODE      ; CLEAR THE ERROR CODE BYTE.
   65 E030:7F00 1D         [ 6]         CLR    RUNFLAG      ; CLEAR THE RUN MODE FLAG.
   66 E033:BDE1 05         [ 6]         JSR    OUTPRMPT     ; SEND PROMPT TO CONSOLE.
   67 E036:BDE0 BB         [ 6]         JSR    GETLINE      ; GO GET LINE FROM OPERATOR.
   68 E039:BDE0 5B         [ 6]         JSR    SKIPSPCS     ; SKIP ANY LEADING SPACES.
   69 E03C:BDEE 48         [ 6]         JSR    CHCKCMDS     ; GO CHECK FOR ANY COMMANDS.
   70 E03F:1A83 0000       [ 5]         CPD    #0           ; WERE THERE ANY?
   71 E043:26D1 (E016)     [ 3]         BNE    MAIN2        ; YES. CONTINUE.
   72 E045:DE0A            [ 4]         LDX    VAREND       ; SAVE CURRENT END OF VARIABLE AREA IN CASE LINE
   73 E047:DF2F            [ 4]         STX    FENCE        ; HAS AN ERROR IN IT. (SO NO SPURIOUS VARIABLES
   74                           *                             ; ARE ALLOCATED)
   75 E049:BDE1 27         [ 6]         JSR    PARSE
   76 E04C:7D00 19         [ 6]         TST    IMMID        ; DID WE EXECUTE IN IMMIDATE MODE?
   77 E04F:26C5 (E016)     [ 3]         BNE    MAIN2        ; YES. PRINT READY MESSAGE.
   78 E051:20D7 (E02A)     [ 3]         BRA    MAIN1        ; NO. JUST PRINT PROMPT.
   79                           *
   80                           *
   81 E053:DE2F            [ 4] MAIN3:  LDX    FENCE        ; GET THE VAREND FENCE.
   82 E055:6F00            [ 6]         CLR    0,X          ; MARK "OLD" END OF VARIABLE AREA IN CASE ANY
   83                           *                             ; VARIABLES WERE ALLOCATED.
   84 E057:DF0A            [ 4]         STX    VAREND       ; RESTORE THE POINTER.
   85 E059:20BB (E016)     [ 3]         BRA    MAIN2        ; CONTINUE AFTER ERROR.
   86                           *
   87                           *        /***** skipspcs() *****/
   88                                   
   89                           *skipspcs()
   90                           *{
   91                           * while(*ibufptr==SPC) ++ibufptr;
   92                           * return;
   93                           *}
   94                           *
   95      E05B                 SKIPSPCS:       EQU    *
   96 E05B:BDE3 C3         [ 6] SKIPSPC1:       JSR    GETCHR
   97 E05E:8120            [ 2]         CMPA   #SPC
   98 E060:2605 (E067)     [ 3]         BNE    SKIPSPC2
   99 E062:BDE3 CC         [ 6]         JSR    INCIBP
  100 E065:20F4 (E05B)     [ 3]         BRA    SKIPSPC1
  101 E067:39              [ 5] SKIPSPC2:       RTS
  102                           *
  103                                   
  104                           *        /***** outheader *****/
  105                                   
  106                           *outheader()
  107                           *{
  108                           * pl("BASIC11 v1.1");
  109                           * nl();
  110                           * nl();
  111                           * pl("Written by Gordon Doughman");
  112                           * nl();
  113                           *}
  114                           *
  115      E068                 OUTHEADR:       EQU    *
  116 E068:CEE0 6E         [ 3]         LDX    #HEADER
  117 E06B:7EE1 1C         [ 3]         JMP    PL
  118                           *
  119      E06E                 HEADER: EQU    *
  120 E06E.0D                           FCB    $0D,$0A,$0D,$0A
  120 E06F.0A                   
  120 E070.0D                   
  120 E071.0A                   
  121 E072.4241 5349 4331               FCC    "BASIC11 v1.55"
  121      3120 7631 2E35  
  121      35              
  122 E07F.0D                           FCB    $0D,$0A
  122 E080.0A                   
  123 E081.436F 7079 7269               FCC    "Copyright 1985-1990 by"
  123      6768 7420 3139  
  123      3835 2D31 3939  
  123      3020 6279       
  124 E097.0D                           FCB    $0D,$0A
  124 E098.0A                   
  125 E099.476F 7264 6F6E               FCC    "Gordon Doughman"
  125      2044 6F75 6768  
  125      6D61 6E         
  126 E0A8.0D                           FCB    $0D,$0A,0
  126 E0A9.0A                   
  126 E0AA.00                   
  127                           *
  128                           *
  129                           *        /***** outrdy() *****/
  130                                   
  131                           *outrdy()
  132                           *{
  133                           * nl();
  134                           * pl("READY");
  135                           * return;
  136                           *}
  137                           *
  138      E0AB                 OUTRDY: EQU    *
  139 E0AB:CEE0 B1         [ 3]         LDX    #READY
  140 E0AE:7EE1 1C         [ 3]         JMP    PL
  141                           *
  142      E0B1                 READY:  EQU    *
  143 E0B1.0D                           FCB    $0D,$0A
  143 E0B2.0A                   
  144 E0B3.5245 4144 59                 FCC    "READY"
  145 E0B8.0D                           FCB    $0D,$0A,0
  145 E0B9.0A                   
  145 E0BA.00                   
  146                           *
  147                           *
  148                           *        /***** getline() *****/
  149                                   
  150                           *getline()
  151                           *{
  152                           * short chrcnt;
  153                           * char c;
  154                           * chrcnt=IBUFLEN;
  155                           * ibufptr=inbuff;
  156                           *
  157      E0BB                 GETLINE:        EQU    *
  158 E0BB:C64F            [ 2]         LDAB   #IBUFLEN-1
  159 E0BD:DE49            [ 4]         LDX    INBUFFS
  160                           *
  161                           * while((c=inbyte())!=EOL && (chrcnt>0))
  162                           * {
  163                           *
  164 E0BF:BDFE EA         [ 6] GETLINE3:       JSR    INBYTE
  165 E0C2:810D            [ 2]         CMPA   #EOL
  166 E0C4:272B (E0F1)     [ 3]         BEQ    GETLINE1
  167 E0C6:5D              [ 2]         TSTB
  168 E0C7:2728 (E0F1)     [ 3]         BEQ    GETLINE1
  169                           *
  170                           *  if(c==BS)
  171                           *  {
  172                           *   if(ibufptr!=inbuff)
  173                           *   {
  174                           *    ibufptr-=1;         /* point to previous buffer location */
  175                           *    outbyte(SPC);        /* erase character on screen */
  176                           *    outbyte(BS);        /* back cursor up */
  177                           *    chrcnt+=1;
  178                           *   }
  179                           *   else
  180                           *    continue;
  181                           *   }
  182                           *
  183                           *
  184 E0C9:8108            [ 2]         CMPA   #BS
  185 E0CB:2610 (E0DD)     [ 3]         BNE    GETLINE2
  186 E0CD:C14F            [ 2]         CMPB   #IBUFLEN-1
  187 E0CF:2720 (E0F1)     [ 3]         BEQ    GETLINE1
  188 E0D1:09              [ 3]         DEX
  189 E0D2:8620            [ 2]         LDAA   #SPC
  190 E0D4:BDFE CD         [ 6]         JSR    OUTBYTE
  191 E0D7:8608            [ 2]         LDAA   #BS
  192 E0D9:BDFE CD         [ 6]         JSR    OUTBYTE
  193 E0DC:5C              [ 2]         INCB
  194                           *
  195                           *  if(c < SPC) continue;  /* ignore all other control characters */
  196                           *
  197      E0DD                 GETLINE2:       EQU    *
  198 E0DD:8103            [ 2]         CMPA   #CNTRLC      ; IS IT A "BREAK"?
  199 E0DF:2606 (E0E7)     [ 3]         BNE    GETLINE4     ; NO. GO PROCESS THE CHARACTER.
  200 E0E1:7C00 1C         [ 6]         INC    CONTFLAG     ; DONT ALLOW A "CONT".
  201 E0E4:7EF2 6F         [ 3]         JMP    CHCKBRK2     ; GO DO A BREAK.
  202 E0E7:8120            [ 2] GETLINE4:       CMPA   #SPC
  203 E0E9:25D4 (E0BF)     [ 3]         BLO    GETLINE3
  204                           *
  205                           *  *ibufptr=c;            /* save character in input buffer */
  206                           *  ibufptr+=1;           /* point to next location */
  207                           *  chrcnt-=1;
  208                           * }
  209 E0EB:A700            [ 4]         STAA   0,X
  210 E0ED:08              [ 3]         INX
  211 E0EE:5A              [ 2]         DECB
  212 E0EF:26CE (E0BF)     [ 3]         BNE    GETLINE3
  213                           *
  214                           * *ibufptr=EOL;          /* put EOL in input buffer */
  215                           * ibufptr=inbuff;        /* initalize the input buffer pointer */
  216                           * return;
  217                           *}
  218                           *
  219      E0F1                 GETLINE1:       EQU    *
  220 E0F1:860D            [ 2]         LDAA   #EOL
  221 E0F3:A700            [ 4]         STAA   0,X
  222 E0F5:DE49            [ 4]         LDX    INBUFFS
  223 E0F7:DF00            [ 4]         STX    IBUFPTR
  224 E0F9:39              [ 5]         RTS
  225                           *
  226      E0FA                 ToUpper:                 EQU    *
  227 E0FA:8161            [ 2]          cmpa   #'a'            ; is the character less than a lower case 'a'?
  228 E0FC:2506 (E104)     [ 3]          blo    ToUpper1
  229 E0FE:817A            [ 2]          cmpa   #'z'
  230 E100:2202 (E104)     [ 3]          bhi    ToUpper1
  231 E102:84DF            [ 2]          anda   #$df
  232 E104:39              [ 5] ToUpper1:       rts
  233                                   
  234                           *        /***** outprmpt() *****/
  235                                   
  236                           *outprmpt()
  237                           *{
  238                           * nl();          /* go to new line */
  239                           * outbyte('#');  /* send prompt to console */
  240                           * return;
  241                           *}
  242                           *
  243      E105                 OUTPRMPT:       EQU    *
  244 E105:CEE1 0A         [ 3]         LDX    #PRMPTSTR
  245 E108:2012 (E11C)     [ 3]         BRA    PL
  246                           *
  247      E10A                 PRMPTSTR:       EQU    *
  248 E10A.0D                           FCB    $0D,$0A
  248 E10B.0A                   
  249 E10C.3E                           FCC    ">"
  250 E10D.00                           FCB    0
  251                           *
  252                           *        /***** nl() *****/
  253                                   
  254                           * nl()                    /* send CR/LF to console */
  255                           *{
  256                           * outbyte(CR);
  257                           * outbyte(LF);
  258                           * return;
  259                           *}
  260                           *
  261                           *
  262 E10E:8D00 (E110)     [ 6] NL2:    BSR    NL
  263      E110                 NL:     EQU    *
  264 E110:CEE1 19         [ 3]         LDX    #CRLFSTR
  265 E113:8D07 (E11C)     [ 6]         BSR    PL
  266 E115:7F00 1E         [ 6]         CLR    PRINTPOS     ; SET THE CURRENT PRINT POSITION TO 0.
  267 E118:39              [ 5]         RTS
  268                           *
  269 E119.0A                   CRLFSTR:        FCB    $0A,$0D,$00
  269 E11A.0D                   
  269 E11B.00                   
  270                           *
  271                           *        /***** pl() *****/
  272                                   
  273                           *pl(ptr)                 /* send line to console */
  274                           *char *ptr;
  275                           *{
  276                           * int k; char c;
  277                           * k=0;
  278                           * while(c=ptr[k++]) outbyte(c);
  279                           * return;
  280                           *}
  281                           *
  282      E11C                 PL:     EQU    *
  283 E11C:A600            [ 4] PL1:    LDAA   0,X
  284 E11E:2706 (E126)     [ 3]         BEQ    PL2
  285 E120:BDFE CD         [ 6]         JSR    OUTBYTE
  286 E123:08              [ 3]         INX
  287 E124:20F6 (E11C)     [ 3]         BRA    PL1
  288 E126:39              [ 5] PL2:    RTS
  289                           *
  290                                   
  291                           *        /***** parse() *****/
  292                                   
  293                           *parse()
  294                           *{
  295                           * int num;
  296                           * tbufptr=tknbuf;                /* initalize the token buffer pointer */
  297                           *
  298      E127                 PARSE:  EQU    *
  299 E127:DE4B            [ 4]         LDX    TKNBUFS          ; Get the start of the token buffer
  300 E129:DF02            [ 4]         STX    TBUFPTR
  301                           *
  302                           * if(num=getlinum())             /* get line number if present */
  303                           * {
  304                           *  if(*ibufptr==EOL)             /* was line # followed by CR? */
  305                           *  {                             /* yes. */
  306                           *   delline(num);                /* go delete the line from the prog buffer */
  307                           *   return;
  308                           *  }
  309                           *  immid=0;                      /* flag as not immidiate */
  310                           *  putlinum(num);                /* put line number in buffer */
  311                           * }
  312                           *  else immid=1;                  /* if no line # flag as immidiate*/
  313                           *
  314 E12B:8D3F (E16C)     [ 6]         BSR    GETLINUM
  315 E12D:2419 (E148)     [ 3]         BCC    PARSE2
  316 E12F:36              [ 3]         PSHA
  317 E130:BDE3 C3         [ 6]         JSR    GETCHR
  318 E133:810D            [ 2]         CMPA   #EOL
  319 E135:32              [ 4]         PULA
  320 E136:2609 (E141)     [ 3]         BNE    PARSE1
  321 E138:BDEB A1         [ 6]         JSR    DELLINE
  322 E13B:DE0A            [ 4]         LDX    VAREND
  323 E13D:08              [ 3]         INX
  324 E13E:DF2D            [ 4]         STX    STRASTG
  325 E140:39              [ 5] PARSE7: RTS
  326 E141:7F00 19         [ 6] PARSE1: CLR    IMMID
  327 E144:8D6E (E1B4)     [ 6] PARSE8: BSR    PUTLINUM
  328 E146:2010 (E158)     [ 3]         BRA    PARSE3
  329 E148:BDE3 C3         [ 6] PARSE2: JSR    GETCHR
  330 E14B:810D            [ 2]         CMPA   #EOL
  331 E14D:27F1 (E140)     [ 3]         BEQ    PARSE7
  332 E14F:8601            [ 2]         LDAA   #1
  333 E151:9719            [ 3]         STAA   IMMID
  334 E153:CC00 00         [ 3]         LDD    #0
  335 E156:20EC (E144)     [ 3]         BRA    PARSE8
  336                           *
  337                           * if(errcode) return;             /* if line number error, return */
  338                           * xlate();                        /* if translation error, return */
  339                           * if(errcode) return;
  340                           * if(immid) runline();            /* if immidiate mode run 1 line */
  341                           *  else storlin();                /* if not store pgm line */
  342                           * return;                         /* go get next line */
  343                           *}
  344                           *
  345 E158:BDE1 E2         [ 6] PARSE3: JSR    XLATE
  346 E15B:7D00 19         [ 6]         TST    IMMID
  347 E15E:2703 (E163)     [ 3]         BEQ    PARSE5
  348 E160:7EF2 2E         [ 3]         JMP    RUNLINE      ; GO RUN THE LINE & RETURN.
  349 E163:BDEB 7A         [ 6] PARSE5: JSR    STORLIN      ; GO STORE LINE & RETURN.
  350 E166:DE0A            [ 4]         LDX    VAREND
  351 E168:08              [ 3]         INX
  352 E169:DF2D            [ 4]         STX    STRASTG
  353 E16B:39              [ 5]         RTS
  354                           *
  355                                   
  356                           *        /***** getlinum *****/
  357                                   
  358                           *getlinum()
  359                           *{
  360                           * int num;
  361                           * num=0;
  362                           *
  363      E16C                 GETLINUM:       EQU    *
  364                           *
  365                           *
  366 E16C:183C            [ 5]         PSHY
  367 E16E:4F              [ 2]         CLRA
  368 E16F:36              [ 3]         PSHA
  369 E170:36              [ 3]         PSHA
  370 E171:1830            [ 4]         TSY
  371                           *
  372                           * if(numeric(*ibufptr)==0) return(0);    /* if 1st char not numeric, rtn 0 */
  373                           *
  374 E173:DE00            [ 4]         LDX    IBUFPTR
  375 E175:A600            [ 4]         LDAA   0,X
  376 E177:8D42 (E1BB)     [ 6]         BSR    NUMERIC
  377 E179:2410 (E18B)     [ 3]         BCC    GTLNUM4
  378                           *
  379                           * while(numeric(*ibufptr))       /* while *ibufptr is numeric */
  380                           * {
  381                           *  num=num*10+(*ibufptr-'0');    /* get a digit */
  382                           *  ibufptr++;                    /* advance input buffer pointer */
  383                           *  if(num<=0) { errcode=LINRANG; return(0); }
  384                           * }
  385                           * return(num);
  386                           *}
  387                           *
  388 E17B:A600            [ 4] GTLNUM2:        LDAA   0,X
  389 E17D:8D3C (E1BB)     [ 6]         BSR    NUMERIC
  390 E17F:2511 (E192)     [ 3]         BCS    GTLNUM3
  391 E181:0D              [ 2]         SEC
  392 E182:18EC 00         [ 6] GTLNUM1:        LDD    0,Y
  393 E185:2604 (E18B)     [ 3]         BNE    GTLNUM4
  394 E187:8612            [ 2]         LDAA   #LINENERR
  395 E189:200D (E198)     [ 3]         BRA    GTLNUM5
  396 E18B:31              [ 3] GTLNUM4:        INS
  397 E18C:31              [ 3]         INS
  398 E18D:1838            [ 6]         PULY
  399 E18F:DF00            [ 4]         STX    IBUFPTR
  400 E191:39              [ 5]         RTS
  401 E192:8D07 (E19B)     [ 6] GTLNUM3:        BSR    ADDDIG
  402 E194:2AE5 (E17B)     [ 3]         BPL    GTLNUM2
  403 E196:8601            [ 2]         LDAA   #LINRANG
  404 E198:7EEA 98         [ 3] GTLNUM5:        JMP    RPTERR
  405                           *
  406                           *
  407      E19B                 ADDDIG: EQU    *
  408 E19B:18EC 00         [ 6]         LDD    0,Y
  409 E19E:05              [ 3]         ASLD
  410 E19F:05              [ 3]         ASLD
  411 E1A0:18E3 00         [ 7]         ADDD   0,Y
  412 E1A3:05              [ 3]         ASLD
  413 E1A4:18ED 00         [ 6]         STD    0,Y
  414 E1A7:E600            [ 4]         LDAB   0,X
  415 E1A9:08              [ 3]         INX
  416 E1AA:C030            [ 2]         SUBB   #'0'
  417 E1AC:4F              [ 2]         CLRA
  418 E1AD:18E3 00         [ 7]         ADDD   0,Y
  419 E1B0:18ED 00         [ 6]         STD    0,Y
  420 E1B3:39              [ 5]         RTS
  421                           *
  422                           *
  423                           *        /***** putlinum *****/
  424                                   
  425                           *putlinum(lnum)
  426                           *int lnum;
  427                           *{
  428                           * putint(lnum);          /* put line # in token buffer */
  429                           * *tbufptr++=0;          /* hold place for length of line */
  430                           * return;
  431                           *}
  432                           *
  433      E1B4                 PUTLINUM:       EQU    *
  434 E1B4:BDE3 D4         [ 6]         JSR    PUTDTOK
  435 E1B7:4F              [ 2]         CLRA
  436 E1B8:7EE3 D7         [ 3]         JMP    PUTTOK
  437                           *
  438                           *        /***** numeric() *****/
  439                                   
  440                           *numeric(c)
  441                           *char c;
  442                           *{
  443                           * c=c&127;
  444                           * return((c>='0')&(c<='9'));
  445                           *}
  446                           *
  447      E1BB                 NUMERIC:        EQU    *
  448 E1BB:8130            [ 2]         CMPA   #'0'
  449 E1BD:2506 (E1C5)     [ 3]         BLO    NUMERIC1
  450 E1BF:8139            [ 2]         CMPA   #'9'
  451 E1C1:2202 (E1C5)     [ 3]         BHI    NUMERIC1
  452 E1C3:0D              [ 2]         SEC
  453 E1C4:39              [ 5]         RTS
  454 E1C5:0C              [ 2] NUMERIC1:       CLC
  455 E1C6:39              [ 5]         RTS
  456                                   
  457                           *        /***** alpha() *****/
  458                                   
  459                           *alpha(c)
  460                           *char c;
  461                           *{
  462                           * c=c&127;
  463                           * return((c>='A')&(c<='Z'));
  464                           *}
  465                           *
  466      E1C7                 ALPHA:  EQU    *
  467 E1C7:8141            [ 2]         CMPA   #'A'
  468 E1C9:250E (E1D9)     [ 3]         BLO    ALPHA1
  469 E1CB:815A            [ 2]         CMPA   #'Z'
  470 E1CD:2308 (E1D7)     [ 3]         BLS    ALPHA2
  471 E1CF:8161            [ 2]         CMPA   #'a'
  472 E1D1:2506 (E1D9)     [ 3]         BLO    ALPHA1
  473 E1D3:817A            [ 2]         CMPA   #'z'
  474 E1D5:2202 (E1D9)     [ 3]         BHI    ALPHA1
  475 E1D7:0D              [ 2] ALPHA2: SEC
  476 E1D8:39              [ 5]         RTS
  477 E1D9:0C              [ 2] ALPHA1: CLC
  478 E1DA:39              [ 5]         RTS
  479                                   
  480                           *        /***** alphanum *****/
  481                                   
  482                           *alphanum(c)
  483                           *char c;
  484                           *{ return ((alpha(c)) | (numeric(c))); }
  485                           *
  486      E1DB                 ALPHANUM:       EQU    *
  487 E1DB:8DEA (E1C7)     [ 6]         BSR    ALPHA
  488 E1DD:2401 (E1E0)     [ 3]         BCC    ALPHANU1
  489 E1DF:39              [ 5]         RTS
  490 E1E0:20D9 (E1BB)     [ 3] ALPHANU1:       BRA    NUMERIC
  491                           *
  492                           */*****************************************
  493                           *              xlate()
  494                           * translate the input buffer into tokenized
  495                           * form placing the results into tknbuf
  496                           ******************************************/
  497                           *
  498                           *xlate()
  499                           *{
  500                           * while(*ibufptr!=EOL)
  501                           * {
  502                           *  ifwhflag=0;              /* set IF flag to zero */
  503                           *  blanks();              /* skip all blanks */
  504                           *  if(match("DATA")) xdata();
  505                           *  else if(match("LET")) xlet();
  506                           *  else if(match("READ")) xread();
  507                           *  else if(match("RESTORE")) xrestore();
  508                           *  else if(match("GOSUB")) xgosub();
  509                           *  else if(match("GOTO")) xgoto();
  510                           *  else if(match("ON")) xon();
  511                           *  else if(match("RETURN")) xreturn();
  512                           *  else if(match("IF")) xif();
  513                           *  else if(match("INPUT")) xinput();
  514                           *  else if(match("PRINT")) xprint();
  515                           *  else if(match("FOR")) xfor();
  516                           *  else if(match("NEXT")) xnext();
  517                           *  else if(match("STOP")) xstop();
  518                           *  else if(match("ENDWH")) xendwh();
  519                           *  else if(match("END")) xend();
  520                           *  else if(match("REM")) xrem();
  521                           */*else if(match("SWAP")) xswap();*/
  522                           *  else if(match("TRON")) xtron();
  523                           *  else if(match("TROFF")) xtroff();
  524                           *  else if(match("WHILE")) xwhile();
  525                           */*else if(match("ONIRQ")) xonirq();*/
  526                           *  else ximplet();                 /* if no keyword, assume implied LET */
  527                           *  if(errcode) return;
  528                           *  blanks();
  529                           *  if(*ibufptr==MIDEOL) { xmideol(); continue; }
  530                           *  if(*ibufptr!=EOL) { errcode=SYTXERR; return; }
  531                           *  }
  532                           * *tbufptr=EOLTOK;               /* put token eol in token buffer */
  533                           * tknbuf[2]=tbufptr-tknbuf+1;    /* put line length into tokenized line */
  534                           * return;
  535                           *}
  536                           *
  537      E1E2                 XLATE:  EQU    *
  538 E1E2:BDE3 C3         [ 6]         JSR    GETCHR      ; GET NEXT CHAR.
  539 E1E5:810D            [ 2]         CMPA   #EOL        ; AT THE END OF THE LINE?
  540 E1E7:274F (E238)     [ 3]         BEQ    XLATE1      ; YES.
  541 E1E9:7F00 1A         [ 6]         CLR    IFWHFLAG    ; NOT XLATING "IF" OR "WHILE"
  542 E1EC:BDE3 7A         [ 6]         JSR    BLANKS      ; SKIP BLANKS.
  543 E1EF:CEE2 46         [ 3]         LDX    #KEYWORDS   ; POINT TO KEYWORD TABLE.
  544 E1F2:BDE3 A5         [ 6] XLATE4: JSR    STREQ       ; IS KEYWORD IS IN THE INPUT BUFFER?
  545 E1F5:2513 (E20A)     [ 3]         BCS    XLATE2      ; YES GO PROCESS IT.
  546 E1F7:08              [ 3] XLATE3: INX                ; NO. POINT TO NEXT CHAR.
  547 E1F8:A600            [ 4]         LDAA   0,X         ; AT THE END OF THIS KEYWORD?
  548 E1FA:26FB (E1F7)     [ 3]         BNE    XLATE3      ; NO.
  549 E1FC:C604            [ 2]         LDAB   #4          ; NUMBER OF BYTES TO SKIP.
  550 E1FE:3A              [ 3]         ABX
  551 E1FF:6D00            [ 6]         TST    0,X         ; AT THE END OF THE TABLE?
  552 E201:26EF (E1F2)     [ 3]         BNE    XLATE4      ; NO. CHCK FOR NEXT KEYWORD.
  553 E203:8602            [ 2]         LDAA   #IMLETTOK   ; ASSUME AN IMPLIED LET.
  554                           *        JSR    PUTTOK       ; PUT TOKEN IN BUFFER.
  555 E205:CEE4 1C         [ 3]         LDX    #XIMPLET    ; GET ADDR OF XLATION ROUTINE.
  556                           *        JSR    0,X          ; GO DO IT.
  557                           *        BRA    XLATE6       ; GO FINISH UP.
  558 E208:2004 (E20E)     [ 3]         BRA    XLATE9
  559 E20A:A601            [ 4] XLATE2: LDAA   1,X         ; GET KEYWORD TOKEN.
  560 E20C:EE02            [ 5]         LDX    2,X         ; GET ADDR OF XLATION ROUTINE.
  561 E20E:BDE3 D7         [ 6] XLATE9: JSR    PUTTOK      ; PUT TOKEN IN BUFFER.
  562 E211:810C            [ 2]         CMPA   #DATATOK    ; SPECIAL CASE, DONT SKIP BLANKS AFTER KEYWORD.
  563 E213:2707 (E21C)     [ 3]         BEQ    XLATE5
  564 E215:810A            [ 2]         CMPA   #REMTOK     ; SAME SPECIAL CASE AS FOR DATA.
  565 E217:2703 (E21C)     [ 3]         BEQ    XLATE5
  566 E219:BDE3 7A         [ 6]         JSR    BLANKS      ; SKIP BLANKS BETWEEN KEYWORD & NEXT OBJECT.
  567 E21C:AD00            [ 6] XLATE5: JSR    0,X         ; GO DO IT.
  568 E21E:BDE3 7A         [ 6] XLATE6: JSR    BLANKS      ; SKIP BLANKS.
  569 E221:BDE3 CA         [ 6]         JSR    GETNXCHR    ; GET NEXT CHAR.
  570 E224:813A            [ 2]         CMPA   #MIDEOL     ; IS IT A MID EOL?
  571 E226:2607 (E22F)     [ 3]         BNE    XLATE7      ; NO. CHCK FOR EOL.
  572 E228:867A            [ 2]         LDAA   #MEOLTOK    ; GET MID EOL TOKEN.
  573 E22A:BDE3 D7         [ 6]         JSR    PUTTOK      ; PUT IT IN BUFFER.
  574 E22D:20B3 (E1E2)     [ 3]         BRA    XLATE       ; CONTINUE.
  575 E22F:810D            [ 2] XLATE7: CMPA   #EOL        ; EOL?
  576 E231:2705 (E238)     [ 3]         BEQ    XLATE1      ; YES. FINISH UP.
  577 E233:8602            [ 2]         LDAA   #SYTXERR    ; NO. SYNTAX ERROR.
  578 E235:7EEA 98         [ 3]         JMP    RPTERR      ; REPORT XLATION ERROR.
  579 E238:867D            [ 2] XLATE1: LDAA   #EOLTOK     ; GET EOL TOKEN.
  580 E23A:BDE3 D7         [ 6]         JSR    PUTTOK      ; PUT IT IN BUFFER.
  581 E23D:DC02            [ 4]         LDD    TBUFPTR     ; GET TOKEN BUFFER POINTER.
  582 E23F:934B            [ 5]         SUBD   TKNBUFS     ; Compute the TOKEN BUFFER LENGTH.
  583 E241:DE4B            [ 4]         LDX    TKNBUFS     ; POINT TO BUFFER.
  584 E243:E702            [ 4]         STAB   2,X         ; STORE LENGTH.
  585 E245:39              [ 5]         RTS                ; RETURN.
  586                           *
  587                           *
  588                           *        KEYWORD LOOK UP TABLE
  589                           *
  590                           *
  591      E246                 KEYWORDS:       EQU    *
  592 E246.4441 5441            DATA:   FCC    "DATA"
  593 E24A.00                           FCB    0
  594 E24B.0C                           FCB    DATATOK
  595 E24C.E3FC                         FDB    XDATA
  596 E24E.4C45 54              LET:    FCC    "LET"
  597 E251.00                           FCB    0
  598 E252.01                           FCB    LETTOK
  599 E253.E41C                         FDB    XLET
  600 E255.5245 4144            READ:   FCC    "READ"
  601 E259.00                           FCB    0
  602 E25A.0D                           FCB    READTOK
  603 E25B.EA58                         FDB    XREAD
  604 E25D.5245 5354 4F52       RESTORE:        FCC    "RESTORE"
  604      45              
  605 E264.00                           FCB    0
  606 E265.0E                           FCB    RESTRTOK
  607 E266.E3FB                         FDB    XRESTORE
  608 E268.474F 5355 42         GOSUB:  FCC    "GOSUB"
  609 E26D.00                           FCB    0
  610 E26E.0F                           FCB    GOSUBTOK
  611 E26F.E3F2                         FDB    XGOSUB
  612 E271.474F 544F            GOTO:   FCC    "GOTO"
  613 E275.00                           FCB    0
  614 E276.12                           FCB    GOTOTOK
  615 E277.E3F2                         FDB    XGOTO
  616 E279.4F4E 5449 4D45       ONTIME: FCC    "ONTIME"
  617 E27F.00                           FCB    0
  618 E280.25                           FCB    ONTIMTOK
  619 E281.E8D3                         FDB    XONTIME
  620 E283.4F4E 4952 51         ONIRQ:  FCC    "ONIRQ"
  621 E288.00                           FCB    0
  622 E289.26                           FCB    ONIRQTOK
  623 E28A.E8D3                         FDB    XONIRQ
  624 E28C.4F4E 5041 4343       ONPACC: FCC    "ONPACC"
  625 E292.00                           FCB    0
  626 E293.28                           FCB    ONPACTOK
  627 E294.E8F3                         FDB    XONPACC
  628 E296.4F4E                 ON:     FCC    "ON"
  629 E298.00                           FCB    0
  630 E299.13                           FCB    ONTOK
  631 E29A.E885                         FDB    XON
  632 E29C.5245 5455 524E       RETURN: FCC    "RETURN"
  633 E2A2.00                           FCB    0
  634 E2A3.14                           FCB    RETNTOK
  635 E2A4.E3FB                         FDB    XRETURN
  636 E2A6.4946                 IIF:    FCC    "IF"
  637 E2A8.00                           FCB    0
  638 E2A9.15                           FCB    IFTOK
  639 E2AA.E907                         FDB    XIF
  640 E2AC.494E 5055 54         INPUT:  FCC    "INPUT"
  641 E2B1.00                           FCB    0
  642 E2B2.16                           FCB    INPUTTOK
  643 E2B3.EA40                         FDB    XINPUT
  644 E2B5.5052 494E 54         PRINT:  FCC    "PRINT"
  645 E2BA.00                           FCB    0
  646 E2BB.03                           FCB    PRINTTOK
  647 E2BC.E9D8                         FDB    XPRINT
  648 E2BE.3F                           FCC    "?"
  649 E2BF.00                           FCB    0
  650 E2C0.03                           FCB    PRINTTOK
  651 E2C1.E9D8                         FDB    XPRINT
  652 E2C3.464F 52              FOR:    FCC    "FOR"
  653 E2C6.00                           FCB    0
  654 E2C7.04                           FCB    FORTOK
  655 E2C8.E970                         FDB    XFOR
  656 E2CA.4E45 5854            NEXT:   FCC    "NEXT"
  657 E2CE.00                           FCB    0
  658 E2CF.05                           FCB    NEXTTOK
  659 E2D0.E9CB                         FDB    XNEXT
  660 E2D2.5354 4F50            STOPSS: FCC    "STOP"
  661 E2D6.00                           FCB    0
  662 E2D7.17                           FCB    STOPTOK
  663 E2D8.E3FB                         FDB    XSTOP
  664 E2DA.454E 4457 48         ENDWH:  FCC    "ENDWH"
  665 E2DF.00                           FCB    0
  666 E2E0.1A                           FCB    ENDWHTOK
  667 E2E1.E3FB                         FDB    XENDWH
  668 E2E3.454E 44              ENDS:   FCC    "END"
  669 E2E6.00                           FCB    0
  670 E2E7.18                           FCB    ENDTOK
  671 E2E8.E3FB                         FDB    XEND
  672 E2EA.5245 4D              REM:    FCC    "REM"
  673 E2ED.00                           FCB    0
  674 E2EE.0A                           FCB    REMTOK
  675 E2EF.E3FC                         FDB    XREM
  676 E2F1.5452 4F4E            TRON:   FCC    "TRON"
  677 E2F5.00                           FCB    0
  678 E2F6.06                           FCB    TRONTOK
  679 E2F7.E3FB                         FDB    XTRON
  680 E2F9.5452 4F46 46         TROFF:  FCC    "TROFF"
  681 E2FE.00                           FCB    0
  682 E2FF.07                           FCB    TROFFTOK
  683 E300.E3FB                         FDB    XTROFF
  684 E302.5748 494C 45         WHILE:  FCC    "WHILE"
  685 E307.00                           FCB    0
  686 E308.19                           FCB    WHILETOK
  687 E309.EA8B                         FDB    XWHILE
  688 E30B.504F 4B45            POKE:   FCC    "POKE"
  689 E30F.00                           FCB    0
  690 E310.08                           FCB    POKETOK
  691 E311.E7FA                         FDB    XPOKE
  692 E313.4449 4D              DIM:    FCC    "DIM"
  693 E316.00                           FCB    0
  694 E317.09                           FCB    DIMTOK
  695 E318.EA58                         FDB    XDIM
  696 E31A.4545 50              EEP:    FCC    "EEP"
  697 E31D.00                           FCB    0
  698 E31E.1B                           FCB    EEPTOK
  699 E31F.E813                         FDB    XEEP
  700 E321.504F 5254 41         PORTA:  FCC    "PORTA"
  701 E326.00                           FCB    0
  702 E327.1C                           FCB    PORTATOK
  703 E328.E418                         FDB    XPORTA
  704 E32A.504F 5254 42         PORTB:  FCC    "PORTB"
  705 E32F.00                           FCB    0
  706 E330.1D                           FCB    PORTBTOK
  707 E331.E418                         FDB    XPORTB
  708 E333.504F 5254 43         PORTC:  FCC    "PORTC"
  709 E338.00                           FCB    0
  710 E339.1E                           FCB    PORTCTOK
  711 E33A.E418                         FDB    XPORTC
  712 E33C.504F 5254 44         PORTD:  FCC    "PORTD"
  713 E341.00                           FCB    0
  714 E342.1F                           FCB    PORTDTOK
  715 E343.E418                         FDB    XPORTD
  716 E345.494E 4259 5445       INBYTES:        FCC    "INBYTE"
  717 E34B.00                           FCB    0
  718 E34C.23                           FCB    INBYTTOK
  719 E34D.EA83                         FDB    XINBYTE
  720 E34F.5449 4D45            TIME:   FCC    "TIME"
  721 E353.00                           FCB    0
  722 E354.24                           FCB    TIMETOK
  723 E355.EA93                         FDB    XTIME
  724 E357.5245 5449            RETI:   FCC    "RETI"
  725 E35B.00                           FCB    0
  726 E35C.27                           FCB    RETITOK
  727 E35D.E3FB                         FDB    XRETI
  728 E35F.5041 4343            PACC:   FCC    "PACC"
  729 E363.00                           FCB    0
  730 E364.0B                           FCB    PACCTOK
  731 E365.EA93                         FDB    XPACC
  732 E367.534C 4545 50         SLEEP:  FCC    "SLEEP"
  733 E36C.00                           FCB    0
  734 E36D.29                           FCB    SLEEPTOK
  735 E36E.E3FB                         FDB    XSLEEP
  736 E370.5254 494D 45         RTIMES: FCC    "RTIME"
  737 E375.00                           FCB    0
  738 E376.2A                           FCB    RTIMETOK
  739 E377.E3FB                         FDB    XRTIME
  740 E379.00                           FCB    0           ; END OF TABLE MARKER.
  741                           
  742                           *blanks()
  743                           *{
  744                           * short spcnt;
  745                           * spcnt=0;
  746                           * while(*ibufptr==SPC) { ibufptr++; spcnt++; }
  747                           *
  748      E37A                 BLANKS: EQU    *
  749 E37A:3C              [ 4]         PSHX
  750 E37B:DE00            [ 4]         LDX    IBUFPTR
  751 E37D:5F              [ 2]         CLRB
  752 E37E:A600            [ 4] BLANKS1:        LDAA   0,X
  753 E380:8120            [ 2]         CMPA   #SPC
  754 E382:2604 (E388)     [ 3]         BNE    BLANKS2
  755 E384:5C              [ 2]         INCB
  756 E385:08              [ 3]         INX
  757 E386:20F6 (E37E)     [ 3]         BRA    BLANKS1
  758                           *
  759                           * if(spcnt==0) return;
  760                           *
  761 E388:5D              [ 2] BLANKS2:        TSTB
  762 E389:2602 (E38D)     [ 3]         BNE    BLANKS3
  763 E38B:38              [ 5]         PULX
  764 E38C:39              [ 5]         RTS
  765                           *
  766                           * if(spcnt>1)
  767                           *  {
  768                           *   *tbufptr++=MSCNTOK;
  769                           *   *tbufptr++=spcnt;
  770                           *  }
  771                           *
  772 E38D:DF00            [ 4] BLANKS3:        STX    IBUFPTR
  773 E38F:DE02            [ 4]         LDX    TBUFPTR
  774 E391:C101            [ 2]         CMPB   #1
  775 E393:270C (E3A1)     [ 3]         BEQ    BLANKS4
  776 E395:867F            [ 2]         LDAA   #MSCNTOK
  777 E397:A700            [ 4]         STAA   0,X
  778 E399:08              [ 3]         INX
  779 E39A:E700            [ 4] BLANKS5:        STAB   0,X
  780 E39C:08              [ 3]         INX
  781 E39D:DF02            [ 4]         STX    TBUFPTR
  782 E39F:38              [ 5]         PULX
  783 E3A0:39              [ 5]         RTS
  784                           *
  785                           * else
  786                           *  {
  787                           *   *tbufptr++=SSCNTOK;
  788                           *  }
  789                           * return;
  790                           *}
  791                           *
  792 E3A1:C67E            [ 2] BLANKS4:        LDAB   #SSCNTOK
  793 E3A3:20F5 (E39A)     [ 3]         BRA    BLANKS5
  794                           *
  795                           *
  796                           *<><><><><><><> NOTE: THIS FUNCTION NOT NEEDED <><><><><><><>
  797                           *
  798                           */**************************************
  799                           *             match()
  800                           * try to find match between *lit and
  801                           * *ibufptr. if match found, ibufptr is
  802                           * advanced to point beyond *lit. the
  803                           * string pointed to by lit must be null
  804                           * terminated.
  805                           ***************************************/
  806                           *
  807                           *match(lit)
  808                           *char *lit;
  809                           *{
  810                           * int k;
  811                           * if(k=streq(ibufptr,lit))
  812                           * {
  813                           *  ibufptr+=k;
  814                           *  return(1);
  815                           * }
  816                           * return(0);
  817                           *}
  818                                   
  819                           */****************************************
  820                           *               streq()
  821                           * compare srt1 to str2. str2 must be null
  822                           * terminated.
  823                           *****************************************/
  824                           *
  825                           *streq(str1,str2)
  826                           *char *str1,*str2;
  827                           *{
  828                           * int k;
  829                           * k=0;
  830                           * while(str2[k])         /* we're not at the end of string2 */
  831                           * {
  832                           *  if((str1[k])!=(str2[k])) return(0);
  833                           *  k++;
  834                           * }
  835                           * return(k);
  836                           *}
  837                           *
  838      E3A5                 STREQ:  EQU    *
  839 E3A5:DC00            [ 4]         LDD    IBUFPTR     ; SAVE VALUE OF POINTER.
  840                           *        PSHD
  841 E3A7:37              [ 3]         PSHB
  842 E3A8:36              [ 3]         PSHA
  843 E3A9:A600            [ 4] STREQU4:        LDAA   0,X
  844 E3AB:2712 (E3BF)     [ 3]         BEQ    STREQU2
  845 E3AD:8D1B (E3CA)     [ 6] STREQU1:        BSR    GETNXCHR
  846 E3AF:BDE0 FA         [ 6]         jsr    ToUpper  ; Make the character upper case.
  847 E3B2:A100            [ 4]         CMPA   0,X
  848 E3B4:2706 (E3BC)     [ 3]         BEQ    STREQU3
  849                           *        PULD
  850 E3B6:32              [ 4]         PULA
  851 E3B7:33              [ 4]         PULB
  852 E3B8:DD00            [ 4]         STD    IBUFPTR
  853 E3BA:0C              [ 2]         CLC
  854 E3BB:39              [ 5]         RTS
  855 E3BC:08              [ 3] STREQU3:        INX
  856 E3BD:20EA (E3A9)     [ 3]         BRA    STREQU4
  857 E3BF:32              [ 4] STREQU2:        PULA
  858 E3C0:33              [ 4]         PULB
  859 E3C1:0D              [ 2]         SEC
  860 E3C2:39              [ 5]         RTS
  861                           *
  862                           *
  863                           *        THIS ROUTINE GETS THE NEXT CHARACTER FROM THE INPUT BUFFER.
  864                           *
  865                           *
  866 E3C3:3C              [ 4] GETCHR: PSHX               ; SAVE THE X REGISTER.
  867 E3C4:DE00            [ 4]         LDX    IBUFPTR     ; GET POINTER.
  868 E3C6:A600            [ 4]         LDAA   0,X         ; GET A CHARACTER.
  869 E3C8:38              [ 5]         PULX               ; RESTORE X.
  870 E3C9:39              [ 5]         RTS                ; RETURN.
  871                           *
  872                           *
  873                           *        THIS ROUTINE GETS THE NEXT CHARACTER FROM THE INPUT BUFFER
  874                           *        AND ADVANCES THE POINTER TO POINT TO THE NEXT CHARACTER.
  875                           *
  876                           *
  877 E3CA:8DF7 (E3C3)     [ 6] GETNXCHR:       BSR    GETCHR
  878                           *                       FALL THROUGH TO INCIBP.
  879                           *
  880                           *
  881                           *        THIS ROUTINE JUST INCREMENTS THE INPUT BUFFER POINTER.
  882                           *
  883                           *
  884 E3CC:3C              [ 4] INCIBP: PSHX               ; SAVE X.
  885 E3CD:DE00            [ 4]         LDX    IBUFPTR     ; GET POINTER.
  886 E3CF:08              [ 3] INCIBP1:        INX                ; ADVANCE POINTER.
  887 E3D0:DF00            [ 4]         STX    IBUFPTR     ; UPDATE POINTER.
  888 E3D2:38              [ 5] INCIBP2:        PULX               ; RESTORE X
  889 E3D3:39              [ 5]         RTS                ; RETURN.
  890                           *
  891                           *
  892                           *        THIS ROUTINE PUTS THE WORD IN THE D-REG. INTO THE TOKEN BUFFER
  893                           *        AND ADVANCES THE TOKEN BUFFER POINTER.
  894                           *
  895                           *
  896 E3D4:8D01 (E3D7)     [ 6] PUTDTOK:        BSR    PUTTOK      ; PUT THE FIRST BYTE INTO THE TOKEN BUFFER.
  897 E3D6:17              [ 2]         TBA                ; PUT THE 2ND BYTE INTO A.
  898                           *                            ; FALL THROUGH TO PUTTOK.
  899                           *
  900                           *
  901                           *        THIS ROUTINE PUTS THE CHARACTER IN THE A-REG. INTO THE TOKEN
  902                           *        BUFFER AND ADVANCES THE TOKEN BUFFER POINTER.
  903                           *
  904                           *
  905 E3D7:3C              [ 4] PUTTOK: PSHX               ; SAVE X.
  906 E3D8:37              [ 3]         pshb
  907 E3D9:36              [ 3]         psha                                    ; (9/12/89).
  908 E3DA:DE02            [ 4]         LDX    TBUFPTR     ; GET POINTER.
  909 E3DC:A700            [ 4]         STAA   0,X         ; PUT CHARACTER.
  910 E3DE:08              [ 3] PUTTOK1:        INX                ; ADVANCE POINTER.
  911 E3DF:DF02            [ 4]         STX    TBUFPTR     ; SAVE POINTER.
  912                                   
  913 E3E1:DC4B            [ 4]         LDD    TKNBUFS     ; get the starting address of the token buffer.
  914 E3E3:C300 80         [ 4]         ADDD   #TBUFLEN    ; add the length of the buffer to it.
  915 E3E6:1A93 02         [ 6]         CPD    TBUFPTR     ; IS THE TOKEN BUFFER FULL?
  916 E3E9:32              [ 4]         pula                                    ; (9/12/89).
  917 E3EA:33              [ 4]         pulb               ; restore the b reg.
  918 E3EB:22E5 (E3D2)     [ 3]         BHI    INCIBP2     ; NO. RESTORE X AND RETURN.
  919 E3ED:8614            [ 2]         LDAA   #EXPCXERR   ; YES. FLAG THE ERROR.
  920 E3EF:7EEA 98         [ 3]         JMP    RPTERR      ; GO REPORT IT.
*** END   INCLUDE FILE: BASICLB1.ASM *** (RESUMING FILE: BASIC11.ASM)
    8                           #Include  'BASICLB2.Asm'
*** BEGIN INCLUDE FILE: BASICLB2.ASM ***
    1                           *        title    BASICLB2
    2                           *        page
    3                           *
    4                           *
    5                           *<><><><><><> NOTE: FUNCTION PERFORMED IN "XLATE" <><><><><><>
    6                           *
    7                           */***** xmideol() *****/
    8                           *
    9                           *xmideol()
   10                           *{
   11                           * *tbufptr++=MEOLTOK;
   12                           * ++ibufptr;
   13                           * return;
   14                           *}
   15                           *
   16                           *
   17                           *
   18                           */****** common code for GOSUB and GOTO *****/
   19                           *
   20                           *xgo(gotok)
   21                           *char gotok;
   22                           *{
   23                           * int num;
   24                           * *tbufptr++=gotok;      /* put GOTO or GOSUB token in buffer */
   25                           * blanks();              /* skip blanks before line number */
   26                           * *tbufptr++=LCONTOK;    /* put line number constant token in buffer */
   27                           * num=getlinum();        /* get line number */
   28                           * if(num==0) errcode=LINENERR;   /* if 0, line number error */
   29                           * if(errcode) return;    /* if error, return */
   30                           * putint(num);           /* put line number in buffer */
   31                           * return;
   32                           *}
   33                           *
   34      E3F2                 XGOSUB: EQU    *
   35      E3F2                 XGOTO:  EQU    *
   36                           *        JSR    BLANKS
   37 E3F2:86A8            [ 2]         LDAA   #LCONTOK
   38 E3F4:8DE1 (E3D7)     [ 6]         BSR    PUTTOK
   39 E3F6:BDE1 6C         [ 6]         JSR    GETLINUM
   40 E3F9:20D9 (E3D4)     [ 3] XGOTO2: BRA    PUTDTOK
   41                           *
   42                           *
   43                           *<><><><><><> ROUTINE NOT NEEDED <><><><><><>
   44                           *
   45                           */***** GOSUB *****/
   46                           *
   47                           *xgosub()
   48                           *{
   49                           * xgo(GOSUBTOK);
   50                           * return;
   51                           *}
   52                           *
   53                           *
   54                           *<><><><><><> ROUTINE NOT NEEDED <><><><><><>
   55                           *
   56                           */***** GOTO *****/
   57                           *
   58                           *xgoto()
   59                           *{
   60                           * xgo(GOTOTOK);
   61                           * return;
   62                           *}
   63                                   
   64                           */***** RETURN *****/
   65                           *
   66                           *xreturn()
   67                           *{
   68                           * *tbufptr++=RETNTOK;    /* put RETURN token in buffer */
   69                           * return;
   70                           *}
   71                           *
   72                           */***** STOP *****/
   73                           *
   74                           *xstop()
   75                           *{
   76                           * *tbufptr++=STOPTOK;    /* put STOP token in buffer */
   77                           * return;
   78                           *}
   79                           *
   80                           */***** END *****/
   81                           *
   82                           *xend()
   83                           *{
   84                           * *tbufptr++=ENDTOK;     /* put end token in buffer */
   85                           * return;
   86                           *}
   87                           *
   88                           */***** TRON *****/
   89                           *
   90                           *xtron()
   91                           *{
   92                           * *tbufptr++=TRONTOK;    /* put TRON token in buffer */
   93                           * return;
   94                           *}
   95                           *
   96                           */***** TROFF *****/
   97                           *
   98                           *xtroff()
   99                           *{
  100                           * *tbufptr++=TROFFTOK;   /* put TROFF token in buffer */
  101                           * return;
  102                           *}
  103                           *
  104      E3FB                 XRETURN:        EQU    *
  105      E3FB                 XSTOP:  EQU    *
  106      E3FB                 XEND:   EQU    *
  107      E3FB                 XTRON:  EQU    *
  108      E3FB                 XTROFF: EQU    *
  109      E3FB                 XRESTORE:       EQU    *
  110      E3FB                 XENDWH: EQU    *
  111      E3FB                 XRETI:  EQU    *
  112      E3FB                 XSLEEP: EQU    *
  113      E3FB                 XRTIME: EQU    *
  114 E3FB:39              [ 5]         RTS                ; NULL FUNCTIONS BECAUSE TOKEN PLACEMENT IS DONE IN
  115                           *                            ; XLATE FUNCTION.
  116                           *
  117                                   
  118                           */***** REM *****/
  119                           *
  120                           *xrem()
  121                           *{
  122                           * char c;
  123                           * *tbufptr++=REMTOK;     /* put rem token in buffer */
  124                           * while(1)
  125                           * {
  126                           *  if((c=*ibufptr)==EOL) break;
  127                           *  *tbufptr++=c;
  128                           *  ++ibufptr;
  129                           * }
  130                           * return;
  131                           *}
  132                           *
  133                           *
  134                           */***** xdata() *****/
  135                           *
  136                           *xdata()
  137                           *{
  138                           * char c;
  139                           * *tbufptr++=DATATOK;            /* put DATA token in buffer */
  140                           * while((c=*ibufptr)!=EOL)
  141                           * {
  142                           *  if(c==',') *tbufptr++=COMMATOK;
  143                           *  else *tbufptr++=c;
  144                           *  ++ibufptr;
  145                           * }
  146                           * return;
  147                           *}
  148                           *
  149      E3FC                 XDATA:  EQU    *
  150      E3FC                 XREM:   EQU    *
  151 E3FC:DE02            [ 4]         LDX    TBUFPTR      ; GET POINTER TO TOKEN BUFFER.
  152 E3FE:3C              [ 4]         PSHX                ; SAVE IT. (POINTER TO LENGTH OF REM OR DATA)
  153 E3FF:8600            [ 2]         LDAA   #0           ; SAVE A BYTE FOR THE LENGTH.
  154 E401:8DD4 (E3D7)     [ 6]         BSR    PUTTOK
  155 E403:C602            [ 2]         LDAB   #2           ; INITALIZE LENGTH  TO 2 (INCLUDES LENGTH & EOL.
  156 E405:8DBC (E3C3)     [ 6] XREM1:  BSR    GETCHR
  157 E407:810D            [ 2]         CMPA   #EOL
  158 E409:2707 (E412)     [ 3]         BEQ    XREM2
  159 E40B:8DCA (E3D7)     [ 6]         BSR    PUTTOK
  160 E40D:8DBD (E3CC)     [ 6]         BSR    INCIBP
  161 E40F:5C              [ 2]         INCB                ; UP THE BYTE COUNT.
  162 E410:20F3 (E405)     [ 3]         BRA    XREM1
  163 E412:8DC3 (E3D7)     [ 6] XREM2:  BSR    PUTTOK
  164 E414:38              [ 5]         PULX                ; GET POINTER TO LENGTH BYTE.
  165 E415:E700            [ 4]         STAB   0,X          ; PUT IT IN THE TOKEN BUFFER.
  166 E417:39              [ 5]         RTS
  167                           *
  168                           *
  169      E418                 XPORTA: EQU    *
  170      E418                 XPORTB: EQU    *
  171      E418                 XPORTC: EQU    *
  172      E418                 XPORTD: EQU    *
  173 E418:C601            [ 2]         LDAB   #NUM         ; WE'RE XLATING A NUMERICAL STATEMENT.
  174 E41A:2004 (E420)     [ 3]         BRA    ASIGNMT1     ; GO DO IT LIKE AN ASIGNMENT STATEMENT.
  175                           *
  176                           *
  177                           *
  178                           *
  179                                   
  180                           */***** LET *****/
  181                           *
  182                           *xlet()
  183                           *{
  184                           * letcom(LETTOK);                /* pass LET token to common code */
  185                           * return;
  186                           *}
  187                           *
  188                           */***** implied LET *****/
  189                           *
  190                           *ximplet()
  191                           *{
  192                           * letcom(IMLETTOK);
  193                           * return;
  194                           *}
  195                           *
  196                           */***** common code for explicit & implicit LET *****/
  197                           *
  198                           *letcom(letok)
  199                           *short letok;
  200                           *{
  201                           * *tbufptr++=letok;              /* put LET token in buffer */
  202                           * blanks();              /* skip blanks before assignment statement */
  203                           * if(ibufptr=='@') { *tbufptr++=INDIRTOK; ++ibufptr; }
  204                           * asignmt();                     /* evaluate expression */
  205                           * return;
  206                           *}
  207                           *
  208      E41C                 XLET:   EQU    *
  209      E41C                 XIMPLET:        EQU    *
  210                           *        JSR    BLANKS
  211                           *XLET1    JMP    ASIGNMT
  212                           *
  213                           *
  214                                   
  215                           */***** asignmt() *****/
  216                           *
  217                           *asignmt()
  218                           *{
  219                           *short type;
  220                           * if((type=getvar())==0) return; /* get variable & return type */
  221                           * if(errcode) return;
  222                           * if(*ibufptr++!='=') { errcode=IVEXPERR; return; } /* invalid expression */
  223                           * *tbufptr++=EQUALTOK;           /* put equals token in buffer */
  224                           * xexpres(type);                 /* build expression in token buffer */
  225                           * return;
  226                           *}
  227                           *
  228      E41C                 ASIGNMT:        EQU    *
  229 E41C:BDE5 57         [ 6]         JSR    GETVAR
  230 E41F:16              [ 2]         TAB
  231 E420:8DA8 (E3CA)     [ 6] ASIGNMT1:       BSR    GETNXCHR
  232 E422:813D            [ 2]         CMPA   #'='
  233 E424:2705 (E42B)     [ 3]         BEQ    ASIGNMT2
  234 E426:8603            [ 2]         LDAA   #IVEXPERR
  235 E428:7EEA 98         [ 3]         JMP    RPTERR
  236 E42B:8679            [ 2] ASIGNMT2:       LDAA   #EQUALTOK
  237 E42D:8DA8 (E3D7)     [ 6]         BSR    PUTTOK
  238 E42F:17              [ 2]         TBA
  239                           *                               FALL THROUGH TO XEXPRES.
  240                           *
  241                           *
  242                                   
  243                           */***** xexpres() *****/
  244                           *
  245                           *xexpres(type)
  246                           *short type;
  247                           *{
  248                           * char c;
  249                           * while(1)
  250                           * {
  251                           *  if(match("-")) *tbufptr++=NEGTOK;
  252                           *  else if(match("@")) *tbufptr++=INDIRTOK;
  253                           *  else if(match("NOT")) *tbufptr++=NOTTOK;
  254      E430                 XEXPRES:        EQU    *
  255 E430:183C            [ 5]         PSHY
  256 E432:36              [ 3]         PSHA
  257 E433:1830            [ 4]         TSY
  258 E435:CEE5 4E         [ 3] XEXPRS29:       LDX    #UINARYOP
  259 E438:BDE4 FD         [ 6]         JSR    TBLSRCH
  260 E43B:2402 (E43F)     [ 3]         BCC    XEXPRS30
  261 E43D:8D98 (E3D7)     [ 6]         BSR    PUTTOK
  262                           *
  263                           *  if(*ibufptr=='(')     /* open paren? */
  264                           *  {
  265                           *   *tbufptr++=OPARNTOK; /* put in token buffer */
  266                           *   ++ibufptr;           /* point to next char in input buffer */
  267                           *   xexpres(type);       /* go get sub expression */
  268                           *   if(errcode) return;
  269                           *   if(*ibufptr!=')') { errcode=UPARNERR; return; }
  270                           *   *tbufptr++=CPARNTOK; /* put it in the token buffer */
  271                           *   ++ibufptr;           /* point to the next char in the input buffer */
  272                           *   goto chkoprtr;
  273                           *  }
  274                           *
  275 E43F:BDE3 C3         [ 6] XEXPRS30:       JSR    GETCHR
  276 E442:8128            [ 2]         CMPA   #'('
  277 E444:2622 (E468)     [ 3]         BNE    XEXPRS1
  278 E446:BDE3 CC         [ 6]         JSR    INCIBP
  279 E449:8610            [ 2]         LDAA   #OPARNTOK
  280 E44B:BDE3 D7         [ 6]         JSR    PUTTOK
  281 E44E:18A6 00         [ 5]         LDAA   0,Y
  282 E451:BDE4 30         [ 6]         JSR    XEXPRES
  283 E454:BDE3 CA         [ 6] XEXPRS2:        JSR    GETNXCHR
  284 E457:8129            [ 2]         CMPA   #')'
  285 E459:2705 (E460)     [ 3]         BEQ    XEXPRS3
  286 E45B:8604            [ 2]         LDAA   #UPARNERR
  287 E45D:7EEA 98         [ 3]         JMP    RPTERR
  288 E460:8611            [ 2] XEXPRS3:        LDAA   #CPARNTOK
  289 E462:BDE3 D7         [ 6]         JSR    PUTTOK
  290 E465:7EE4 97         [ 3]         JMP    CHKOPRTR
  291                           *
  292                           *  if((numeric(*ibufptr)) | (*ibufptr=='$') | (*ibufptr=='"'))
  293                           *  {
  294                           *   c=getcon();
  295                           *   if(errcode) return;
  296                           *  }
  297                           *  else if(c=getfun()) ;
  298                           *  else (c=getvar()) ;
  299                           *  if(errcode) return;
  300                           *  if(type==NULL) type=c;
  301                           *  if(c!=type) { errcode=DTMISERR; return; }
  302                           *
  303      E468                 XEXPRS1:        EQU    *
  304 E468:BDE1 BB         [ 6]         JSR    NUMERIC
  305 E46B:2508 (E475)     [ 3]         BCS    XEXPRS4
  306 E46D:8124            [ 2]         CMPA   #'$'
  307 E46F:2704 (E475)     [ 3]         BEQ    XEXPRS4
  308 E471:8122            [ 2]         CMPA   #'"'
  309 E473:2605 (E47A)     [ 3]         BNE    XEXPRS5
  310 E475:BDE6 6C         [ 6] XEXPRS4:        JSR    GETCON
  311 E478:2009 (E483)     [ 3]         BRA    XEXPRS7
  312 E47A:BDE7 67         [ 6] XEXPRS5:        JSR    GETFUN
  313 E47D:4D              [ 2]         TSTA
  314 E47E:2603 (E483)     [ 3]         BNE    XEXPRS7
  315 E480:BDE5 57         [ 6]         JSR    GETVAR
  316 E483:18E6 00         [ 5] XEXPRS7:        LDAB   0,Y
  317 E486:C100            [ 2]         CMPB   #NULL
  318 E488:2603 (E48D)     [ 3]         BNE    XEXPRS8
  319 E48A:18A7 00         [ 5]         STAA   0,Y
  320 E48D:18A1 00         [ 5] XEXPRS8:        CMPA   0,Y
  321 E490:2705 (E497)     [ 3]         BEQ    XEXPRS9
  322 E492:8605            [ 2]         LDAA   #DTMISERR
  323 E494:7EEA 98         [ 3]         JMP    RPTERR
  324      E497                 XEXPRS9:        EQU    *
  325                           *
  326                           *
  327                           */* now look for operator or end of expression */
  328                           *
  329                           *  chkoprtr:
  330                           *  c=*ibufptr;
  331                           *  if(c==EOL | c==MIDEOL | c==SPC | c==COMMA | c==SEMI | c==')')
  332                           *  {
  333                           *   return(c);
  334                           *  }
  335                           *
  336      E497                 CHKOPRTR:       EQU    *
  337 E497:BDE3 C3         [ 6]         JSR    GETCHR
  338 E49A:810D            [ 2]         CMPA   #EOL
  339 E49C:2740 (E4DE)     [ 3]         BEQ    XEXPRS24
  340 E49E:813A            [ 2]         CMPA   #MIDEOL
  341 E4A0:273C (E4DE)     [ 3]         BEQ    XEXPRS24
  342 E4A2:8120            [ 2]         CMPA   #SPC
  343 E4A4:2738 (E4DE)     [ 3]         BEQ    XEXPRS24
  344 E4A6:812C            [ 2]         CMPA   #COMMA
  345 E4A8:2734 (E4DE)     [ 3]         BEQ    XEXPRS24
  346 E4AA:813B            [ 2]         CMPA   #SEMI
  347 E4AC:2730 (E4DE)     [ 3]         BEQ    XEXPRS24
  348 E4AE:8129            [ 2]         CMPA   #')'
  349 E4B0:272C (E4DE)     [ 3]         BEQ    XEXPRS24
  350                           *
  351                           *
  352                           *  if(type==NUM)
  353                           *  {
  354                           *   if(c=cknumop()) ;
  355                           *   else if(c=ckbolop()) ;
  356                           *   else if(ifwhflag) c=cklogop();
  357                           *   else c=NULL;
  358                           *  }
  359      E4B2                 XEXPRS15:       EQU    *
  360 E4B2:18A6 00         [ 5]         LDAA   0,Y
  361 E4B5:8101            [ 2]         CMPA   #NUM
  362 E4B7:2618 (E4D1)     [ 3]         BNE    XEXPRS21
  363 E4B9:BDE4 E8         [ 6]         JSR    CKNUMOP
  364 E4BC:2518 (E4D6)     [ 3]         BCS    XEXPRS17
  365 E4BE:BDE4 F3         [ 6]         JSR    CKBOLOP
  366 E4C1:2513 (E4D6)     [ 3]         BCS    XEXPRS17
  367 E4C3:7D00 1A         [ 6]         TST    IFWHFLAG
  368 E4C6:2705 (E4CD)     [ 3]         BEQ    XEXPRS18
  369 E4C8:BDE4 F8         [ 6]         JSR    CKLOGOP
  370 E4CB:2009 (E4D6)     [ 3]         BRA    XEXPRS17
  371 E4CD:8600            [ 2] XEXPRS18:       LDAA   #NULL
  372 E4CF:2005 (E4D6)     [ 3]         BRA    XEXPRS17
  373                           *
  374                           *
  375                           *  else { errcode=IDTYERR; return; }
  376                           *
  377      E4D1                 XEXPRS21:       EQU    *
  378 E4D1:8613            [ 2]         LDAA   #IDTYERR
  379 E4D3:7EEA 98         [ 3]         JMP    RPTERR
  380                           *
  381                           *
  382                           *  if(c==NULL) { errcode=OPRTRERR; return; }
  383                           *  *tbufptr++=c;
  384                           * }
  385                           * return;
  386                           *}
  387                           *
  388      E4D6                 XEXPRS17:       EQU    *
  389 E4D6:4D              [ 2]         TSTA
  390 E4D7:2609 (E4E2)     [ 3]         BNE    XEXPRS23
  391 E4D9:8606            [ 2]         LDAA   #OPRTRERR
  392 E4DB:7EEA 98         [ 3]         JMP    RPTERR
  393 E4DE:31              [ 3] XEXPRS24:       INS
  394 E4DF:1838            [ 6]         PULY
  395 E4E1:39              [ 5]         RTS
  396 E4E2:BDE3 D7         [ 6] XEXPRS23:       JSR    PUTTOK
  397 E4E5:7EE4 35         [ 3]         JMP    XEXPRS29
  398                           *
  399                           *
  400                           */***** cknumop() *****/
  401                           *
  402                           *cknumop()
  403                           *{
  404                           * if(match("+")) return(PLUSTOK);
  405                           * else if(match("-")) return(MINUSTOK);
  406                           * else if(match("*")) return(MULTTOK);
  407                           * else if(match("/")) return(DIVTOK);
  408                           * else if(match("\\")) return(MODTOK);
  409                           * else if(match("^")) return(PWRTOK);
  410                           * else return(NULL);
  411                           *}
  412                           *
  413      E4E8                 CKNUMOP:        EQU    *
  414 E4E8:CEE5 13         [ 3]         LDX    #NUMOPTBL
  415                           *
  416 E4EB:BDE4 FD         [ 6] CKOP:   JSR    TBLSRCH
  417 E4EE:2502 (E4F2)     [ 3]         BCS    CKOP1
  418 E4F0:8600            [ 2]         LDAA   #NULL
  419 E4F2:39              [ 5] CKOP1:  RTS
  420                           *
  421                           *
  422                                   
  423                           */***** ckbolop() *****/
  424                           *
  425                           *ckbolop()
  426                           *{
  427                           * if(match("AND")) return(ANDTOK);
  428                           * else if(match("OR")) return(ORTOK);
  429                           * else if(match("EOR")) return(EORTOK);
  430                           * else return(NULL);
  431                           *}
  432                           *
  433      E4F3                 CKBOLOP:        EQU    *
  434 E4F3:CEE5 23         [ 3]         LDX    #BOLOPTBL
  435 E4F6:20F3 (E4EB)     [ 3]         BRA    CKOP
  436                           *
  437                           *
  438                                   
  439                           */***** cklogop() *****/
  440                           *
  441                           *cklogop()
  442                           *{
  443                           * if(match("<=")) return(LTEQTOK);
  444                           * else if(match(">=")) return(GTEQTOK);
  445                           * else if(match("<>")) return(NOTEQTOK);
  446                           * else if(match("<")) return(LTTOK);
  447                           * else if(match(">")) return(GTTOK);
  448                           * else if(match("=")) return(EQTOK);
  449                           * else return(NULL);
  450                           *}
  451                           *
  452      E4F8                 CKLOGOP:        EQU    *
  453 E4F8:CEE5 38         [ 3]         LDX    #LOGOPTBL
  454 E4FB:20EE (E4EB)     [ 3]         BRA    CKOP
  455                           *
  456                           *
  457                           *
  458                           *
  459                           *<><><><><> NOTE: THIS ROUTINE HAS NO 'C' COUNTER PART <><><><><><>
  460                           *
  461      E4FD                 TBLSRCH:        EQU    *
  462 E4FD:BDE3 A5         [ 6]         JSR    STREQ        ; SEARCH FOR STRING.
  463 E500:250D (E50F)     [ 3]         BCS    TBLSRCH1     ; IF FOUND GO GET TOKEN & RETURN.
  464 E502:08              [ 3] TBLSRCH2:       INX                 ; BUMP POINTER TO NEXT CHAR.
  465 E503:A600            [ 4]         LDAA   0,X          ; GET IT.
  466 E505:26FB (E502)     [ 3]         BNE    TBLSRCH2     ; KEEP LOOKING FOR END OF ENTRY.
  467 E507:08              [ 3]         INX                 ; FOUND IT. BUMP POINTER TO NEXT ENTRY.
  468 E508:08              [ 3]         INX
  469 E509:A600            [ 4]         LDAA   0,X          ; AT THE END OF THE TABLE?
  470 E50B:26F0 (E4FD)     [ 3]         BNE    TBLSRCH      ; NO. GO CHECK THE NEXT ENTRY.
  471 E50D:0C              [ 2]         CLC                 ; YES. FLAG AS NOT FOUND.
  472 E50E:39              [ 5]         RTS                 ; RETURN.
  473 E50F:A601            [ 4] TBLSRCH1:       LDAA   1,X          ; GET TOKEN.
  474 E511:0D              [ 2]         SEC                 ; FLAG AS FOUND.
  475 E512:39              [ 5]         RTS                 ; RETURN.
  476                           *
  477                           *
  478      E513                 NUMOPTBL:       EQU    *
  479 E513.2B                   PLUS:   FCC    "+"
  480 E514.00                           FCB    0
  481 E515.40                           FCB    PLUSTOK
  482 E516.2D                   MINUS:  FCC    "-"
  483 E517.00                           FCB    0
  484 E518.41                           FCB    MINUSTOK
  485 E519.2A                   MULT:   FCC    "*"
  486 E51A.00                           FCB    0
  487 E51B.50                           FCB    MULTTOK
  488 E51C.2F                   DIV:    FCC    "/"
  489 E51D.00                           FCB    0
  490 E51E.51                           FCB    DIVTOK
  491 E51F.5C                   MODS:   FCB    $5C,$00
  491 E520.00                   
  492 E521.52                           FCB    MODTOK
  493 E522.00                           FCB    0            ; END OF TABLE FLAG.
  494                           *
  495      E523                 BOLOPTBL:       EQU    *
  496 E523.2E41 4E44 2E         ANDS:   FCC    ".AND."
  497 E528.00                           FCB    0
  498 E529.20                           FCB    ANDTOK
  499 E52A.2E4F 522E            ORS:    FCC    ".OR."
  500 E52E.00                           FCB    0
  501 E52F.21                           FCB    ORTOK
  502 E530.2E45 4F52 2E         EORS:   FCC    ".EOR."
  503 E535.00                           FCB    0
  504 E536.22                           FCB    EORTOK
  505 E537.00                           FCB    0            ; END OF TABLE FLAG.
  506                           *
  507      E538                 LOGOPTBL:       EQU    *
  508 E538.3C3D                 LTEQ:   FCC    "<="
  509 E53A.00                           FCB    0
  510 E53B.32                           FCB    LTEQTOK
  511 E53C.3E3D                 GTEQ:   FCC    ">="
  512 E53E.00                           FCB    0
  513 E53F.33                           FCB    GTEQTOK
  514 E540.3C3E                 NOTEQ:  FCC    "<>"
  515 E542.00                           FCB    0
  516 E543.35                           FCB    NOTEQTOK
  517 E544.3C                   LT:     FCC    "<"
  518 E545.00                           FCB    0
  519 E546.30                           FCB    LTTOK
  520 E547.3E                   GT:     FCC    ">"
  521 E548.00                           FCB    0
  522 E549.31                           FCB    GTTOK
  523 E54A.3D                   EQ:     FCC    "="
  524 E54B.00                           FCB    0
  525 E54C.34                           FCB    EQTOK
  526 E54D.00                           FCB    0            ; END OF TABLE FLAG.
  527                           *
  528                           *
  529      E54E                 UINARYOP:       EQU    *
  530 E54E.2D                   NEGS:   FCC    "-"
  531 E54F.00                           FCB    0
  532 E550.72                           FCB    NEGTOK
  533 E551.4E4F 54              NOTS:   FCC    "NOT"
  534 E554.00                           FCB    0
  535 E555.71                           FCB    NOTTOK
  536 E556.00                           FCB    0            ; END OF TABLE MARKER.
  537                           *
*** END   INCLUDE FILE: BASICLB2.ASM *** (RESUMING FILE: BASIC11.ASM)
    9                           #Include  'BASICLB3.Asm'
*** BEGIN INCLUDE FILE: BASICLB3.ASM ***
    1                           *        title    BASICLB3
    2                           *        page
    3                           *
    4                           *
    5                           */***** getvar *****/
    6                           *
    7                           */* tries to make a variable out of what is currently being pointed to by */
    8                           */* 'ibufptr' and places it into the variable symbol table if it is not   */
    9                           */* already there */
   10                           *
   11                           *getvar()
   12                           *{
   13                           * short vartype,cnt;
   14                           * char varname[3];
   15                           * int offset;
   16                           * for(cnt=0; cnt<=2; cnt++) { varname[cnt]=0; } /* clr out var name */
   17                           * if(alpha(*ibufptr)) { varname[0]=*ibufptr++; } /* is 1st char an alpha? */
   18                           *  else { errcode=ILVARERR; return(0); } /* no. error */
   19                           *
   20      E557                 GETVAR: EQU    *
   21 E557:183C            [ 5]         PSHY
   22 E559:4F              [ 2]         CLRA
   23 E55A:36              [ 3]         PSHA
   24 E55B:36              [ 3]         PSHA
   25 E55C:36              [ 3]         PSHA
   26 E55D:36              [ 3]         PSHA
   27 E55E:1830            [ 4]         TSY
   28 E560:BDE3 C3         [ 6]         JSR    GETCHR
   29 E563:BDE1 C7         [ 6]         JSR    ALPHA
   30 E566:2505 (E56D)     [ 3]         BCS    GETVAR1
   31 E568:8607            [ 2]         LDAA   #ILVARERR
   32 E56A:7EEA 98         [ 3]         JMP    RPTERR
   33 E56D:BDE0 FA         [ 6] GETVAR1:        jsr    ToUpper
   34 E570:18A7 00         [ 5]         STAA   0,Y
   35 E573:BDE3 CC         [ 6]         JSR    INCIBP
   36                           *
   37                           *
   38                           * if(alphanum(*ibufptr)) { varname[1]=*ibufptr++; }
   39                           * if((vartype=chcktyp())==0) { vartype=FVARTOK; }
   40                           *  else { ++ibufptr; }
   41                           *
   42 E576:BDE3 C3         [ 6]         JSR    GETCHR
   43 E579:BDE1 DB         [ 6]         JSR    ALPHANUM
   44 E57C:2409 (E587)     [ 3]         BCC    GETVAR2
   45 E57E:BDE0 FA         [ 6]         jsr    ToUpper
   46 E581:18A7 01         [ 5]         STAA   1,Y
   47 E584:BDE3 CC         [ 6]         JSR    INCIBP
   48 E587:BDE5 E0         [ 6] GETVAR2:        JSR    CHCKTYP
   49 E58A:18A7 03         [ 5]         STAA   3,Y
   50                           *
   51                           *
   52                           * if((offset=findvar(vartype,varname))==-1) /* is var already in table? */
   53                           * {
   54                           *  if(errcode) return;
   55                           *  if((offset=putvar(vartype,varname))==-1) return;  /* no. put it there */
   56                           * }
   57                           * if(errcode) return;
   58                           *
   59 E58D:BDE5 EE         [ 6]         JSR    FINDVAR
   60 E590:1A83 FFFF       [ 5]         CPD    #-1
   61 E594:2606 (E59C)     [ 3]         BNE    GETVAR5
   62 E596:18A6 03         [ 5] GETVAR4:        LDAA   3,Y
   63 E599:BDE6 26         [ 6]         JSR    PUTVAR
   64                           *
   65                           *
   66                           * *tbufptr++=vartype;    /* put variable type byte in token buffer */
   67                           * putint(offset);        /* put offset after it */
   68                           * if((vartype==IVARTOK) | (vartype==FVARTOK)) return(NUM);
   69                           * return(STRING);
   70                           *}
   71                           *
   72      E59C                 GETVAR5:        EQU    *
   73                           *        PSHD
   74 E59C:37              [ 3]         PSHB
   75 E59D:36              [ 3]         PSHA
   76 E59E:18A6 03         [ 5]         LDAA   3,Y
   77 E5A1:BDE3 D7         [ 6]         JSR    PUTTOK
   78                           *        PULD
   79 E5A4:32              [ 4]         PULA
   80 E5A5:33              [ 4]         PULB
   81 E5A6:BDE3 D4         [ 6]         JSR    PUTDTOK
   82 E5A9:18A6 03         [ 5]         LDAA   3,Y           ; GET VARIABLE TYPE AGAIN.
   83 E5AC:8510            [ 2]         BITA   #$10          ; IS IT AN ARRAY VARIABLE?
   84 E5AE:271E (E5CE)     [ 3]         BEQ    GETVAR7       ; NO. CONTINUE.
   85 E5B0:BDE3 CC         [ 6]         JSR    INCIBP        ; MOVE THE INPUT BUFFER POINTER PAST THE OPEN (.
   86 E5B3:8610            [ 2]         LDAA   #OPARNTOK
   87 E5B5:BDE3 D7         [ 6]         JSR    PUTTOK
   88 E5B8:8601            [ 2]         LDAA   #NUM          ; YES. SUBSCRIPT EXPRESSION MUST BE NUMERIC.
   89 E5BA:BDE4 30         [ 6]         JSR    XEXPRES       ; GO GET THE SUBSCRIPT.
   90 E5BD:BDE3 CA         [ 6]         JSR    GETNXCHR      ; GET THE TERMINATING CHARACTER.
   91 E5C0:8129            [ 2]         CMPA   #')'          ; IS IT A CLOSING PAREN?
   92 E5C2:2705 (E5C9)     [ 3]         BEQ    GETVAR8       ; YES. GO FINISH UP.
   93 E5C4:860E            [ 2]         LDAA   #MPARNERR     ; NO. ERROR.
   94 E5C6:7EEA 98         [ 3]         JMP    RPTERR
   95 E5C9:8611            [ 2] GETVAR8:        LDAA   #CPARNTOK     ; GET CLOSING PAREN TOKEN.
   96 E5CB:BDE3 D7         [ 6]         JSR    PUTTOK        ; PUT TOKEN IN BUFFER.
   97 E5CE:8601            [ 2] GETVAR7:        LDAA   #NUM          ; NO. RETURN PROPER TYPE.
   98 E5D0:18E6 03         [ 5]         LDAB   3,Y
   99 E5D3:C502            [ 2]         BITB   #2
  100 E5D5:2702 (E5D9)     [ 3]         BEQ    GETVAR6
  101 E5D7:8602            [ 2]         LDAA   #STRING
  102 E5D9:31              [ 3] GETVAR6:        INS
  103 E5DA:31              [ 3]         INS
  104 E5DB:31              [ 3]         INS
  105 E5DC:31              [ 3]         INS
  106 E5DD:1838            [ 6]         PULY
  107 E5DF:39              [ 5]         RTS
  108                           *
  109                           *
  110                           *
  111                           */***** chcktype *****/
  112                           *
  113                           *chcktyp()
  114                           *{
  115                           * if(*ibufptr=='%') return(IVARTOK);
  116                           *  else if(*ibufptr=='$') return(SVARTOK);
  117                           *  else return(0);
  118                           *}
  119                           *
  120      E5E0                 CHCKTYP:        EQU    *
  121 E5E0:8684            [ 2]         LDAA   #IVARTOK        ; IN V1.0 ONLY INTEGER VARIABLES ARE SUPPORTED.
  122 E5E2:36              [ 3]         PSHA                   ; IN V2.0 FLOATING POINT VARIABLES WILL BE
  123 E5E3:BDE3 C3         [ 6]         JSR    GETCHR          ; SUPPORTED.
  124 E5E6:8128            [ 2]         CMPA   #'('            ; IS A SUBSCRIPT FOLLOWING THE NAME?
  125 E5E8:32              [ 4]         PULA                   ; RESTORE THE TOKEN TYPE.
  126 E5E9:2602 (E5ED)     [ 3]         BNE    CHCKTYP4        ; NO. RETURN.
  127 E5EB:8B10            [ 2]         ADDA   #$10            ; YES. MAKE IT AN ARRAY VARIABLE.
  128 E5ED:39              [ 5] CHCKTYP4:       RTS                    ; RETURN.
  129                           *
  130                           */***** findvar *****/
  131                           *
  132                           *findvar(vartype,varname)
  133                           *short vartype;
  134                           *char *varname;
  135                           *{
  136                           * char *varptr;
  137                           * varptr=varbegin;               /* point to the start of the var table */
  138                           * while(*varptr)                 /* we're not to the end of the table */
  139                           *
  140      E5EE                 FINDVAR:        EQU    *
  141 E5EE:DE08            [ 4]         LDX    VARBEGIN
  142 E5F0:6D00            [ 6] FINDVAR1:       TST    0,X
  143 E5F2:272E (E622)     [ 3]         BEQ    FINDVAR2
  144                           *
  145                           * {
  146                           *  if(*varptr==vartype)          /* is the current var the same type? */
  147                           *  {                             /* yes. */
  148                           *   if(streq(varptr+1,varname))  /* is the name the same? */
  149                           *   {                            /* yes. */
  150                           *    return(varptr-varbegin);    /* return the offset from the table start */
  151                           *   }
  152                           *  }
  153                           *
  154 E5F4:A100            [ 4]         CMPA   0,X
  155 E5F6:2612 (E60A)     [ 3]         BNE    FINDVAR3
  156 E5F8:E601            [ 4]         LDAB   1,X
  157 E5FA:18E1 00         [ 5]         CMPB   0,Y
  158 E5FD:260B (E60A)     [ 3]         BNE    FINDVAR3
  159 E5FF:E602            [ 4]         LDAB   2,X
  160 E601:18E1 01         [ 5]         CMPB   1,Y
  161 E604:2604 (E60A)     [ 3]         BNE    FINDVAR3
  162 E606:8F              [ 3]         XGDX
  163 E607:9308            [ 5]         SUBD   VARBEGIN
  164 E609:39              [ 5]         RTS
  165                           *
  166                           *  /* if not, advance to the next variable in the table */
  167                           *  if(*varptr==IVARTOK) varptr=varptr+ISIZ+3;
  168                           *  else if(*varptr==SVARTOK) varptr=varptr+SSIZ+3;
  169                           *  else if(*varptr==FVARTOK) varptr=varptr+FSIZ+3;
  170                           *  else { errcode=ILTOKERR; return(-1); }
  171                           * }
  172                           *
  173      E60A                 FINDVAR3:       EQU    *
  174 E60A:E600            [ 4]         LDAB   0,X
  175 E60C:C510            [ 2]         BITB   #$10          ; IS IT AN ARRAY VARIABLE?
  176 E60E:2704 (E614)     [ 3]         BEQ    FINDVAR8      ; NO CONTINUE.
  177 E610:C605            [ 2]         LDAB   #ASIZ+3       ; YES. GET ARRAY SIZE +3.
  178 E612:2006 (E61A)     [ 3]         BRA    FINDVAR7
  179 E614:C184            [ 2] FINDVAR8:       CMPB   #IVARTOK
  180 E616:2605 (E61D)     [ 3]         BNE    FINDVAR6
  181 E618:C605            [ 2]         LDAB   #ISIZ+3
  182 E61A:3A              [ 3] FINDVAR7:       ABX
  183 E61B:20D3 (E5F0)     [ 3]         BRA    FINDVAR1
  184 E61D:8608            [ 2] FINDVAR6:       LDAA   #ILTOKERR
  185 E61F:7EEA 98         [ 3]         JMP    RPTERR
  186 E622:CCFF FF         [ 3] FINDVAR2:       LDD    #-1
  187 E625:39              [ 5]         RTS
  188                           *
  189                           * return(-1);
  190                           *}
  191                           *
  192                           *
  193                           *
  194                           */***** putvar *****/
  195                           *
  196                           *putvar(vartype,varname)
  197                           *short vartype;
  198                           *char *varname;
  199                           *{
  200                           *short count,n;
  201                           *char *varadd;
  202                           * varadd=varend;         /* save begining addr of var we are storing */
  203                           * *varend++=vartype;     /* put token/type in variable symbol table */
  204                           * *varend++=*varname++;  /* put variable name in */
  205                           * *varend++=*varname++;
  206                           *
  207      E626                 PUTVAR: EQU    *
  208 E626:DE0A            [ 4]         LDX    VAREND
  209 E628:3C              [ 4]         PSHX
  210 E629:A700            [ 4]         STAA   0,X
  211 E62B:08              [ 3]         INX
  212 E62C:18E6 00         [ 5]         LDAB   0,Y
  213 E62F:E700            [ 4]         STAB   0,X
  214 E631:08              [ 3]         INX
  215 E632:18E6 01         [ 5]         LDAB   1,Y
  216 E635:E700            [ 4]         STAB   0,X
  217 E637:08              [ 3]         INX
  218                           *
  219                           * if(vartype==IVARTOK) count=ISIZ+1;     /* determine # of bytes for this */
  220                           * else if(vartype==SVARTOK) count=SSIZ+1;/* variable */
  221                           * else if(vartype==FVARTOK) count=FSIZ+1;
  222                           * else { errcode=ILTOKERR; return(-1); }
  223                           * for(n=1;n<=count;n++) *varend++=0;      /* zero the storage */
  224                           * --varend;
  225                           * if(varend > varmend) { errcode=OMEMERR; return(-1); } /* memory overflow? */
  226                           * vmemavil-=count;       /* decrement the amt of avail memory */
  227                           * return(varadd-varbegin);       /* return offset */
  228                           *}
  229                           *
  230 E638:8D18 (E652)     [ 6]         BSR    CLRVAR
  231 E63A:6F00            [ 6]         CLR    0,X          ; CLEAR 1 BYTE BEYOND THE END OF THE VAR AREA.
  232 E63C:DF0A            [ 4]         STX    VAREND
  233 E63E:9C10            [ 5]         CPX    VARMEND
  234 E640:2304 (E646)     [ 3]         BLS    PUTVAR5
  235 E642:8609            [ 2]         LDAA   #OMEMERR
  236 E644:2023 (E669)     [ 3]         BRA    CLRVAR6
  237      E646                 PUTVAR5:        EQU    *
  238                           *        PULD
  239 E646:32              [ 4]         PULA
  240 E647:33              [ 4]         PULB
  241 E648:9308            [ 5]         SUBD   VARBEGIN
  242                           *        PSHD                ; SAVE THE OFFSET TO THIS VARIABLE.
  243 E64A:37              [ 3]         PSHB
  244 E64B:36              [ 3]         PSHA
  245 E64C:BDF2 DE         [ 6]         JSR    CCLEAR3      ; CLEAR ALL VARIABLES SINCE WE MAY HAVE TRASHED
  246                           *                            ANY ARRAYS THAT HAD BEEN ALLOCATED.
  247                           *        PULD                RESTORE THE "NEW" VARIABLE OFFSET.
  248 E64F:32              [ 4]         PULA
  249 E650:33              [ 4]         PULB
  250 E651:39              [ 5]         RTS
  251                           *
  252                           *
  253      E652                 CLRVAR: EQU    *
  254 E652:8510            [ 2]         BITA   #$10          ; IS IT AN ARRAY VARIABLE?
  255 E654:2704 (E65A)     [ 3]         BEQ    CLRVAR8       ; NO. CONTINUE.
  256 E656:C602            [ 2]         LDAB   #ASIZ         ; YES. GET THE DICTIONARY SIZE+1.
  257 E658:2006 (E660)     [ 3]         BRA    CLRVAR1       ; PUT THE VARIABLE IN THE DICTIONARY.
  258 E65A:8184            [ 2] CLRVAR8:        CMPA   #IVARTOK
  259 E65C:2609 (E667)     [ 3]         BNE    CLRVAR4
  260 E65E:C602            [ 2]         LDAB   #ISIZ
  261      E660                 CLRVAR1:        EQU    *
  262 E660:6F00            [ 6]         CLR    0,X
  263 E662:08              [ 3]         INX
  264 E663:5A              [ 2]         DECB
  265 E664:26FA (E660)     [ 3]         BNE    CLRVAR1
  266 E666:39              [ 5]         RTS
  267 E667:8608            [ 2] CLRVAR4:        LDAA   #ILTOKERR
  268 E669:7EEA 98         [ 3] CLRVAR6:        JMP    RPTERR
  269                           *
  270                           *
  271                           */***** getcon() *****/
  272                           *
  273                           *getcon()
  274                           *{
  275                           * int const;
  276                           * char *litp;
  277                           * short count;
  278                           * litp=ibufptr;          /* save a pointer to start of constant */
  279                           * if(*ibufptr=='"') { getscon(); return(STRING); } /* if " get strng */
  280                           *
  281      E66C                 GETCON: EQU    *
  282 E66C:BDE3 C3         [ 6]         JSR    GETCHR
  283                           *
  284                           *
  285                           *  else if(*ibufptr=='$') { ++ibufptr; const=gethex(); } /* if '$' get hex */
  286                           *  else const=getdeci();         /* else assume its a decimal constant */
  287                           * if(errcode) return(0);         /* if error abort */
  288                           *
  289      E66F                 GETCON2:        EQU    *
  290 E66F:DE00            [ 4]         LDX    IBUFPTR
  291 E671:3C              [ 4]         PSHX
  292 E672:8124            [ 2]         CMPA   #'$'
  293 E674:2608 (E67E)     [ 3]         BNE    GETCON3
  294 E676:BDE3 CC         [ 6]         JSR    INCIBP
  295 E679:BDE6 CF         [ 6]         JSR    GETHEX
  296 E67C:2003 (E681)     [ 3]         BRA    GETCON4
  297 E67E:BDE6 A1         [ 6] GETCON3:        JSR    GETDECI
  298                           *
  299                           *
  300                           * *tbufptr++=ICONTOK;            /* put integer constant token in buffer */
  301                           * putint(const);                 /* follow it with the constant */
  302                           * count=ibufptr-litp;    /* get number of bytes in source form of const. */
  303                           * *tbufptr++=count;       /* put it in the token buffer */
  304                           * while(litp < ibufptr) *tbufptr++=*litp++; /* copy source form into buffer */
  305                           * return(NUM);           /* return the constant type */
  306                           * }
  307                           *
  308      E681                 GETCON4:        EQU    *
  309 E681:36              [ 3]         PSHA
  310 E682:86A4            [ 2]         LDAA   #ICONTOK
  311 E684:BDE3 D7         [ 6]         JSR    PUTTOK
  312 E687:32              [ 4]         PULA
  313 E688:BDE3 D4         [ 6]         JSR    PUTDTOK
  314 E68B:DC00            [ 4]         LDD    IBUFPTR
  315 E68D:30              [ 3]         TSX
  316 E68E:A300            [ 6]         SUBD   0,X
  317 E690:17              [ 2]         TBA
  318 E691:BDE3 D7         [ 6]         JSR    PUTTOK
  319 E694:38              [ 5]         PULX
  320 E695:A600            [ 4] GETCON5:        LDAA   0,X
  321 E697:BDE3 D7         [ 6]         JSR    PUTTOK
  322 E69A:08              [ 3]         INX
  323 E69B:5A              [ 2]         DECB
  324 E69C:26F7 (E695)     [ 3]         BNE    GETCON5
  325 E69E:8601            [ 2]         LDAA   #NUM
  326 E6A0:39              [ 5]         RTS
  327                           *
  328                           *
  329                           */***** getdeci() *****/
  330                           *
  331                           *getdeci()
  332                           *{
  333                           * char c;
  334                           * int num;
  335                           * num=0;
  336                           * if(numeric(*ibufptr)==0)       /* is 1st char numeric? */
  337                           *  { errcode=SYTXERR; return; }  /* no. flag error & return */
  338                           * while(numeric(c=*ibufptr))     /* yes. while *ibufptr is numeric */
  339                           * {
  340                           *  num=num*10+(c-'0');           /* build number */
  341                           *  if(num < 0) { errcode=INTOVERR; return; }     /* if <0 flag error & ret */
  342                           *  ++ibufptr;
  343                           * }
  344                           * return(num);           /* return the value */
  345                           *}
  346                           *
  347      E6A1                 GETDECI:        EQU    *
  348 E6A1:183C            [ 5]         PSHY
  349 E6A3:4F              [ 2]         CLRA
  350 E6A4:36              [ 3]         PSHA
  351 E6A5:36              [ 3]         PSHA
  352 E6A6:1830            [ 4]         TSY
  353 E6A8:DE00            [ 4]         LDX    IBUFPTR
  354 E6AA:A600            [ 4]         LDAA   0,X
  355 E6AC:BDE1 BB         [ 6]         JSR    NUMERIC
  356 E6AF:2504 (E6B5)     [ 3]         BCS    GETDECI1
  357 E6B1:8602            [ 2]         LDAA   #SYTXERR
  358 E6B3:202C (E6E1)     [ 3]         BRA    CHCKERR
  359 E6B5:A600            [ 4] GETDECI1:       LDAA   0,X
  360 E6B7:BDE1 BB         [ 6]         JSR    NUMERIC
  361 E6BA:2409 (E6C5)     [ 3]         BCC    GETDECI3
  362 E6BC:BDE1 9B         [ 6]         JSR    ADDDIG
  363 E6BF:2AF4 (E6B5)     [ 3]         BPL    GETDECI1
  364 E6C1:860A            [ 2]         LDAA   #INTOVERR
  365 E6C3:201C (E6E1)     [ 3]         BRA    CHCKERR
  366 E6C5:DF00            [ 4] GETDECI3:       STX    IBUFPTR
  367 E6C7:18EC 00         [ 6]         LDD    0,Y
  368 E6CA:31              [ 3]         INS
  369 E6CB:31              [ 3]         INS
  370 E6CC:1838            [ 6]         PULY
  371 E6CE:39              [ 5]         RTS
  372                           *
  373                           *
  374                           */***** gethex() *****/
  375                           *
  376                           *gethex()
  377                           *{
  378                           * char c;
  379                           * short count;
  380                           * int num;
  381                           * num=count=0;
  382                           * if(hexdig(*ibufptr)==0)        /* is the char a hex digit? */
  383                           *  { errcode=IVHEXERR; return; } /* no. flag error & return */
  384                           *
  385      E6CF                 GETHEX: EQU    *
  386 E6CF:183C            [ 5]         PSHY
  387 E6D1:4F              [ 2]         CLRA
  388 E6D2:36              [ 3]         PSHA
  389 E6D3:36              [ 3]         PSHA
  390 E6D4:1830            [ 4]         TSY
  391 E6D6:DE00            [ 4]         LDX    IBUFPTR
  392 E6D8:A600            [ 4]         LDAA   0,X
  393 E6DA:BDE7 21         [ 6]         JSR    HEXDIG
  394 E6DD:250D (E6EC)     [ 3]         BCS    GETHEX1
  395 E6DF:860B            [ 2]         LDAA   #IVHEXERR
  396 E6E1:7D00 1D         [ 6] CHCKERR:        TST    RUNFLAG
  397 E6E4:2703 (E6E9)     [ 3]         BEQ    GETHEX5
  398 E6E6:7EEA EF         [ 3]         JMP    RPTRERR
  399 E6E9:7EEA 98         [ 3] GETHEX5:        JMP    RPTERR
  400                           *
  401                           *
  402                           * while(hexdig(c=*ibufptr))      /* while a hex digit is in the buffer */
  403                           * {
  404                           *  if(numeric(c)) num=num*16+(c-'0');  /* build the number */
  405                           *   else num=num*16+(c-55);
  406                           *  if(count++ > 4)
  407                           *   { errcode=HEXOVERR; return; }  /* if over 4 digits flag overflow & ret */
  408                           *  ++ibufptr;
  409                           * }
  410                           * return(num);   /* return constant value */
  411                           *}
  412                           *
  413      E6EC                 GETHEX1:        EQU    *
  414 E6EC:A600            [ 4]         LDAA   0,X
  415 E6EE:BDE7 21         [ 6]         JSR    HEXDIG
  416 E6F1:24D2 (E6C5)     [ 3]         BCC    GETDECI3
  417 E6F3:18EC 00         [ 6]         LDD    0,Y
  418 E6F6:05              [ 3]         LSLD
  419 E6F7:2524 (E71D)     [ 3]         BCS    GETHEX3
  420 E6F9:05              [ 3]         LSLD
  421 E6FA:2521 (E71D)     [ 3]         BCS    GETHEX3
  422 E6FC:05              [ 3]         LSLD
  423 E6FD:251E (E71D)     [ 3]         BCS    GETHEX3
  424 E6FF:05              [ 3]         LSLD
  425 E700:251B (E71D)     [ 3]         BCS    GETHEX3
  426 E702:18ED 00         [ 6]         STD    0,Y
  427 E705:A600            [ 4]         LDAA   0,X
  428 E707:BDE0 FA         [ 6]          JSR    ToUpper
  429 E70A:16              [ 2]          TAB
  430 E70B:08              [ 3]         INX
  431 E70C:C030            [ 2]         SUBB   #'0'
  432 E70E:C109            [ 2]         CMPB   #9
  433 E710:2302 (E714)     [ 3]         BLS    GETHEX4
  434 E712:C007            [ 2]         SUBB   #7
  435 E714:4F              [ 2] GETHEX4:        CLRA
  436 E715:18E3 00         [ 7]         ADDD   0,Y
  437 E718:18ED 00         [ 6]         STD    0,Y
  438 E71B:20CF (E6EC)     [ 3]         BRA    GETHEX1
  439 E71D:860C            [ 2] GETHEX3:        LDAA   #HEXOVERR
  440 E71F:20C0 (E6E1)     [ 3]         BRA    CHCKERR
  441                           *
  442                           *
  443                           */***** hexdig() *****/
  444                           *
  445                           *hexdig(c)
  446                           *char c;
  447                           *{
  448                           * return(numeric(c) | (c>='A' & c<='F')); /* return true if c is hex */
  449                           *}
  450                           *
  451      E721                 HEXDIG: EQU    *
  452 E721:BDE1 BB         [ 6]         JSR    NUMERIC
  453 E724:2401 (E727)     [ 3]         BCC    HEXDIG1
  454 E726:39              [ 5]         RTS
  455 E727:BDE0 FA         [ 6] HEXDIG1:        JSR    ToUpper
  456 E72A:8141            [ 2]         CMPA   #'A'
  457 E72C:2506 (E734)     [ 3]         BLO    HEXDIG2
  458 E72E:8146            [ 2]         CMPA   #'F'
  459 E730:2202 (E734)     [ 3]         BHI    HEXDIG2
  460 E732:0D              [ 2]         SEC
  461 E733:39              [ 5]         RTS
  462 E734:0C              [ 2] HEXDIG2:        CLC
  463 E735:39              [ 5]         RTS
  464                           *
  465                           *
  466                           */***** getscon *****/
  467                           *
  468                           *getscon()
  469                           *{
  470                           * short count;
  471                           * char *bufptr,c;
  472                           * count=2;       /* initalize byte count to 2 */
  473                           * *tbufptr++=SCONTOK;   /* put string constant token in buffer */
  474                           * bufptr=tbufptr++;   /* save value of tbufptr, advance to next byte, */
  475                           *                     /* and reserve a byte for string length */
  476                           * *tbufptr++=*ibufptr++;   /* put 1st quote in token buffer */
  477                           *
  478      E736                 GETSCON:        EQU    *
  479 E736:C602            [ 2]         LDAB   #2
  480 E738:86A2            [ 2]         LDAA   #SCONTOK
  481 E73A:BDE3 D7         [ 6]         JSR    PUTTOK
  482 E73D:DE02            [ 4]         LDX    TBUFPTR
  483 E73F:3C              [ 4]         PSHX
  484 E740:4F              [ 2]         CLRA
  485 E741:BDE3 D7         [ 6]         JSR    PUTTOK
  486 E744:BDE3 CA         [ 6]         JSR    GETNXCHR     ; PUT FIRST QUOTE IN TOKEN BUFFER.
  487 E747:BDE3 D7         [ 6]         JSR    PUTTOK
  488                           *
  489                           *
  490                           * while(((c=*ibufptr) != '"'))
  491                           * {
  492                           *  if(c==EOL)             /* if we hit EOL */
  493                           *   { errcode=MISQUERR; return; } /* flag error & return */
  494                           *  *tbufptr++=c;         /* if not, put next char in buffer */
  495                           *  ++ibufptr;            /* advance input buffer pointer */
  496                           *  ++count;              /* up byte count */
  497                           * }
  498                           *
  499      E74A                 GETSCON1:       EQU    *
  500 E74A:BDE3 CA         [ 6]         JSR    GETNXCHR
  501 E74D:8122            [ 2]         CMPA   #'"'
  502 E74F:270F (E760)     [ 3]         BEQ    GETSCON2
  503 E751:810D            [ 2]         CMPA   #EOL
  504 E753:2605 (E75A)     [ 3]         BNE    GETSCON3
  505 E755:860D            [ 2]         LDAA   #MISQUERR
  506 E757:7EEA 98         [ 3]         JMP    RPTERR
  507 E75A:BDE3 D7         [ 6] GETSCON3:       JSR    PUTTOK
  508 E75D:5C              [ 2]         INCB
  509 E75E:20EA (E74A)     [ 3]         BRA    GETSCON1
  510                           *
  511                           * *tbufptr++=c;          /* put closing quote in token buffer */
  512                           * ++ibufptr;             /* advance input buffer pointer */
  513                           * *bufptr=count;         /* put string byte count in token buffer */
  514                           * return;
  515                           *}
  516                           *
  517      E760                 GETSCON2:       EQU    *
  518 E760:BDE3 D7         [ 6]         JSR    PUTTOK
  519 E763:38              [ 5] GETSCON4:       PULX
  520 E764:E700            [ 4]         STAB   0,X
  521 E766:39              [ 5]         RTS
  522                           *
  523                           *
*** END   INCLUDE FILE: BASICLB3.ASM *** (RESUMING FILE: BASIC11.ASM)
   10                           #Include  'BASICLB5.Asm'
*** BEGIN INCLUDE FILE: BASICLB5.ASM ***
    1                           *        title    BASICLB5
    2                           *        page
    3                           *
    4                           */***** getfun() *****/
    5                           *
    6                           *getfun()
    7                           *{
    8                           * short type;
    9                           * if(match("FDIV")) type=xfdiv();
   10                           * else if(match("CHR$")) type=xchrs();
   11                           * else if(match("ABS")) type=xabs();
   12                           * else if(match("RND")) type=xrnd();
   13                           * else if(match("SGN")) type=xsgn();
   14                           * else if(match("TAB")) type=xtab();
   15                           * else if(match("ADC")) type=xadc();
   16                           * else if(match("CALL")) type=xcall();
   17                           * else return(0);
   18                           * return(type);
   19                           *}
   20                           *
   21                           *
   22      E767                 GETFUN: EQU    *
   23 E767:CEE7 88         [ 3]         LDX    #FUNCTBL
   24 E76A:BDE3 A5         [ 6] GETFUN1:        JSR    STREQ
   25 E76D:250E (E77D)     [ 3]         BCS    GETFUN2
   26 E76F:08              [ 3] GETFUN3:        INX
   27 E770:A600            [ 4]         LDAA   0,X
   28 E772:26FB (E76F)     [ 3]         BNE    GETFUN3
   29 E774:C604            [ 2]         LDAB   #4
   30 E776:3A              [ 3]         ABX
   31 E777:6D00            [ 6]         TST    0,X
   32 E779:26EF (E76A)     [ 3]         BNE    GETFUN1
   33 E77B:4F              [ 2]         CLRA
   34 E77C:39              [ 5]         RTS
   35 E77D:8636            [ 2] GETFUN2:        LDAA   #FUNCTFLG
   36 E77F:BDE3 D7         [ 6]         JSR    PUTTOK
   37 E782:A601            [ 4]         LDAA   1,X
   38 E784:EE02            [ 5]         LDX    2,X
   39 E786:6E00            [ 3]         JMP    0,X
   40                           *
   41                           *
   42      E788                 FUNCTBL:        EQU    *
   43 E788.4644 4956            FDIVS:  FCC    "FDIV"
   44 E78C.00                           FCB    0
   45 E78D.01                           FCB    FDIVTOK
   46 E78E.E801                         FDB    BNUMFUN
   47 E790.4348 5224            CHRS:   FCC    "CHR$"
   48 E794.00                           FCB    0
   49 E795.02                           FCB    CHRTOK
   50 E796.E81F                         FDB    UNUMFUN
   51 E798.4142 53              ABS:    FCC    "ABS"
   52 E79B.00                           FCB    0
   53 E79C.04                           FCB    ABSTOK
   54 E79D.E81F                         FDB    UNUMFUN
   55 E79F.524E 44              RND:    FCC    "RND"
   56 E7A2.00                           FCB    0
   57 E7A3.05                           FCB    RNDTOK
   58 E7A4.E81F                         FDB    UNUMFUN
   59 E7A6.5347 4E              SGN:    FCC    "SGN"
   60 E7A9.00                           FCB    0
   61 E7AA.06                           FCB    SGNTOK
   62 E7AB.E81F                         FDB    UNUMFUN
   63 E7AD.5441 42              TABS:   FCC    "TAB"
   64 E7B0.00                           FCB    0
   65 E7B1.07                           FCB    TABTOK
   66 E7B2.E81F                         FDB    UNUMFUN
   67 E7B4.4144 43              ADCS:   FCC    "ADC"
   68 E7B7.00                           FCB    0
   69 E7B8.03                           FCB    ADCTOK
   70 E7B9.E81F                         FDB    UNUMFUN
   71 E7BB.4341 4C4C            CALL:   FCC    "CALL"
   72 E7BF.00                           FCB    0
   73 E7C0.08                           FCB    CALLTOK
   74 E7C1.E81F                         FDB    UNUMFUN
   75 E7C3.5045 454B            PEEK:   FCC    "PEEK"
   76 E7C7.00                           FCB    0
   77 E7C8.09                           FCB    PEEKTOK
   78 E7C9.E81F                         FDB    UNUMFUN
   79 E7CB.4545 50                      FCC    "EEP"
   80 E7CE.00                           FCB    0
   81 E7CF.0A                           FCB    FEEPTOK
   82 E7D0.E81F                         FDB    UNUMFUN
   83 E7D2.4845 5832            HEX2:   FCC    "HEX2"
   84 E7D6.00                           FCB    0
   85 E7D7.12                           FCB    HEX2TOK
   86 E7D8.E81F                         FDB    UNUMFUN
   87 E7DA.4845 58              HEX:    FCC    "HEX"
   88 E7DD.00                           FCB    0
   89 E7DE.0B                           FCB    HEXTOK
   90 E7DF.E81F                         FDB    UNUMFUN
   91 E7E1.504F 5254                    FCC    "PORT"
   92 E7E5.00                           FCB    0
   93 E7E6.0C                           FCB    FPRTATOK
   94 E7E7.E868                         FDB    FINDPORT
   95 E7E9.5449 4D45                    FCC    "TIME"
   96 E7ED.00                           FCB    0
   97 E7EE.11                           FCB    FTIMETOK
   98 E7EF.E87F                         FDB    XTIMEF
   99 E7F1.5041 4343                    FCC    "PACC"
  100 E7F5.00                           FCB    0
  101 E7F6.13                           FCB    FPACCTOK
  102 E7F7.E87F                         FDB    XPACCF
  103 E7F9.00                           FCB    0            ; END OF TABLE MARKER.
  104                           *
  105                           *
  106      E7FA                 XPOKE:  EQU    *
  107 E7FA:DE02            [ 4]         LDX    TBUFPTR      ; GET TOKEN BUFFER POINTER.
  108 E7FC:09              [ 3]         DEX                 ; DEC. TO COMPENSATE FOR PUTTOK DONE IN XLATE.
  109 E7FD:DF02            [ 4]         STX    TBUFPTR      ; SAVE NEW POINTER VALUE. FALL THROUGH TO BNUMFUN.
  110 E7FF:A600            [ 4]         LDAA   0,X          ; GET TOKEN BACK INTO THE A-REG.
  111                           *
  112                           *
  113                           */***** xfdiv() *****/
  114                           *
  115                           *xfdiv()
  116                           *{
  117                           * short type[2];
  118                           * type[0]=type[1]=NUM;            /* both arguments must be type NUM */
  119                           * dofunct(FDIVTOK,2,type);
  120                           * return(NUM);
  121                           *}
  122                           *
  123      E801                 BNUMFUN:        EQU    *
  124 E801:183C            [ 5]         PSHY
  125 E803:C601            [ 2]         LDAB   #NUM
  126 E805:37              [ 3]         PSHB
  127 E806:37              [ 3]         PSHB
  128 E807:1830            [ 4]         TSY
  129 E809:C602            [ 2]         LDAB   #2
  130 E80B:BDE8 2E         [ 6]         JSR    DOFUNCT
  131                           *        LDAA   #NUM
  132 E80E:32              [ 4]         PULA
  133 E80F:32              [ 4]         PULA
  134 E810:1838            [ 6]         PULY
  135 E812:39              [ 5]         RTS
  136                           *
  137                           *
  138                           */***** xchrs *****/
  139                           *
  140                           *xchrs()
  141                           *{
  142                           * return(unumfun(CHRTOK));
  143                           *}
  144                           *
  145                           */***** xabs() *****/
  146                           *
  147                           *xabs()
  148                           *{
  149                           * return(unumfun(ABSTOK));
  150                           *}
  151                           *
  152                           */***** xrnd() *****/
  153                           *
  154                           *xrnd()
  155                           *{
  156                           * return(unumfun(RNDTOK));
  157                           *}
  158                           *
  159                           */***** xsgn() *****/
  160                           *
  161                           *xsgn()
  162                           *{
  163                           * return(unumfun(SGNTOK));
  164                           *}
  165                           *
  166                           */***** xtab() *****/
  167                           *
  168                           *xtab()
  169                           *{
  170                           * return(unumfun(TABTOK));
  171                           *}
  172                           *
  173                           */***** xadc() *****/
  174                           *
  175                           *xadc()
  176                           *{
  177                           * return(unumfun(ADCTOK));
  178                           *}
  179                           *
  180                           */***** xcall() *****/
  181                           *
  182                           *xcall()
  183                           *{
  184                           * return(unumfun(CALLTOK));
  185                           *}
  186                           *
  187                           */***** unumfun() *****/
  188                           *
  189                           *unumfun(token)  /* common code for a uinary numerical function */
  190                           *short token;
  191                           *{
  192                           * short type[1];         /* setup argument 'type' array */
  193                           * type[0]=NUM;           /* set the 1st (only) argument type to NUM */
  194                           * dofunct(token,1,type); /* go do the function */
  195                           * return(NUM);           /* return the function type */
  196                           *}
  197                           *
  198      E813                 XEEP:   EQU    *            ; PROGRAM A WORD OF EEPROM.
  199 E813:DE02            [ 4]         LDX    TBUFPTR      ; COMPENSATE FOR TOKEN PLACEMENT BU UNUMFUN
  200 E815:09              [ 3]         DEX                 ; ROUTINE.
  201 E816:DF02            [ 4]         STX    TBUFPTR      ; SAVE POINTER.
  202 E818:A600            [ 4]         LDAA   0,X          ; GET TOKEN FROM BUFFER.
  203 E81A:8D03 (E81F)     [ 6]         BSR    UNUMFUN      ; GO TREAT AS A UNIARY NUMERIC FUNCTION.
  204 E81C:7EE4 20         [ 3]         JMP    ASIGNMT1     ; GO USE ASSIGNMENT CODE FOR REST OF FUNCTION.
  205                           *
  206                           *
  207                           *
  208      E81F                 UNUMFUN:        EQU    *
  209 E81F:183C            [ 5]         PSHY
  210 E821:C601            [ 2]         LDAB   #NUM
  211 E823:37              [ 3]         PSHB
  212 E824:C601            [ 2]         LDAB   #1
  213 E826:1830            [ 4]         TSY
  214 E828:8D04 (E82E)     [ 6]         BSR    DOFUNCT
  215                           *        LDAA   #NUM
  216 E82A:32              [ 4]         PULA
  217 E82B:1838            [ 6]         PULY
  218 E82D:39              [ 5]         RTS
  219                           *
  220                           *
  221                           */***** dofunct() *****/
  222                           *
  223                           *dofunct(functok,nargs,type)
  224                           *short functok,nargs,*type;
  225                           *{
  226                           * *tbufptr++=functok;            /* put function token in buffer */
  227                           * if(*ibufptr!='(') { errcode=ILFSYERR; return; }
  228                           * *tbufptr++=OPARNTOK;           /* put open paren in token buffer */
  229                           * ++ibufptr;
  230                           *
  231      E82E                 DOFUNCT:        EQU    *
  232 E82E:BDE3 D7         [ 6]         JSR    PUTTOK
  233 E831:BDE3 C3         [ 6]         JSR    GETCHR
  234 E834:8128            [ 2]         CMPA   #'('
  235 E836:2705 (E83D)     [ 3]         BEQ    DOFUNCT1
  236 E838:860E            [ 2] DOFUNCT5:       LDAA   #MPARNERR
  237 E83A:7EEA 98         [ 3]         JMP    RPTERR
  238 E83D:BDE3 CC         [ 6] DOFUNCT1:       JSR    INCIBP
  239 E840:8610            [ 2]         LDAA   #OPARNTOK
  240 E842:BDE3 D7         [ 6]         JSR    PUTTOK
  241                           *
  242                           *
  243                           * while(1)
  244                           * {
  245                           *  xexpres(*type++);             /* get the argument/expression */
  246                           *  if(errcode) return;           /* return if error */
  247                           *  if(--nargs==0) break;         /* if we have all the arguments, quit */
  248                           *  if(*ibufptr!=',')             /* if delimiter not present, return */
  249                           *   { errcode=ILFSYERR; return; }
  250                           *  *tbufptr++=COMMATOK;          /* if it is, put it in the token buffer */
  251                           *  ++ibufptr;                    /* point to the next character */
  252                           * }
  253                           *
  254 E845:18A6 00         [ 5] DOFUNCT4:       LDAA   0,Y
  255 E848:1808            [ 4]         INY
  256 E84A:37              [ 3]         PSHB
  257 E84B:BDE4 30         [ 6]         JSR    XEXPRES
  258 E84E:33              [ 4]         PULB
  259 E84F:5A              [ 2]         DECB
  260 E850:2707 (E859)     [ 3]         BEQ    DOFUNCT3
  261 E852:BDEA 2D         [ 6]         JSR    CHKCOMA
  262 E855:24E1 (E838)     [ 3]         BCC    DOFUNCT5
  263 E857:20EC (E845)     [ 3]         BRA    DOFUNCT4
  264                           *
  265                           *
  266                           * if(*ibufptr!=')')              /* must see closing paren */
  267                           * {
  268                           *  errcode=ILFSYERR;             /* if not, error */
  269                           *  return;
  270                           * }
  271                           * else                           /* saw closing paren */
  272                           * {
  273                           *  *tbufptr++=CPARNTOK;          /* put it in the token buffer */
  274                           *  ++ibufptr;                    /* advance input buffer pointer */
  275                           * }
  276                           * return;
  277                           *}
  278                           *
  279      E859                 DOFUNCT3:       EQU    *
  280 E859:BDE3 C3         [ 6]         JSR    GETCHR
  281 E85C:8129            [ 2]         CMPA   #')'
  282 E85E:26D8 (E838)     [ 3]         BNE    DOFUNCT5
  283 E860:BDE3 CC         [ 6]         JSR    INCIBP
  284 E863:8611            [ 2]         LDAA   #CPARNTOK
  285 E865:7EE3 D7         [ 3]         JMP    PUTTOK       ; PUT TOKEN IN BUFFER & RETURN.
  286                           *
  287                           *
  288                           *
  289      E868                 FINDPORT:       EQU    *
  290 E868:BDE3 CA         [ 6]         JSR    GETNXCHR     ; GO GET PORT "NUMBER".
  291 E86B:BDE0 FA         [ 6]         JSR    ToUpper  ; Translate the character to upper case.
  292 E86E:8141            [ 2]         CMPA   #'A'         ; IS IT AN A OR HIGHER?
  293 E870:2405 (E877)     [ 3]         BHS    FINDPRT1     ; YES. GO CHECK UPPER LIMIT.
  294 E872:862F            [ 2] FINDPRT2:       LDAA   #ILPRTERR    ; NO. ILLEGAL PORT "NUMBER".
  295 E874:7EEA 98         [ 3]         JMP    RPTERR       ; REPORT ERROR.
  296 E877:8145            [ 2] FINDPRT1:       CMPA   #'E'         ; IS IT HIGHER THAN AN "E"?
  297 E879:22F7 (E872)     [ 3]         BHI    FINDPRT2     ; YES. ILLEGAL PORT.
  298 E87B:8041            [ 2]         SUBA   #'A'         ; SUBTRACT "BASE" PORT OF A
  299 E87D:8B0C            [ 2]         ADDA   #FPRTATOK    ; ADD IN "BASE" TOKEN.
  300                           *
  301                           *                            ; STEAL SOME CODE.
  302      E87F                 XPACCF: EQU    *
  303 E87F:BDE3 D7         [ 6] XTIMEF: JSR    PUTTOK       ; PUT TOKEN IN BUFFER.
  304 E882:8601            [ 2]         LDAA   #NUM         ; RETURN TYPE "NUM".
  305 E884:39              [ 5]         RTS                 ; RETURN.
  306                           *
  307                           *
*** END   INCLUDE FILE: BASICLB5.ASM *** (RESUMING FILE: BASIC11.ASM)
   11                           #Include  'BASICLB4.Asm'
*** BEGIN INCLUDE FILE: BASICLB4.ASM ***
    1                           *        title    BASICLB4
    2                           *        page
    3                           *
    4                           *
    5                           */***** xon *****/
    6                           *
    7                           *xon()
    8                           *{
    9                           * int num;
   10                           * *tbufptr++=ONTOK;      /* put ON token in buffer */
   11                           * blanks();              /* skip any blanks */
   12                           * xexpres(NUM);          /* get the expression */
   13                           * if(errcode) return;    /* if error, return */
   14                           * blanks();              /* skip any blanks */
   15                           * if(match("GOTO")) xgoto();     /* check for GOTO */
   16                           * else if(match("GOSUB")) xgosub();      /* check for GOSUB */
   17                           * else errcode=IONSYERR;         /* if neither, flag an error */
   18                           * if(errcode) return;            /* if error, return */
   19                           * blanks();              /* skip blanks */
   20                           *
   21                           *
   22      E885                 XON:    EQU    *
   23                           *        JSR    BLANKS
   24 E885:8601            [ 2]         LDAA   #NUM
   25 E887:BDE4 30         [ 6]         JSR    XEXPRES
   26 E88A:BDE3 7A         [ 6] XON1:   JSR    BLANKS
   27 E88D:CEE2 71         [ 3]         LDX    #GOTO
   28 E890:BDE3 A5         [ 6]         JSR    STREQ
   29 E893:240D (E8A2)     [ 3]         BCC    XON2
   30 E895:8612            [ 2]         LDAA   #GOTOTOK
   31 E897:BDE3 D7         [ 6]         JSR    PUTTOK
   32 E89A:BDE3 7A         [ 6]         JSR    BLANKS
   33 E89D:BDE3 F2         [ 6]         JSR    XGOTO
   34 E8A0:2018 (E8BA)     [ 3]         BRA    XON5
   35 E8A2:CEE2 68         [ 3] XON2:   LDX    #GOSUB
   36 E8A5:BDE3 A5         [ 6]         JSR    STREQ
   37 E8A8:2505 (E8AF)     [ 3]         BCS    XON4
   38 E8AA:860F            [ 2]         LDAA   #IONSYERR
   39 E8AC:7EEA 98         [ 3]         JMP    RPTERR
   40 E8AF:860F            [ 2] XON4:   LDAA   #GOSUBTOK
   41 E8B1:BDE3 D7         [ 6]         JSR    PUTTOK
   42 E8B4:BDE3 7A         [ 6]         JSR    BLANKS
   43 E8B7:BDE3 F2         [ 6]         JSR    XGOSUB
   44 E8BA:BDE3 7A         [ 6] XON5:   JSR BLANKS
   45                           *
   46                           *
   47                           * while(*ibufptr==',')   /* do until EOL */
   48                           * {
   49                           *  *tbufptr++=COMMATOK;  /* put COMMA token in buffer */
   50                           *  ++ibufptr;            /* advance the input buffer pointer */
   51                           *  blanks();             /* skip blanks */
   52                           *  *tbufptr++=LCONTOK;   /* put line number constant token in buffer */
   53                           *  num=getlinum();       /* get line number */
   54                           *  if(num==0) errcode=LINENERR;   /* if 0, line number error */
   55                           *  if(errcode) return;    /* if error, return */
   56                           *  putint(num);           /* put line number in buffer */
   57                           *  blanks();              /* skip blanks */
   58                           * }
   59                           * return;
   60                           *}
   61                           *
   62 E8BD:BDEA 2D         [ 6]         JSR    CHKCOMA
   63 E8C0:2501 (E8C3)     [ 3]         BCS    XON6
   64 E8C2:39              [ 5]         RTS
   65 E8C3:BDE3 7A         [ 6] XON6:   JSR    BLANKS
   66 E8C6:86A8            [ 2]         LDAA   #LCONTOK
   67 E8C8:BDE3 D7         [ 6]         JSR    PUTTOK
   68 E8CB:BDE1 6C         [ 6]         JSR    GETLINUM
   69 E8CE:BDE3 D4         [ 6] XON8:   JSR    PUTDTOK
   70 E8D1:20E7 (E8BA)     [ 3]         BRA    XON5
   71                           *
   72                           *
   73      E8D3                 XONIRQ: EQU    *            ; "ONIRQ" HAS A FUNCTION CODE & LINE NUMBER.
   74      E8D3                 XONTIME:        EQU    *
   75 E8D3:8601            [ 2]         LDAA   #NUM         ; GO GET THE VALUE OF THE TIMER WE SHOULD GO ON.
   76 E8D5:BDE4 30         [ 6]         JSR    XEXPRES
   77 E8D8:BDE3 7A         [ 6]         JSR    BLANKS       ; SKIP BLANKS.
   78 E8DB:BDEA 2D         [ 6]         JSR    CHKCOMA      ; GO CHECK FOR A COMMA.
   79 E8DE:2505 (E8E5)     [ 3]         BCS    XONTIME1     ; IF PRESENT, IT'S OK.
   80 E8E0:8615            [ 2] XONTIME2:       LDAA   #MCOMAERR    ; IF NOT, REPORT AN ERROR.
   81 E8E2:7EEA 98         [ 3]         JMP    RPTERR
   82 E8E5:BDE3 7A         [ 6] XONTIME1:       JSR    BLANKS
   83 E8E8:86A8            [ 2]         LDAA   #LCONTOK     ; GET THE LINE CONSTANT TOKEN.
   84 E8EA:BDE3 D7         [ 6]         JSR    PUTTOK       ; PUT IT IN THE TOKEN BUFFER.
   85 E8ED:BDE1 6C         [ 6]         JSR    GETLINUM     ; GO GET A LINE NUMBER.
   86 E8F0:7EE3 D4         [ 3]         JMP    PUTDTOK      ; PUT THE LINE NUMBER IN THE TOKEN BUFFER.
   87                           *
   88                           *
   89      E8F3                 XONPACC:        EQU    *
   90 E8F3:8D02 (E8F7)     [ 6]         BSR    GETARG       ; GET AN ARGUMENT AND A COMMA.
   91 E8F5:20DC (E8D3)     [ 3]         BRA    XONTIME      ; GO USE SOME OTHER CODE.
   92                           *
   93                           *
   94 E8F7:8601            [ 2] GETARG: LDAA   #NUM         ; GO GET THE "OPERATING MODE" EXPRESSION.
   95 E8F9:BDE4 30         [ 6]         JSR    XEXPRES
   96 E8FC:BDE3 7A         [ 6]         JSR    BLANKS       ; SKIP BLANKS.
   97 E8FF:BDEA 2D         [ 6]         JSR    CHKCOMA      ; GO CHECK FOR COMMA.
   98 E902:24DC (E8E0)     [ 3]         BCC    XONTIME2     ; NO COMMA. REPORT ERROR.
   99 E904:7EE3 7A         [ 3]         JMP    BLANKS       ; SKIP BLANKS AFTER COMMA AND RETURN.
  100                           
  101                           *
  102                           *
  103                           *
  104                           */***** xif() *****/
  105                           *
  106                           *xif()
  107                           *{
  108                           *int num;
  109                           * *tbufptr++=IFTOK;              /* put if token in the buffer */
  110                           * blanks();                      /* skip any blanks */
  111                           * ifwhflag=1;                    /* let xexpres() know we are doing an IF */
  112                           * xexpres(NULL);                 /* get relational expression */
  113                           * if(errcode) return;            /* if error, return */
  114                           * blanks();                      /* if not, skip blanks */
  115                           *
  116                           *
  117      E907                 XIF:    EQU    *
  118                           *        JSR    BLANKS
  119 E907:7C00 1A         [ 6]         INC    IFWHFLAG
  120 E90A:8601            [ 2]         LDAA   #NUM
  121 E90C:BDE4 30         [ 6]         JSR    XEXPRES
  122 E90F:BDE3 7A         [ 6] XIF1:   JSR    BLANKS
  123                           *
  124                           *
  125                           * if(match("THEN"))              /* check for "THEN" clause */
  126                           * {
  127                           *  *tbufptr++=THENTOK;           /* put THEN token in the buffer */
  128                           *  blanks();                     /* skip any blanks after "THEN" */
  129                           *
  130                           *
  131 E912:CEE9 66         [ 3]         LDX    #THENS
  132 E915:BDE3 A5         [ 6]         JSR    STREQ
  133 E918:2505 (E91F)     [ 3]         BCS    XIF2
  134 E91A:8610            [ 2]         LDAA   #MTHENERR
  135 E91C:7EEA 98         [ 3]         JMP    RPTERR
  136                           *
  137                           *
  138                           *  if(numeric(*ibufptr))         /* is a line number present after THEN? */
  139                           *  {                             /* yes */
  140                           *   *tbufptr++=LCONTOK;          /* put line # const. token in buffer */
  141                           *   num=getlinum();              /* get the line # */
  142                           *   if(num==0) errcode=LINENERR;
  143                           *   if(errcode) return;          /* if error, return */
  144                           *   putint(num);                 /* put number in buffer */
  145                           *  }
  146                           *  else                          /* not a line #, check for statement */
  147                           *  {
  148                           *   xlate();             /* try to make a statement out of what follows */
  149                           *   if(errcode) return;          /* if error, return */
  150                           *  }
  151                           * }
  152                           *
  153                           *
  154      E91F                 XIF2:   EQU    *
  155 E91F:8638            [ 2]         LDAA   #THENTOK
  156 E921:BDE3 D7         [ 6]         JSR    PUTTOK
  157 E924:BDE3 7A         [ 6]         JSR    BLANKS
  158 E927:BDE3 C3         [ 6]         JSR    GETCHR
  159 E92A:BDE1 BB         [ 6]         JSR    NUMERIC
  160 E92D:2427 (E956)     [ 3]         BCC    XIF9
  161                           *
  162 E92F:86A8            [ 2] XIF3:   LDAA   #LCONTOK
  163 E931:BDE3 D7         [ 6]         JSR    PUTTOK
  164 E934:BDE1 6C         [ 6]         JSR    GETLINUM
  165 E937:BDE3 D4         [ 6] XIF6:   JSR    PUTDTOK
  166                           *
  167                           *
  168                           * else                   /* if "THEN" not present */
  169                           * {
  170                           *  errcode=MTHENERR;             /* flag a missing THEN error */
  171                           *  return;
  172                           * }
  173                           *
  174                           *
  175                           * blanks();                      /* skip any blanks after object of THEN */
  176                           * if(match("ELSE"))              /* is "ELSE" clause present? */
  177                           * {                              /* yes */
  178                           *  *tbufptr++=ELSETOK;           /* put ELSE token in the buffer */
  179                           *  blanks();                     /* skip any blanks after ELSE */
  180                           *
  181                           *
  182      E93A                 XIF4:   EQU    *
  183 E93A:BDE3 7A         [ 6]         JSR    BLANKS
  184 E93D:CEE9 6B         [ 3]         LDX    #ELSES
  185 E940:BDE3 A5         [ 6]         JSR    STREQ
  186 E943:2501 (E946)     [ 3]         BCS    XIF7
  187 E945:39              [ 5]         RTS
  188 E946:8639            [ 2] XIF7:   LDAA   #ELSETOK
  189 E948:BDE3 D7         [ 6]         JSR    PUTTOK
  190 E94B:BDE3 7A         [ 6]         JSR    BLANKS
  191                           *
  192                           *
  193                           *  if(numeric(*ibufptr))         /* is a line # present after ELSE */
  194                           *  {                     /* yes */
  195                           *   *tbufptr++=LCONTOK;          /* put line # const. token in buffer */
  196                           *   num=getlinum();              /* get the line # */
  197                           *   if(num==0) errcode=LINENERR;
  198                           *   if(errcode) return;          /* if error, return */
  199                           *   putint(num);                 /* put number in buffer */
  200                           *  }
  201                           *  else          /* line # not present, try to xlate a statement */
  202                           *  {
  203                           *   xlate();
  204                           *  }
  205                           * }
  206                           *
  207                           *
  208 E94E:BDE3 C3         [ 6]         JSR    GETCHR
  209 E951:BDE1 BB         [ 6]         JSR    NUMERIC
  210 E954:2505 (E95B)     [ 3]         BCS    XIF8
  211 E956:8612            [ 2] XIF9:   LDAA   #LINENERR
  212 E958:7EEA 98         [ 3]         JMP    RPTERR
  213 E95B:86A8            [ 2] XIF8:   LDAA   #LCONTOK
  214 E95D:BDE3 D7         [ 6]         JSR    PUTTOK
  215 E960:BDE1 6C         [ 6]         JSR    GETLINUM
  216 E963:7EE3 D4         [ 3] XIF10:  JMP    PUTDTOK
  217                           *
  218                           * return;                /* in any case, return */
  219                           *}
  220                           *
  221                           *
  222 E966.5448 454E            THENS:  FCC    "THEN"
  223 E96A.00                           FCB    0
  224 E96B.454C 5345            ELSES:  FCC    "ELSE"
  225 E96F.00                           FCB   0
  226                           *
  227                           *
  228                           */***** xfor() *****/
  229                           *
  230                           *xfor()
  231                           *{
  232                           * short type;
  233                           * *tbufptr++=FORTOK;             /* put for token in buffer */
  234                           * blanks();              /* skip blanks between FOR & assignment statement */
  235                           * type=getvar();         /* get variable */
  236                           * if((type!=NUM)|(*ibufptr++!='='))      /* is it a numerical variable? */
  237                           * { errcode=IVEXPERR; return; }  /* no. flag error & return */
  238                           *
  239                           *
  240      E970                 XFOR:   EQU    *
  241                           *        JSR    BLANKS
  242 E970:BDE5 57         [ 6]         JSR    GETVAR
  243 E973:8101            [ 2]         CMPA   #NUM
  244 E975:2705 (E97C)     [ 3]         BEQ    XFOR1
  245 E977:8603            [ 2] XFOR2:  LDAA   #IVEXPERR
  246 E979:7EEA 98         [ 3]         JMP    RPTERR
  247 E97C:BDE3 CA         [ 6] XFOR1:  JSR    GETNXCHR
  248 E97F:813D            [ 2]         CMPA   #'='
  249 E981:26F4 (E977)     [ 3]         BNE    XFOR2
  250                           *
  251                           *
  252                           * *tbufptr++=EQUALTOK;   /* put equals token in buffer */
  253                           * xexpres(NUM);          /* go get a numerical expression */
  254                           * if(errcode) return;    /* if error, return */
  255                           * blanks();              /* skip blanks */
  256                           *
  257                           *
  258 E983:8679            [ 2]         LDAA   #EQUALTOK
  259 E985:BDE3 D7         [ 6]         JSR    PUTTOK
  260 E988:8601            [ 2]         LDAA   #NUM
  261 E98A:BDE4 30         [ 6]         JSR    XEXPRES
  262 E98D:BDE3 7A         [ 6]         JSR    BLANKS
  263                           *
  264                           *
  265                           * if(match("TO"))        /* is TO present? */
  266                           * {                      /* yes */
  267                           *  *tbufptr++=TOTOK;     /* put TO token in buffer */
  268                           *  blanks();             /* skip blanks */
  269                           *  xexpres(NUM);         /* get the "TO" expression */
  270                           *  if(errcode) return;   /* return if error */
  271                           * }
  272                           * else                   /* "TO" not present */
  273                           * {
  274                           *  errcode=MTOERR;       /* set error flag & return */
  275                           *  return;
  276                           * }
  277                           *
  278                           *
  279 E990:CEE9 C3         [ 3]         LDX    #TO
  280 E993:BDE3 A5         [ 6]         JSR    STREQ
  281 E996:2505 (E99D)     [ 3]         BCS    XFOR4
  282 E998:8611            [ 2]         LDAA   #MTOERR
  283 E99A:7EEA 98         [ 3]         JMP    RPTERR
  284 E99D:8637            [ 2] XFOR4:  LDAA   #TOTOK
  285 E99F:BDE3 D7         [ 6]         JSR    PUTTOK
  286 E9A2:BDE3 7A         [ 6]         JSR    BLANKS
  287 E9A5:8601            [ 2]         LDAA   #NUM
  288 E9A7:BDE4 30         [ 6]         JSR    XEXPRES
  289                           *
  290                           *
  291                           * blanks();              /* skip blanks */
  292                           * if(match("STEP"))      /* is optional "STEP" clause present? */
  293                           * {                      /* yes */
  294                           *  *tbufptr++=STEPTOK;   /* put STEP token in buffer */
  295                           *  blanks();             /* skip blanks */
  296                           *  xexpres(NUM);         /* get expression */
  297                           * }
  298                           * return;
  299                           *}
  300                           *
  301                           *
  302 E9AA:BDE3 7A         [ 6]         JSR    BLANKS
  303 E9AD:CEE9 C6         [ 3]         LDX    #STEP
  304 E9B0:BDE3 A5         [ 6]         JSR    STREQ
  305 E9B3:2501 (E9B6)     [ 3]         BCS    XFOR3
  306 E9B5:39              [ 5]         RTS
  307 E9B6:863A            [ 2] XFOR3:  LDAA   #STEPTOK
  308 E9B8:BDE3 D7         [ 6]         JSR    PUTTOK
  309 E9BB:BDE3 7A         [ 6]         JSR    BLANKS
  310 E9BE:8601            [ 2]         LDAA   #NUM
  311 E9C0:7EE4 30         [ 3]         JMP    XEXPRES
  312                           *
  313                           *
  314 E9C3.544F                 TO:     FCC    "TO"
  315 E9C5.00                           FCB    0
  316 E9C6.5354 4550            STEP:   FCC    "STEP"
  317 E9CA.00                           FCB    0
  318                           *
  319                           *
  320                           */***** xnext() *****/
  321                           *
  322                           *xnext()
  323                           *{
  324                           * *tbufptr++=NEXTTOK;    /* put NEXT token in buffer */
  325                           * blanks();              /* skip blanks */
  326                           * if(getvar()!=NUM) errcode=SYTXERR;     /* get variable, must be numeric */
  327                           * return;
  328                           *}
  329                           *
  330                           *
  331      E9CB                 XNEXT:  EQU    *
  332                           *        JSR    BLANKS
  333 E9CB:BDE5 57         [ 6]         JSR    GETVAR
  334 E9CE:8101            [ 2]         CMPA   #NUM
  335 E9D0:2705 (E9D7)     [ 3]         BEQ    XNEXT1
  336 E9D2:8602            [ 2]         LDAA   #SYTXERR
  337 E9D4:7EEA 98         [ 3]         JMP    RPTERR
  338 E9D7:39              [ 5] XNEXT1: RTS
  339                           *
  340                           *
  341                           */***** xprint() *****/
  342                           *
  343                           *xprint()
  344                           *{
  345                           * *tbufptr++=PRINTTOK;   /* put PRINT token in buffer */
  346                           * blanks();             /* skip blanks */
  347                           *
  348                           *
  349      E9D8                 XPRINT: EQU    *
  350                           *        JSR    BLANKS
  351 E9D8:BDE3 C3         [ 6]         JSR    GETCHR
  352 E9DB:8123            [ 2]         CMPA   #'#'       ; HAS AN ALTERNATE PORT BEEN SPECIFIED?
  353 E9DD:260D (E9EC)     [ 3]         BNE    XPRINT9    ; NO. GO PROCESS THE REST OF THE PRINT STATEMENT.
  354 E9DF:8678            [ 2]         LDAA   #PNUMTOK   ; YES. PUT THE TOKEN INTO THE BUFFER.
  355 E9E1:BDE3 D7         [ 6]         JSR    PUTTOK     ; DO IT.
  356 E9E4:BDE3 CC         [ 6]         JSR    INCIBP     ; POINT PAST THE "#".
  357 E9E7:BDE3 7A         [ 6]         JSR    BLANKS     ; SKIP SPACES BETWEEN '#' AND EXPRESION.
  358 E9EA:201B (EA07)     [ 3]         BRA    XPRINT7    ; GO GET EXPRESSION & CONTINUE.
  359                           *
  360                           *
  361                                   
  362                           * while((*ibufptr!=EOL)|(*ibufptr!=MIDEOL))    /* do until end of line */
  363                           * {
  364                           *  xexpres(NULL);        /* get expression */
  365                           *  if(errcode) return;   /* if error, return */
  366                           *  blanks();             /* skip blanks */
  367                           *  if(*ibufptr==COMMA) *tbufptr=COMMATOK;        /* check for comma */
  368                           *  else if(*ibufptr==SEMI) *tbufptr=SEMITOK;     /* check for semicolin */
  369                           *  else return;          /* if neither, return */
  370                           *  ++ibufptr;            /* advance input buffer pointer */
  371                           *  ++tbufptr;            /* advance token buffer pointer */
  372                           *  blanks();             /* skip blanks after delimeter */
  373                           * }
  374                           * return;
  375                           *}
  376 E9EC:BDE3 7A         [ 6] XPRINT9:        JSR    BLANKS
  377 E9EF:BDE3 C3         [ 6]         JSR    GETCHR
  378 E9F2:810D            [ 2]         CMPA   #EOL
  379 E9F4:2704 (E9FA)     [ 3]         BEQ    XPRINT2
  380 E9F6:813A            [ 2]         CMPA   #MIDEOL
  381 E9F8:2601 (E9FB)     [ 3]         BNE    XPRINT3
  382 E9FA:39              [ 5] XPRINT2:        RTS
  383 E9FB:BDE3 C3         [ 6] XPRINT3:        JSR    GETCHR       ; GET THE NEXT CHARACTER IN THE BUFFER.
  384 E9FE:8122            [ 2]         CMPA   #'"'         ; IS IT A STRING CONSTANT?
  385 EA00:2605 (EA07)     [ 3]         BNE    XPRINT7
  386 EA02:BDE7 36         [ 6]         JSR    GETSCON      ; YES. GO GET A STRING CONSTANT.
  387 EA05:2005 (EA0C)     [ 3]         BRA    XPRINT8      ; CONTINUE.
  388 EA07:8601            [ 2] XPRINT7:        LDAA   #NUM
  389 EA09:BDE4 30         [ 6]         JSR    XEXPRES
  390 EA0C:BDE3 7A         [ 6] XPRINT8:        JSR    BLANKS
  391 EA0F:BDE3 C3         [ 6]         JSR    GETCHR
  392 EA12:810D            [ 2]         CMPA   #EOL
  393 EA14:27E4 (E9FA)     [ 3]         BEQ    XPRINT2
  394 EA16:813A            [ 2]         CMPA   #MIDEOL
  395 EA18:27E0 (E9FA)     [ 3]         BEQ    XPRINT2
  396 EA1A:8D11 (EA2D)     [ 6]         BSR    CHKCOMA
  397 EA1C:25CE (E9EC)     [ 3]         BCS    XPRINT9
  398 EA1E:813B            [ 2] XPRINT4:        CMPA   #SEMI
  399 EA20:2705 (EA27)     [ 3]         BEQ    XPRINT6
  400 EA22:8616            [ 2]         LDAA   #MCMSMERR
  401 EA24:7EEA 98         [ 3]         JMP    RPTERR
  402 EA27:867B            [ 2] XPRINT6:        LDAA   #SEMITOK
  403 EA29:8D0D (EA38)     [ 6]         BSR    CHKCOMA2
  404 EA2B:20BF (E9EC)     [ 3]         BRA    XPRINT9
  405                           *
  406                           *
  407 EA2D:BDE3 C3         [ 6] CHKCOMA:        JSR    GETCHR          ; GET CHARACTER FROM INPUT BUFFER.
  408 EA30:812C            [ 2]         CMPA   #COMMA          ; IS IT A COMMA?
  409 EA32:2702 (EA36)     [ 3]         BEQ    CHKCOMA1        ; YES. PUT IT IN THE TOKEN BUFFER.
  410 EA34:0C              [ 2]         CLC                    ; NO. FLAG NO COMMA FOUND.
  411 EA35:39              [ 5]         RTS                    ; RETURN.
  412 EA36:867C            [ 2] CHKCOMA1:       LDAA   #COMMATOK       ; GET THE COMMA TOKEN.
  413 EA38:BDE3 D7         [ 6] CHKCOMA2:       JSR    PUTTOK          ; PUT THE TOKEN IN THE BUFFER.
  414 EA3B:BDE3 CC         [ 6]         JSR    INCIBP          ; BUMP THE INPUT BUFFER POINTER.
  415 EA3E:0D              [ 2]         SEC
  416 EA3F:39              [ 5]         RTS                    ; RETURN.
  417                           *
  418                           *
  419                           */***** xinput() *****/
  420                           *
  421                           *xinput()
  422                           *{
  423                           * *tbufptr++=INPUTTOK;           /* put INPUT token in buffer */
  424                           * blanks();                      /* skip blanks */
  425                           *
  426                           *
  427      EA40                 XINPUT: EQU    *
  428                           *        JSR    BLANKS
  429 EA40:8D21 (EA63)     [ 6]         BSR    XCHKDEV         ; GO CHECK FOR AN ALTERNATE DEVICE NUMBER.
  430                           *
  431                           *
  432                           * if(*ibufptr=='"')              /* is a prompt included? */
  433                           * {                      /* yes */
  434                           *  getscon();            /* get the string constant */
  435                           *  if(errcode) return;   /* if error, return */
  436                           *  if(*ibufptr!=COMMA) { errcode=SYTXERR; return; }
  437                           *  *tbufptr++=COMMATOK;
  438                           *  ++ibufptr;
  439                           * }
  440                           * inreadcm();            /* get the input variable list */
  441                           * return;
  442                           *}
  443                           *
  444                           *
  445 EA42:BDE3 7A         [ 6] XINPUT2:        JSR    BLANKS
  446 EA45:BDE3 C3         [ 6]         JSR    GETCHR
  447 EA48:8122            [ 2]         CMPA   #'"'
  448 EA4A:260C (EA58)     [ 3]         BNE    INREADCM
  449 EA4C:BDE7 36         [ 6]         JSR    GETSCON
  450 EA4F:8DDC (EA2D)     [ 6]         BSR    CHKCOMA         ; IF COMMA PRESENT, PUT IN TOKEN BUFFER.
  451 EA51:2505 (EA58)     [ 3]         BCS    INREADCM
  452 EA53:8615            [ 2] XINPUT3:        LDAA   #MCOMAERR
  453 EA55:7EEA 98         [ 3]         JMP    RPTERR
  454                           *
  455                           *
  456                           */***** inreadcm() *****/
  457                           *
  458                           *inreadcm()
  459                           *{
  460                           * while(1)               /* do forever */
  461                           * {
  462                           *  blanks();             /* skip blanks */
  463                           *  getvar();             /* get a variable */
  464                           *  if(errcode) return;   /* if error, return */
  465                           *  blanks();             /* skip blanks */
  466                           *  if(*ibufptr==COMMA)
  467                           *  {
  468                           *   *tbufptr++=COMMATOK;      /* put delimiter in buffer */
  469                           *   ++ibufptr;                /* and point to the next char in the buffer */
  470                           *  }
  471                           *  else return;          /* if no delimiter return */
  472                           * }
  473                           *}
  474                           *
  475      EA58                 XDIM:   EQU    *
  476      EA58                 INREADCM:       EQU    *
  477      EA58                 XREAD:  EQU    *
  478                           *        JSR    BLANKS
  479 EA58:BDE5 57         [ 6]         JSR    GETVAR
  480 EA5B:BDE3 7A         [ 6] XREAD1: JSR    BLANKS
  481 EA5E:8DCD (EA2D)     [ 6]         BSR    CHKCOMA
  482 EA60:25F6 (EA58)     [ 3]         BCS    XREAD
  483 EA62:39              [ 5]         RTS
  484                           *
  485                           *
  486                           *
  487      EA63                 XCHKDEV:        EQU    *
  488 EA63:BDE3 C3         [ 6]         JSR    GETCHR
  489 EA66:8123            [ 2]         CMPA   #'#'       ; HAS AN ALTERNATE PORT BEEN SPECIFIED?
  490 EA68:2701 (EA6B)     [ 3]         BEQ    XCHKDEV1   ; NO. GO PROCESS THE REST OF THE PRINT STATEMENT.
  491 EA6A:39              [ 5]         RTS               ; RETURN.
  492 EA6B:8678            [ 2] XCHKDEV1:       LDAA   #PNUMTOK   ; YES. PUT THE TOKEN INTO THE BUFFER.
  493 EA6D:BDE3 D7         [ 6]         JSR    PUTTOK     ; DO IT.
  494 EA70:BDE3 CC         [ 6]         JSR    INCIBP     ; POINT PAST THE "#".
  495 EA73:BDE3 7A         [ 6]         JSR    BLANKS     ; SKIP SPACES BETWEEN '#' AND EXPRESION.
  496 EA76:8601            [ 2]         LDAA   #NUM       ; EXPRESSION MUST BE NUMERIC.
  497 EA78:BDE4 30         [ 6]         JSR    XEXPRES    ; GO GET THE EXPRESSION.
  498 EA7B:BDE3 7A         [ 6]         JSR    BLANKS     ; SKIP SPACES.
  499 EA7E:8DAD (EA2D)     [ 6]         BSR    CHKCOMA    ; GO GET COMMA THAT MUST FOLLOW THE EXPRESSION.
  500 EA80:24D1 (EA53)     [ 3]         BCC    XINPUT3    ; MISSING COMMA. GO REPORT THE ERROR.
  501 EA82:39              [ 5]         RTS               ; IT WAS THERE. GO PROCESS THE REST OF THE STATEMENT.
  502                           *
  503                           *
  504                           *
  505      EA83                 XINBYTE:        EQU    *
  506 EA83:8DDE (EA63)     [ 6]         BSR    XCHKDEV    ; GO CHECK FOR ALTERNATE DEVICE.
  507 EA85:BDE3 7A         [ 6]         JSR    BLANKS     ; SKIP BLANKS AFTER COMMA.
  508 EA88:7EE5 57         [ 3]         JMP    GETVAR     ; GO TRY TO GET A VARIABLE.
  509                           *
  510                           *
  511                           *
  512                           *
  513                           */***** xread *****/
  514                           *
  515                           *xread()
  516                           *{
  517                           * *tbufptr++=READTOK;    /* put read token in buffer */
  518                           * inreadcm();            /* get the variable list */
  519                           * return;
  520                           *}
  521                           *
  522                           */***** xrestore() *****/
  523                           *
  524                           *xrestore()
  525                           *{
  526                           * *tbufptr++=RESTRTOK;   /* put RESTORE token in buffer */
  527                           * return;
  528                           *}
  529                           *
  530                           */***** xwhile() *****/
  531                           *
  532                           *xwhile()
  533                           *{
  534                           * *tbufptr++=WHILETOK;   /* put WHILE token in buffer */
  535                           * blanks();              /* skip blanks */
  536                           * ifwhflag=1;            /* indicate we are going to get a WHILE expression */
  537                           * xexpres(NULL);         /* get expression */
  538                           * return;
  539                           *}
  540                           *
  541                           *
  542      EA8B                 XWHILE: EQU    *
  543                           *        JSR    BLANKS
  544 EA8B:7C00 1A         [ 6]         INC    IFWHFLAG
  545 EA8E:8600            [ 2]         LDAA   #NULL
  546 EA90:7EE4 30         [ 3]         JMP    XEXPRES
  547                           *
  548                           *
  549                           */***** xendwh() *****/
  550                           *
  551                           *xendwh()
  552                           *{
  553                           * *tbufptr++=ENDWHTOK;   /* put ENDWH token in buffer */
  554                           * return;
  555                           *}
  556                           *
  557                           *
  558      EA93                 XPACC:  EQU    *
  559      EA93                 XTIME:  EQU    *
  560 EA93:C601            [ 2]         LDAB   #NUM         ; SETUP TO USE CODE IN "ASIGNMT".
  561 EA95:7EE4 20         [ 3]         JMP    ASIGNMT1     ; GO DO ASSIGNMENT STATEMENT.
  562                           *
  563                           *
  564                           *
  565                           */***** rpterr() *****/
  566                           *
  567                           *rpterr()
  568                           *{
  569                           *char *ptr,c;
  570                           * ptr=inbuff;    /* point to start of input buffer */
  571                           * nl();
  572                           * nl();
  573                           * while((c=*ptr++)!=EOL) outbyte(c);     /* print the input buffer */
  574                           *
  575                           *
  576      EA98                 RPTERR: EQU    *
  577 EA98:9718            [ 3]         STAA   ERRCODE
  578 EA9A:BDE1 0E         [ 6]         JSR    NL2
  579 EA9D:DE49            [ 4]         LDX    INBUFFS
  580 EA9F:A600            [ 4] RPTERR1:        LDAA   0,X
  581 EAA1:810D            [ 2]         CMPA   #EOL
  582 EAA3:2706 (EAAB)     [ 3]         BEQ    RPTERR2
  583 EAA5:BDFE CD         [ 6]         JSR    OUTBYTE
  584 EAA8:08              [ 3]         INX
  585 EAA9:20F4 (EA9F)     [ 3]         BRA    RPTERR1
  586                           *
  587                           *
  588                           * nl();          /* go to next line */
  589                           * ptr=inbuff;    /* point to begining of input buffer */
  590                           * while(ptr++ < ibufptr-2) outbyte('*');    /* output '*' to point of error */
  591                           * pl("^^^");  /* point to error */
  592                           * nl();
  593                           *
  594                           *
  595      EAAB                 RPTERR2:        EQU    *
  596 EAAB:BDE1 10         [ 6]         JSR    NL
  597 EAAE:DE00            [ 4]         LDX    IBUFPTR
  598 EAB0:09              [ 3]         DEX
  599 EAB1:09              [ 3]         DEX
  600 EAB2:9C49            [ 5]         CPX    INBUFFS
  601 EAB4:230E (EAC4)     [ 3]         BLS    RPTERR4
  602 EAB6:DF00            [ 4]         STX    IBUFPTR
  603 EAB8:DE49            [ 4]         LDX    INBUFFS
  604 EABA:862A            [ 2]         LDAA   #'*'
  605 EABC:BDFE CD         [ 6] RPTERR3:        JSR    OUTBYTE
  606 EABF:08              [ 3]         INX
  607 EAC0:9C00            [ 5]         CPX    IBUFPTR
  608 EAC2:26F8 (EABC)     [ 3]         BNE    RPTERR3
  609 EAC4:CEEA E2         [ 3] RPTERR4:        LDX    #ARROWS
  610 EAC7:BDE1 1C         [ 6]         JSR    PL
  611 EACA:BDE1 10         [ 6]         JSR    NL
  612 EACD:8D07 (EAD6)     [ 6]         BSR    RPTERR5
  613 EACF:8601            [ 2] RPTERR6:        LDAA   #1
  614 EAD1:971C            [ 3]         STAA   CONTFLAG
  615 EAD3:7EE0 53         [ 3]         JMP    MAIN3
  616                           *
  617                           *
  618                           * pl("ERROR # ");
  619                           * outdeci(errcode);
  620                           * return;
  621                           *}
  622                           *
  623                           *
  624 EAD6:CEEA E6         [ 3] RPTERR5:        LDX    #ERRORS
  625 EAD9:BDE1 1C         [ 6]         JSR    PL
  626 EADC:D618            [ 3]         LDAB   ERRCODE
  627 EADE:4F              [ 2]         CLRA
  628 EADF:7EEB 1A         [ 3]         JMP    OUTDECI
  629                           *
  630                           *
  631 EAE2.5E5E 5E              ARROWS: FCC    "^^^"
  632 EAE5.00                           FCB    0
  633 EAE6.4552 524F 5220       ERRORS: FCC    "ERROR # "
  633      2320            
  634 EAEE.00                           FCB    0
  635                           *
  636                           *
  637      EAEF                 RPTRERR:        EQU    *             ; REPORT A RUN TIME ERROR.
  638 EAEF:9718            [ 3]         STAA   ERRCODE
  639 EAF1:BDEA D6         [ 6]         JSR    RPTERR5
  640 EAF4:CEEB 0E         [ 3] RPTRERR1:       LDX    #INLINE
  641 EAF7:BDE1 1C         [ 6]         JSR    PL
  642 EAFA:DC29            [ 4]         LDD    CURLINE
  643 EAFC:BDEB 1A         [ 6]         JSR    OUTDECI
  644 EAFF:BDE1 10         [ 6]         JSR    NL
  645 EB02:8601            [ 2]         LDAA   #1
  646 EB04:971C            [ 3]         STAA   CONTFLAG
  647 EB06:7EE0 16         [ 3]         JMP    MAINW
  648                           *
  649                           *
  650 EB09.4252 4541 4B         BREAKS: FCC    "BREAK"
  651 EB0E.2049 4E20 4C49       INLINE: FCC    " IN LINE # "
  651      4E45 2023 20    
  652 EB19.00                           FCB    0
  653                                   $IF     HC11 = 0
  744                                   $ELSE
  745                           *
  746      EB1A                 OUTDECI:        EQU    *
  747 EB1A:1A83 0000       [ 5]         CPD    #0
  748 EB1E:2605 (EB25)     [ 3]         BNE    OUTDECI1
  749 EB20:8630            [ 2]         LDAA   #'0'
  750 EB22:7EFE CD         [ 3]         JMP    OUTBYTE
  751      EB25                 OUTDECI1:       EQU    *
  752 EB25:183C            [ 5]         PSHY
  753                           *        PSHD                ; SAVE THE NUMBER TO PRINT.
  754 EB27:37              [ 3]         PSHB
  755 EB28:36              [ 3]         PSHA
  756 EB29:CC27 10         [ 3]         LDD    #10000       ; NUMBER TO START DIVIDING BY.
  757                           *        PSHD
  758 EB2C:37              [ 3]         PSHB
  759 EB2D:36              [ 3]         PSHA
  760 EB2E:5F              [ 2]         CLRB                ; SET INITAL VALUE OF LEADING ZERO SUPRESS FLAG.
  761 EB2F:37              [ 3]         PSHB
  762 EB30:1830            [ 4]         TSY
  763 EB32:18EC 03         [ 6]         LDD    3,Y          ; IS THE NUMBER NEGATIVE?
  764 EB35:2A0D (EB44)     [ 3]         BPL    OUTDECI2     ; NO. GO PRINT THE NUMBER.
  765 EB37:43              [ 2]         COMA                ; YES. MAKE THE NUMBER POSITIVE.
  766 EB38:53              [ 2]         COMB                ; (TWO'S COMPLEMENT)
  767 EB39:C300 01         [ 4]         ADDD   #1
  768 EB3C:18ED 03         [ 6]         STD    3,Y          ; SAVE THE RESULT.
  769 EB3F:862D            [ 2]         LDAA   #'-'         ; PRINT A MINUS SIGN TO SHOW IT'S NEGATIVE.
  770 EB41:BDFE CD         [ 6]         JSR    OUTBYTE
  771 EB44:18EC 03         [ 6] OUTDECI2:       LDD    3,Y          ; GET THE DIVIDEND.
  772 EB47:CDEE 01         [ 6]         LDX    1,Y          ; GET THE DIVISOR.
  773 EB4A:02              [41]         IDIV                ; DO THE DIVIDE.
  774 EB4B:18ED 03         [ 6]         STD    3,Y          ; SAVE THE REMAINDER.
  775 EB4E:8F              [ 3]         XGDX                ; PUT QUOTIENT IN D.
  776 EB4F:1A83 0000       [ 5]         CPD    #0           ; IS THE QUOTIENT 0?
  777 EB53:2605 (EB5A)     [ 3]         BNE    OUTDECI3     ; NO. GO OUTPUT THE NUMBER.
  778 EB55:186D 00         [ 7]         TST    0,Y          ; YES. ARE WE STILL SUPRESSING LEADING ZEROS?
  779 EB58:270B (EB65)     [ 3]         BEQ    OUTDECI4     ; YES. DON'T PRINT THE NUMBER.
  780 EB5A:17              [ 2] OUTDECI3:       TBA                 ; PUT THE NUMBER IN THE A-REG.
  781 EB5B:8B30            [ 2]         ADDA   #$30         ; MAKE THE NUMBER ASCII.
  782 EB5D:C601            [ 2]         LDAB   #1           ; MAKE THE ZERO SUPRESS FLAG NON-ZERO.
  783 EB5F:18E7 00         [ 5]         STAB   0,Y
  784 EB62:BDFE CD         [ 6]         JSR    OUTBYTE      ; OUTPUT THE NUMBER.
  785 EB65:18EC 01         [ 6] OUTDECI4:       LDD    1,Y          ; GET CURRENT DIVISOR.
  786 EB68:CE00 0A         [ 3]         LDX    #10          ; DIVIDE IT BY 10.
  787 EB6B:02              [41]         IDIV
  788 EB6C:CDEF 01         [ 6]         STX    1,Y          ; SAVE RESULT. ARE WE DONE?
  789 EB6F:26D3 (EB44)     [ 3]         BNE    OUTDECI2     ; NO KEEP GOING.
  790 EB71:C605            [ 2]         LDAB   #5           ; DEALLOCATE LOCALS.
  791 EB73:183A            [ 4]         ABY
  792 EB75:1835            [ 4]         TYS
  793 EB77:1838            [ 6]         PULY                ; RESTORE Y.
  794 EB79:39              [ 5]         RTS                 ; RETURN.
  795                           *
  796                           *
  797                                   $ENDIF
  798                           *
  799                           *
*** END   INCLUDE FILE: BASICLB4.ASM *** (RESUMING FILE: BASIC11.ASM)
   12                           #Include  'LEDITOR.Asm'
*** BEGIN INCLUDE FILE: LEDITOR.ASM ***
    1                           *        title    LEDITOR.TXT
    2                           *        page
    3                           */***** storlin() *****/
    4                           *
    5                           *storlin()
    6                           *{
    7                           * int *numptr,*linum;
    8                           * numptr=tknbuf;                 /* get int pointer into token buffer */
    9                           * if(*numptr>hiline)             /* line # larger than current hi line*/
   10                           * {
   11                           *  apendlin();                   /* append it to the end of the buffer */
   12                           *  hiline=*numptr;               /* make it the current hi line number */
   13                           *  return;
   14                           * }
   15                           *
   16                           *
   17      EB7A                 STORLIN:        EQU    *
   18 EB7A:8601            [ 2]         LDAA   #1               ;set the continue flag.
   19 EB7C:971C            [ 3]         STAA   CONTFLAG ; we don't allow continues if the program has been altered.
   20 EB7E:DE4B            [ 4]         LDX     TKNBUFS ; point to the start of the token buffer
   21 EB80:EC00            [ 5]         LDD    0,X      ; get the first 2 bytes of the token buffer (the line number).
   22 EB82:1A93 0C         [ 6]         CPD    HILINE   ; was the entered lines number higher than the highest so far?
   23 EB85:230A (EB91)     [ 3]         BLS    STORLIN1 ; no. go do an insert or replace operation.
   24 EB87:BDEC 69         [ 6]         JSR    APENDLIN ; yes. just append the line to the end of the program buffer.
   25 EB8A:DE4B            [ 4]         LDX    TKNBUFS  ; point to the start of the token buffer
   26 EB8C:EC00            [ 5]         LDD    0,X      ; get the first 2 bytes of the token buffer (the line number).
   27 EB8E:DD0C            [ 4]         STD    HILINE
   28 EB90:39              [ 5]         RTS             ; return.
   29                           *
   30                           *
   31                           * linum=findline(*numptr);       /* look for line # in the program buffer */
   32                           * if(*linum==*numptr)            /* is it the same line #? */
   33                           * {
   34                           *  repline(linum);               /* yes. replace it with the new line */
   35                           *  return;
   36                           * }
   37                           * insrtlin(linum);               /* no. insert the new line in the buffer */
   38                           * return;
   39                           *}
   40                           *
   41                           *
   42      EB91                 STORLIN1:       EQU    *
   43 EB91:8D56 (EBE9)     [ 6]         BSR    FINDLINE
   44 EB93:EC00            [ 5]         LDD    0,X
   45 EB95:3C              [ 4]         PSHX
   46 EB96:DE4B            [ 4]         LDX    TKNBUFS
   47 EB98:1AA3 00         [ 7]         CPD    0,X
   48 EB9B:38              [ 5]         PULX
   49 EB9C:266A (EC08)     [ 3]         BNE    INSRTLIN
   50 EB9E:7EEC 86         [ 3]         JMP    REPLINE
   51                           *
   52                           *
   53                           * /***** delline() *****/
   54                           *
   55                           *delline(num)            /* delete line from basic buffer */
   56                           *int num;
   57                           *{
   58                           * int *linum;
   59                           * char *ptr;
   60                           * if(num > hiline) return;       /* line number can't be there, return */
   61                           * linum=findline(num);           /* look for the requested line # */
   62                           *
   63                           *
   64      EBA1                 DELLINE:        EQU    *
   65                           *        PSHD           ; SAVE THE LINE NUMBER TO DELETE.
   66 EBA1:37              [ 3]         PSHB
   67 EBA2:36              [ 3]         PSHA
   68 EBA3:1830            [ 4]         TSY             ; POINT TO THE LINE NUMBER WE SAVED.
   69 EBA5:1A93 0C         [ 6]         CPD    HILINE   ; IS IT HIGHER THAN THE HIGHEST LINE ENTERED SO FAR?
   70 EBA8:2307 (EBB1)     [ 3]         BLS    DELLINE1 ; NO. GO SEE IF THE LINE EXISTS.
   71 EBAA:8601            [ 2] DELLINE2:       LDAA   #1               ; YES. THE LINE CANNOT EXIST.
   72 EBAC:971C            [ 3]         STAA   CONTFLAG
   73                           *        PULD           ; PULL THE LINE NUMBER OFF THE STACK.
   74 EBAE:32              [ 4]         PULA
   75 EBAF:33              [ 4]         PULB
   76 EBB0:39              [ 5]         RTS             ; RETURN.
   77 EBB1:8D36 (EBE9)     [ 6] DELLINE1:       BSR    FINDLINE ; GO SEE IF THE LINE EXISTS.
   78                                                   ; RETURN A POINTER TO A LINE NUMBER IN THE BASIC PROGRAM BUFFER.
   79                           *
   80                           *
   81                           * if(*linum!=num) return;        /* if the line # doesn't exist, return */
   82                           * ptr=linum;                     /* make the int pointer a char pointer */
   83                           * closespc(ptr[2],ptr);          /* go delete the line */
   84                           * if(num==hiline) hiline=findhiln();
   85                           * return;
   86                           *}
   87                           *
   88                           *
   89 EBB3:EC00            [ 5]         LDD    0,X      ; GET THE LINE NUMBER THAT WAS FOUND.
   90 EBB5:CDA3 00         [ 7]         CPD    0,Y      ; WAS THE LINE NUMBER FOUND THE ONE THAT WAS REQUESTED TO BE DELETED.
   91 EBB8:26F0 (EBAA)     [ 3]         BNE    DELLINE2 ; NO. THE LINE DOESN'T EXIST. JUST RETURN.
   92 EBBA:E602            [ 4]         LDAB   2,X      ; YES. GET THE LENGTH OF THE LINE.
   93 EBBC:8D0D (EBCB)     [ 6]         BSR    CLOSESPC ; GO CLOSE THE SPACE IN THE PROGRAM BUFFER.
   94 EBBE:DC0C            [ 4]         LDD    HILINE   ; GET THE HIGHEST LINE NUMBER ENTERED.
   95 EBC0:CDA3 00         [ 7]         CPD    0,Y      ; DID WE DELETE THE HIGHEST LINE NUMBER?
   96 EBC3:26E5 (EBAA)     [ 3]         BNE    DELLINE2 ; NO. JUST RETURN.
   97 EBC5:8D31 (EBF8)     [ 6]         BSR    FINDHILN ; YES. GO FIND THE HIGHEST LINE NUMBER.
   98 EBC7:DD0C            [ 4]         STD    HILINE   ; SAVE IT.
   99 EBC9:20DF (EBAA)     [ 3]         BRA    DELLINE2 ; RETURN.
  100                           *
  101                           *
  102                           */***** closespc() *****/        /* close up space in the BASIC buffer */
  103                           *
  104                           *closespc(bytes,ptr)
  105                           *char bytes,*ptr;
  106                           *{
  107                           * char *to,*from;                /* define the from/to pointers */
  108                           * to=ptr;                        /* set up destination pointer */
  109                           * from=ptr+bytes;                /* setup source pointer */
  110                           * while(from<basend)             /* while we're not at the end of the buff */
  111                           * { *to++=*from++; }             /* move source to destination */
  112                           * basend=to;                     /* set new basend pointer */
  113                           * return;
  114                           *}
  115                           *
  116                           *
  117      EBCB                 CLOSESPC:       EQU    *                ; ENTERED WITH
  118 EBCB:183C            [ 5]         PSHY            ; SAVE THE CURRENT VALUE OF Y.
  119 EBCD:3C              [ 4]         PSHX            ; TRANSFER X TO Y BY... PUSHING X AND THEN
  120 EBCE:1838            [ 6]         PULY            ; PULLING Y.
  121 EBD0:183A            [ 4]         ABY             ; ADD THE LENGTH TO Y.
  122 EBD2:189C 06         [ 6] CLOSESP1:       CPY    BASEND   ; HAVE WE MOVED ALL THE BYTES?
  123 EBD5:240A (EBE1)     [ 3]         BHS    CLOSESP2 ; YES. RETURN.
  124 EBD7:18A6 00         [ 5]         LDAA   0,Y      ; NO. GET A BYTE.
  125 EBDA:A700            [ 4]         STAA   0,X      ; MOVE IT.
  126 EBDC:08              [ 3]         INX             ; ADVANCE THE DESTINATION POINTER.
  127 EBDD:1808            [ 4]         INY             ; ADVANCE THE SOURCE POINTER.
  128 EBDF:20F1 (EBD2)     [ 3]         BRA    CLOSESP1 ; GO CHECK TO SEE IF WE'RE DONE.
  129 EBE1:DF06            [ 4] CLOSESP2:       STX    BASEND   ; SAVE THE NEW 'END OF BASIC PROGRAM' POINTER.
  130 EBE3:BDEC C9         [ 6]         JSR    MOVEVARSDN       ; MOVE ALL THE VARIABLES DOWN.
  131 EBE6:1838            [ 6]         PULY            ; RESTORE Y.
  132 EBE8:39              [ 5]         RTS             ; RETURN.
  133                           *
  134                           *
  135                           */***** findline() *****/        /* return pointer to line number or next
  136                           *                                   highest line number */
  137                           *findline(linenum)
  138                           *int linenum;
  139                           *{
  140                           * char *linelen;
  141                           * int *basbufp;
  142                           * basbufp=basbeg;                /* set pointer to start of basic buffer */
  143                           * while(*basbufp<linenum)        /* do until we find line # or one higher */
  144                           * {
  145                           *  linelen=basbufp;              /* convert int pointer to char pointer */
  146                           *  basbufp=linelen+linelen[2];   /* convert char ptr back to int pointer */
  147                           * }
  148                           * return(basbufp);               /* return the pointer */
  149                           *}
  150                           *
  151                           *
  152      EBE9                 FINDLINE:       EQU    *
  153 EBE9:DE04            [ 4]         LDX    BASBEG
  154 EBEB:1AA3 00         [ 7] FINDLIN1:       CPD    0,X
  155 EBEE:2307 (EBF7)     [ 3]         BLS    FINDLIN2
  156 EBF0:37              [ 3]         PSHB
  157 EBF1:E602            [ 4]         LDAB   2,X
  158 EBF3:3A              [ 3]         ABX
  159 EBF4:33              [ 4]         PULB
  160 EBF5:20F4 (EBEB)     [ 3]         BRA    FINDLIN1
  161 EBF7:39              [ 5] FINDLIN2:       RTS
  162                           *
  163                           *
  164                           */***** findhiln() *****/
  165                           *
  166                           *findhiln()                      /* find highest line number in basic buffer **/*{
  167                           * int *iptr,lnum;
  168                           * char *cptr;
  169                           * lnum=0;                        /* set line # to 0 */
  170                           * iptr=basbeg;                   /* set int pointer to basbeg */
  171                           * while(iptr!=basend)            /* we're not to the end of the basic buff */
  172                           * {
  173                           *  lnum=*iptr;                   /* get current line # */
  174                           *  cptr=iptr;                    /* convert int pointer to char pointer */
  175                           *  iptr=cptr+cptr[2];            /* add line length, point to next line */
  176                           * }
  177                           * return(lnum);                  /* return highest line number */
  178                           *}
  179                           *
  180                           *
  181      EBF8                 FINDHILN:       EQU    *
  182 EBF8:DE04            [ 4]         LDX    BASBEG
  183 EBFA:9C06            [ 5] FINDHIL1:       CPX    BASEND
  184 EBFC:2709 (EC07)     [ 3]         BEQ    FINDHIL2
  185 EBFE:EC00            [ 5]         LDD    0,X
  186 EC00:37              [ 3]         PSHB
  187 EC01:E602            [ 4]         LDAB   2,X
  188 EC03:3A              [ 3]         ABX
  189 EC04:33              [ 4]         PULB
  190 EC05:20F3 (EBFA)     [ 3]         BRA    FINDHIL1
  191 EC07:39              [ 5] FINDHIL2:       RTS
  192                           *
  193                           *
  194                           */***** insrtlin() *****/
  195                           *
  196                           *insrtlin(ptr)
  197                           *char *ptr;
  198                           *{
  199                           * openspc(tknbuf[2],ptr);        /* go open space in the program bufer */
  200                           * if(errcode) return;            /* return if out of memory */
  201                           * putline(ptr);                  /* put line into buffer */
  202                           * return;
  203                           *}
  204                           *
  205                           *
  206      EC08                 INSRTLIN:       EQU    *
  207 EC08:3C              [ 4]         PSHX
  208 EC09:DE4B            [ 4]         LDX     TKNBUFS
  209 EC0B:E602            [ 4]         LDAB   2,X
  210 EC0D:38              [ 5]         PULX
  211 EC0E:3C              [ 4]         PSHX
  212 EC0F:8D03 (EC14)     [ 6]         BSR    OPENSPC
  213 EC11:38              [ 5]         PULX
  214 EC12:2040 (EC54)     [ 3]         BRA    PUTLINE
  215                           *
  216                           *
  217                           */***** openspc() *****/         /* open space in program buffer */
  218                           *
  219                           *openspc(bytes,ptr)
  220                           *char bytes,*ptr;
  221                           *{
  222                           * char *to,*from;                /* declare to/from pointers */
  223                           * from=basend;                   /* set source at end of buffer */
  224                           * to=basend+bytes;               /* set destination "bytes" beyond source */
  225                           * if(to>basmend)                 /* if out of memory, return an error */
  226                           * { errcode=OMEMERR; return; }
  227                           * basend=to;                     /* set new end of buffer */
  228                           * while(from>=ptr)
  229                           * { *to--=*from--; }             /* open up area in buffer */
  230                           * return;
  231                           *}
  232                           *
  233      EC14                 OPENSPC:        EQU    *
  234 EC14:183C            [ 5]         PSHY
  235 EC16:3C              [ 4]         PSHX
  236 EC17:DE0A            [ 4]         LDX    VAREND
  237 EC19:3A              [ 3]         ABX
  238 EC1A:9C0E            [ 5]         CPX    BASMEND
  239 EC1C:222B (EC49)     [ 3]         BHI    OPENSPC4
  240 EC1E:BDEC A3         [ 6]         JSR    MOVEVARSUP
  241 EC21:DE06            [ 4]         LDX    BASEND
  242 EC23:3C              [ 4]         PSHX
  243 EC24:3A              [ 3]         ABX
  244 EC25:3C              [ 4]         PSHX
  245 EC26:1830            [ 4]         TSY
  246 EC28:18EC 00         [ 6]         LDD    0,Y
  247 EC2B:DD06            [ 4] OPENSPC1:       STD    BASEND
  248 EC2D:18EC 02         [ 6] OPENSPC3:       LDD    2,Y
  249 EC30:CDA3 04         [ 7]         CPD    4,Y
  250 EC33:2519 (EC4E)     [ 3]         BLO    OPENSPC2
  251 EC35:CDEE 02         [ 6]         LDX    2,Y
  252 EC38:A600            [ 4]         LDAA   0,X
  253 EC3A:09              [ 3]         DEX
  254 EC3B:CDEF 02         [ 6]         STX    2,Y
  255 EC3E:CDEE 00         [ 6]         LDX    0,Y
  256 EC41:A700            [ 4]         STAA   0,X
  257 EC43:09              [ 3]         DEX
  258 EC44:CDEF 00         [ 6]         STX    0,Y
  259 EC47:20E4 (EC2D)     [ 3]         BRA    OPENSPC3
  260 EC49:8609            [ 2] OPENSPC4:       LDAA   #OMEMERR
  261 EC4B:7EEA 98         [ 3]         JMP    RPTERR
  262 EC4E:38              [ 5] OPENSPC2:       PULX
  263 EC4F:38              [ 5]         PULX
  264 EC50:38              [ 5]         PULX
  265 EC51:1838            [ 6]         PULY
  266 EC53:39              [ 5]         RTS
  267                           *
  268                           *
  269                           */***** putline() *****/         /* move line from token buffer to program
  270                           *                                   buffer */
  271                           *putline(cptr)
  272                           *char *cptr;
  273                           *{
  274                           * short count;
  275                           * count=tknbuf[2];               /* get length of line in token buffer */
  276                           * tbufptr=tknbuf;                /* point to start of token buffer */
  277                           * while(count)
  278                           * {
  279                           *  *cptr++=*tbufptr++;           /* move a byte */
  280                           *  --count;                      /* decrement the byte count */
  281                           * }
  282                           * return;
  283                           *}
  284                           *
  285                           *
  286      EC54                 PUTLINE:        EQU    *
  287 EC54:3C              [ 4]         PSHX
  288 EC55:DE4B            [ 4]         LDX    TKNBUFS
  289 EC57:E602            [ 4]         LDAB   2,X
  290 EC59:38              [ 5]         PULX
  291 EC5A:18DE 4B         [ 5]         LDY    TKNBUFS
  292 EC5D:18A6 00         [ 5] PUTLINE1:       LDAA   0,Y
  293 EC60:1808            [ 4]         INY
  294 EC62:A700            [ 4]         STAA   0,X
  295 EC64:08              [ 3]         INX
  296 EC65:5A              [ 2]         DECB
  297 EC66:26F5 (EC5D)     [ 3]         BNE    PUTLINE1
  298 EC68:39              [ 5]         RTS
  299                           *
  300                           *
  301                           */***** apendlin() *****/        /* appent line to end of program buffer */
  302                           *
  303                           *apendlin()
  304                           *{
  305                           * if((basend+tknbuf[2])<=basmend)  /* do we have enough memory left? */
  306                           * {
  307                           *  putline(basend);              /* move the line */
  308                           *  basend+=tknbuf[2];            /* set the new end of basic pointer */
  309                           * }
  310                           * else errcode=OMEMERR;          /* not enough memory, error */
  311                           * return;
  312                           *}
  313                           *
  314                           *
  315      EC69                 APENDLIN:       EQU    *
  316 EC69:DE4B            [ 4]         LDX    TKNBUFS
  317 EC6B:E602            [ 4]         LDAB   2,X
  318 EC6D:DE0A            [ 4]         LDX    VAREND
  319 EC6F:3A              [ 3]         ABX
  320 EC70:9C0E            [ 5]         CPX    BASMEND
  321 EC72:220D (EC81)     [ 3]         BHI    APENDLN1
  322                           *       LDAB   TKNBUF+2
  323 EC74:BDEC A3         [ 6]         JSR    MOVEVARSUP
  324 EC77:DE06            [ 4]         LDX    BASEND
  325 EC79:3A              [ 3]         ABX
  326 EC7A:8F              [ 3]         XGDX
  327 EC7B:DE06            [ 4]         LDX    BASEND
  328 EC7D:DD06            [ 4]         STD    BASEND
  329 EC7F:20D3 (EC54)     [ 3]         BRA    PUTLINE
  330 EC81:8609            [ 2] APENDLN1:       LDAA   #OMEMERR
  331 EC83:7EEA 98         [ 3]         JMP    RPTERR
  332                           *
  333                           *
  334                           */***** repline() *****/         /* replace line in buffer */
  335                           *
  336                           *repline(ptr)
  337                           *char *ptr;
  338                           *{
  339                           * short lendif,temp1,temp2;
  340                           * temp1=*(ptr+2);                /* convert type from char to int */
  341                           * temp2=(tknbuf[2]);
  342                           * lendif=temp1-temp2;            /* get the difference in line length */
  343                           *      if(lendif==0)             /* if the same, just write over the old */
  344                           *      {
  345                           *       putline(ptr);
  346                           *      }
  347                           *
  348                           *
  349      EC86                 REPLINE:        EQU    *
  350 EC86:E602            [ 4]         LDAB   2,X
  351 EC88:3C              [ 4]         PSHX
  352 EC89:DE4B            [ 4]         LDX   TKNBUFS
  353 EC8B:E002            [ 4]         SUBB   2,X
  354 EC8D:38              [ 5]         PULX
  355 EC8E:2602 (EC92)     [ 3]         BNE    REPLINE1
  356 EC90:20C2 (EC54)     [ 3]         BRA    PUTLINE
  357                           *
  358                           *
  359                           * else if(lendif<0)              /* if line in tknbuf is larger */
  360                           *      {
  361                           *       lendif=-lendif;          /* make it a positive number */
  362                           *       openspc(lendif,ptr);     /* tru to open up a space */
  363                           *       if(errcode) return;      /* if not enough memory, return */
  364                           *       putline(ptr);            /* if ok, copy line to program buffer */
  365                           *      }
  366                           *
  367                           *
  368      EC92                 REPLINE1:       EQU    *
  369 EC92:2A08 (EC9C)     [ 3]         BPL    REPLINE2
  370 EC94:50              [ 2]         NEGB
  371 EC95:3C              [ 4]         PSHX
  372 EC96:BDEC 14         [ 6]         JSR    OPENSPC
  373 EC99:38              [ 5]         PULX
  374 EC9A:20B8 (EC54)     [ 3]         BRA    PUTLINE
  375                           *
  376                           *
  377                           * else                           /* if line in tknbuf is smaller */
  378                           *      {
  379                           *       closespc(lendif,ptr);    /* close up excess space */
  380                           *       putline(ptr);            /* put new line in program buffer */
  381                           *      }
  382                           * return;
  383                           *}
  384                           *
  385                           *
  386      EC9C                 REPLINE2:       EQU    *
  387 EC9C:3C              [ 4]         PSHX
  388 EC9D:BDEB CB         [ 6]         JSR    CLOSESPC
  389 ECA0:38              [ 5]         PULX
  390 ECA1:20B1 (EC54)     [ 3]         BRA    PUTLINE
  391                           *
  392                           *
  393      ECA3                 MoveVarsUp:
  394 ECA3:183C            [ 5]         PSHY            ; SAVE THE Y REGISTER.
  395 ECA5:37              [ 3]         PSHB            ; SAVE THE BYTE COUNT.
  396 ECA6:DE0A            [ 4]         LDX     VAREND  ; POINT TO THE END OF THE VARIABLE MEMORY SPACE.
  397 ECA8:18DE 0A         [ 5]         LDY     VAREND  ; POINT TO THE END OF VARIABLE MEMORY SPACE.
  398 ECAB:3A              [ 3]         ABX             ; ADD THE NUMBER OF BYTES TO MOVE TO THE POINTER.
  399 ECAC:DC0A            [ 4]         LDD     VAREND  ; GET THE CURRENT VARIABLE TABLE ENDING ADDRESS.
  400 ECAE:DF0A            [ 4]         STX     VAREND  ; SAVE THE NEW END OF VARIABLE TABLE POINTER.
  401 ECB0:9308            [ 5]         SUBD    VARBEGIN        ; CALCULATE THE NUMBER OF BYTES TO MOVE.
  402 ECB2:270F (ECC3)     [ 3]         BEQ     MOVEUP2 ; JUST RETURN IF THERE IS NOTHING TO MOVE.
  403 ECB4:DD6C            [ 4]         std     VarSize ; save the size of the variable table (9/12/89).
  404 ECB6:18A6 00         [ 5] MOVEUP1:        LDAA    0,Y     ; GET A BYTE.
  405 ECB9:A700            [ 4]         STAA    0,X     ; MOVE IT.
  406 ECBB:09              [ 3]         DEX
  407 ECBC:1809            [ 4]         DEY
  408 ECBE:8D32 (ECF2)     [ 6]         bsr     DecCount        ; DECREMENT THE BYTE COUNT. ARE WE DONE? (9/12/89).
  409 ECC0:2AF4 (ECB6)     [ 3]         BPL     MOVEUP1 ; GO TILL WE'RE DONE.
  410 ECC2:08              [ 3]         INX             ; ADJUST THE POINTER
  411 ECC3:DF08            [ 4] MOVEUP2:        STX     VARBEGIN  ; SAVE THE NEW START OF VARIABLE TABLE POINTER.
  412 ECC5:33              [ 4]         PULB            ; RESTORE THE BYTE COUNT.
  413 ECC6:1838            [ 6]         PULY            ; RESTORE Y.
  414 ECC8:39              [ 5]         RTS             ; RETURN.
  415                           *
  416                           *
  417      ECC9                 MoveVarsDn:
  418 ECC9:183C            [ 5]         PSHY            ; SAVE Y.
  419 ECCB:37              [ 3]         PSHB            ; SAVE THE BYTE COUNT.
  420 ECCC:18DE 08         [ 5]         LDY     VARBEGIN        ; POINT TO THE CURRENT START OF THE VARIABLE TABLE.
  421 ECCF:86FF            [ 2]         LDAA    #$FF    ; MAKE THE BYTE COUNT NEGATIVE SO WE CAN JUST ADD.
  422 ECD1:50              [ 2]         NEGB                    
  423 ECD2:D308            [ 5]         ADDD    VARBEGIN        ; CALCULATE THE NEW START OF THE VARIABLE TABLE.
  424 ECD4:8F              [ 3]         XGDX            ; PUT THE NEW STARTING ADDRESS OF THE VARIABLE TABLE INTO X.
  425 ECD5:DC0A            [ 4]         LDD     VAREND  ; GET THE OLD TABLE ENDING ADDRESS.
  426 ECD7:9308            [ 5]         SUBD    VARBEGIN        ; SUBTRACT THE OLD TABLE STARTING ADDRESS TO GET THE SIZE OF THE TABLE.
  427 ECD9:DF08            [ 4]         STX     VARBEGIN        ; SAVE THE POINTER TO THE NEW START OF THE VARIABLE TABLE.
  428 ECDB:DD6C            [ 4]         std     VarSize ; save the size of the variable table (9/12/89).
  429 ECDD:270D (ECEC)     [ 3]         BEQ     MOVEDN2 ; IF THE SIZE IS 0 (NO VARIABLES ALLOCATED) EXIT.
  430 ECDF:18A6 00         [ 5] MOVEDN1:        LDAA    0,Y     ; GET A BYTE.
  431 ECE2:A700            [ 4]         STAA    0,X     ; MOVE IT.
  432 ECE4:08              [ 3]         INX             ; MOVE THE DESTINATION POINTER.
  433 ECE5:1808            [ 4]         INY             ; MOVE THE SOURCE POINTER.
  434 ECE7:8D09 (ECF2)     [ 6]         bsr     DecCount        ; DECREMENT THE BYTE COUNT. ARE WE DONE? (9/12/89).
  435 ECE9:2AF4 (ECDF)     [ 3]         BPL     MOVEDN1 ; NO. KEEP MOVIN' THEM BYTES.
  436 ECEB:09              [ 3]         DEX
  437 ECEC:DF0A            [ 4] MOVEDN2:        STX     VAREND  ; SAVE THE NEW POINTER TO THE END OF THE VARIABLE TABLE.
  438 ECEE:33              [ 4]         PULB            ; RESTORE THE BYTE COUNT.
  439 ECEF:1838            [ 6]         PULY            ; RESTORE Y.
  440 ECF1:39              [ 5]         RTS             ; RETURN.
  441                           *
  442                           *
  443      ECF2                 DecCount:
  444 ECF2:DC6C            [ 4]         ldd     VarSize ; get the size of the variable table.
  445 ECF4:8300 01         [ 4]         subd    #1      ; decrement it.
  446 ECF7:DD6C            [ 4]         std     VarSize ; save the new value.
  447 ECF9:39              [ 5]         rts             ; return.
*** END   INCLUDE FILE: LEDITOR.ASM *** (RESUMING FILE: BASIC11.ASM)
   13                           #Include  'INITS.Asm'
*** BEGIN INCLUDE FILE: INITS.ASM ***
    1                           *       title   Inits.Asm
    2                           *
    3                           *
    4                           */***** initvars() *****/
    5                           *
    6                           *initvars()
    7                           *{
    8                           * char *x;
    9                           * varbegin=varend=0x7000;
   10                           * varmend=0x7FFF;
   11                           * for(x=varbegin; x<=varmend; x++) *x=0;
   12                           * basbeg=basend=0x4000;
   13                           * basmend=0x6FFF;
   14                           * for(x=basbeg; x<=basmend; x++) *x=0;
   15                           * hiline=0;
   16                           * return;
   17                           *}
   18                           *
   19                           *
   20      ECFA                 INITVARS:       EQU    *
   21 ECFA:FEFF C0         [ 5]         LDX    RAMStart     ; YES. VARIABLES START AT RAMBEG.
   22 ECFD:DF08            [ 4]         STX    VARBEGIN     ; SET POINTERS TO BOTH START AND END OF VARIABLE
   23 ECFF:DF0A            [ 4]         STX    VAREND       ; STORAGE.
   24 ED01:DF04            [ 4]         STX    BASBEG       ; SET POINTERS TO BOTH THE START AND END OF THE
   25 ED03:DF06            [ 4]         STX    BASEND       ; BASIC PROGRAM.
   26 ED05:8F              [ 3]         XGDX            ; GET THE START OF RAM INTO D
   27 ED06:F3FF C2         [ 6]         ADDD   RAMSize  ; add the size of the RAM to it.
   28 ED09:8302 51         [ 4]         SUBD   #SWSTKSize+1     ; subtract the size of the software stack, token & input buffers.
   29 ED0C:DD10            [ 4]         STD    VARMEND      ; SAVE THE POINTER.
   30 ED0E:DD0E            [ 4]         STD    BASMEND      ; MAKE IT THE END OF BASIC PROGRAM MEMORY.
   31 ED10:C300 01         [ 4]         addd   #1               ; Set up a pointer to the input buffer.
   32 ED13:DD49            [ 4]         std    INBUFFS  ; Save the pointer.
   33 ED15:C300 50         [ 4]         addd   #IBUFLEN     ; add the length of the input buffer to create a pointer to the token buffer.
   34 ED18:DD4B            [ 4]         std    TKNBUFS  ; save the pointer.
   35 ED1A:C300 80         [ 4]         addd   #TBUFLEN     ; add the length of the token buffer to create a pointer to the end of the operand stack.
   36 ED1D:DD4D            [ 4]         std    EOPSTK       ; save the pointer to the end of the operator stack.
   37 ED1F:C300 1E         [ 4]         addd   #OPSLEN  ; add the length of the operand stack.
   38 ED22:DD4F            [ 4]         std    STOPS    ; save the pointer to the start of the operator stack.
   39 ED24:DD51            [ 4]         std    ENUMSTK  ; also make it the end of the operand stack.
   40 ED26:C300 3C         [ 4]         addd   #NUMSLEN     ; add the length of the operand stack.
   41 ED29:DD53            [ 4]         std    STNUMS   ; save the result as the start of the operand stack.
   42 ED2B:DD55            [ 4]         std    EFORSTK  ; also make it the end of the FOR stack.
   43 ED2D:C300 50         [ 4]         addd   #FORSLEN     ; Add the length of the FOR stack.
   44 ED30:DD57            [ 4]         std    STFORSTK     ; save the result as the start of the FOR stack.
   45 ED32:DD59            [ 4]         std    EWHSTK   ; also make it the end of the while stack.
   46 ED34:C300 10         [ 4]         addd   #WHSLEN  ; add the length of the while stack.
   47 ED37:DD5B            [ 4]         std    STWHSTK  ; save the pointer as the start of the while stack.
   48 ED39:DD5D            [ 4]         std    EGOSTK   ; also make it the end of the GOSUB stack.
   49 ED3B:C300 10         [ 4]         addd   #GOSLEN  ; add the length of the GOSUB stack.
   50 ED3E:DD5F            [ 4]         std    STGOSTK  ; save it as the start of the GOSUB stack.
   51 ED40:DE04            [ 4]         LDX    BASBEG   ; point to the start of the basic program buffer.
   52 ED42:6F00            [ 6] INIT1:  CLR    0,X          ; CLEAR THE STORAGE TO ZERO.
   53 ED44:08              [ 3]         INX                 ; POINT TO THE NEXT LOCATION.
   54 ED45:9C0E            [ 5]         CPX    BASMEND      ; ARE WE DONE?
   55 ED47:23F9 (ED42)     [ 3]         BLS    INIT1        ; NO. KEEP CLEARING.
   56                           *                             ; YES. POINT TO THE PHYSICAL END OF MEMORY.
   57 ED49:FEFF C4         [ 5]         ldx    EEStart
   58 ED4C:A60A            [ 4]         LDAA   AUTOSTF,X    ; GET THE AUTO START FLAG AGAIN.
   59 ED4E:8155            [ 2]         CMPA   #$55         ; IS THE AUTO START MODE SET?
   60 ED50:2603 (ED55)     [ 3]         BNE    INIT5        ; NO. DO A NORMAL INIT.
   61                           *
   62 ED52:BDF3 AA         [ 6]         JSR    AUTOLOAD     ; GO LOAD the program and VARIABLES INTO RAM.
   63 ED55:CC00 00         [ 3] INIT5:  LDD    #0           ; MAKE THE HIGHEST LINE IN THE PROGRAM 0.
   64 ED58:DD0C            [ 4]         STD    HILINE
   65 ED5A:DD29            [ 4]         STD    CURLINE      ; MAKE THE CURRENT LINE #0.
   66 ED5C:BDF2 86         [ 6]         JSR    RUNINIT      ; GO INITALIZE ALL THE SOFTWARE STACKS.
   67 ED5F:7F00 1B         [ 6]         CLR    TRFLAG       ; TURN THE TRACE MODE OFF.
   68 ED62:8601            [ 2]         LDAA   #1           ; "CONT" COMMAND NOT ALLOWED.
   69 ED64:971C            [ 3]         STAA   CONTFLAG
   70                           ;JKJ : Not present!
   71                           ;        LDX    DFLOPADR     ; point to the D-Flip flop address.
   72                           ;        STAA   0,X          ; CONNECT SCI RX PIN TO THE HOST CONNECTOR.
   73 ED66:7F00 37         [ 6]         CLR    DEVNUM       ; MAKE THE DEFAULT DEVICE NUMBER 0 (CONSOLE).
   74 ED69:7F00 19         [ 6]         clr    IMMID        ; clear the immediate mode flag (added 9/17/90).
   75 ED6C:DE0A            [ 4]         LDX    VAREND   ; GET THE POINTER TO THE END OF VARIABLE STORAGE.
   76 ED6E:08              [ 3]         INX             ; BUMP IT BY 1.
   77 ED6F:DF2D            [ 4]         STX    STRASTG  ; POINT TO THE DYNAMIC ARRAY STORAGE.
   78 ED71:39              [ 5]         RTS                 ; RETURN.
   79                           *
   80                           *
   81                           *
   82      ED72                 POWERUP:        EQU    *
   83 ED72:FCFF C8         [ 5]         LDD    IOBASE   ; GET THE BASE ADDRESS OF THE I/O REGISTERS.
   84 ED75:DD61            [ 4]         STD    IOBaseV
   85 ED77:44              [ 2]         LSRA
   86 ED78:44              [ 2]         LSRA
   87 ED79:44              [ 2]         LSRA
   88 ED7A:44              [ 2]         LSRA
   89 ED7B:B710 3D         [ 4]         STAA   $103D    ; remap the I/0 regs to where the user wants them.
   90 ED7E:DE61            [ 4]         LDX    IOBaseV      ; point to the I/O Register Base.
   91 ED80:8693            [ 2]         LDAA   #$93         ; TURN ON A/D, USE E CLOCK, SET IRQ LEVEL SENSITIVE
   92 ED82:A739            [ 4]         STAA   OPTION,X     ; DELAY AFTER STOP, DISABLE CLOCK MONITOR, SET COP
   93                           *                             ; TIMMER PREIOD TO MAX.
   94 ED84:8603            [ 2]         LDAA   #$03         ; SET THE TIMER PRESCALER TO /16.
   95 ED86:A724            [ 4]         STAA   TMSK2,X
   96                           *
   97 ED88:FCFF C0         [ 5]         LDD    RAMStart ; Get start of RAM.
   98 ED8B:F3FF C2         [ 6]         ADDD   RAMSize  ; Add the size of the RAM to it.
   99 ED8E:8F              [ 3]         XGDX            ; Put the calculated address into X.
  100 ED8F:35              [ 3]         TXS             ; Transfer the address to the stack pointer.
  101                           *
  102 ED90:CE00 C4         [ 3]         LDX    #RAMVECTS    ; POINT TO THE RAM INTERRUPT VECTOR TABLE.
  103 ED93:18CE EDFB       [ 4]         LDY    #RETII       ; GET ADDRESS OF RTI INSTRUCTION.
  104 ED97:C614            [ 2]         LDAB   #20          ; PUT THE "JMP" OPCODE INTO ALL VECTOR LOCATIONS.
  105 ED99:867E            [ 2]         LDAA   #JMPOP       ; GET THE JMP OPCODE.
  106 ED9B:A700            [ 4] POWERUP1:       STAA   0,X          ; STORE IT.
  107 ED9D:08              [ 3]         INX                 ; POINT TO THE NEXT VECTOR.
  108 ED9E:1AEF 00         [ 6]         STY    0,X          ; INITALIZE VECTOR TO "RTI".
  109 EDA1:08              [ 3]         INX
  110 EDA2:08              [ 3]         INX
  111 EDA3:5A              [ 2]         DECB                ; DONE?
  112 EDA4:26F5 (ED9B)     [ 3]         BNE    POWERUP1     ; NO. INITALIZE ALL VECTORS.
  113 EDA6:CE00 F7         [ 3]         LDX    #ILLOP       ; POINT TO THE ILLEGAL OP-CODE VECTOR.
  114 EDA9:CCED 72         [ 3]         LDD    #POWERUP     ; GET THE ADDRESS OF THE POWER UP VECTOR.
  115 EDAC:ED01            [ 5]         STD    1,X          ; INITALIZE ILLEGAL OP-CODE VECTOR.
  116 EDAE:ED04            [ 5]         STD    4,X          ; INITALIZE WATCH DOG FAIL VECTOR.
  117 EDB0:ED07            [ 5]         STD    7,X          ; INITALIZE CLOCK MONITOR FAIL VECTOR.
  118                           *
  119                           *
  120                           *
  121 EDB2:CE00 A4         [ 3]         LDX    #INTABLE     ; POINT TO THE START OF THE I/O VECTOR TABLE.
  122 EDB5:18CE FFA0       [ 4]         LDY    #IOVects     ; point to the default table in ROM.
  123 EDB9:C620            [ 2]         LDAB   #32          ; GET NUMBER OF BYTES IN THE TABLE.
  124 EDBB:18A6 00         [ 5] POWERUP2:       ldaa   0,Y          ; Move a byte of the table from ROM into RAM.
  125 EDBE:A700            [ 4]         staa   0,X
  126 EDC0:08              [ 3]         INX                 ; POINT TO THE NEXT BYTE.
  127 EDC1:1808            [ 4]         INY
  128 EDC3:5A              [ 2]         DECB                ; DECREMENT THE COUNT.
  129 EDC4:26F5 (EDBB)     [ 3]         BNE    POWERUP2     ; GO TILL WE'RE DONE.
  130                           *
  131                           *
  132 EDC6:CEED F9         [ 3]         LDX    #TIMEINT     ; GET THE ADDRESS OF THE OUTPUT COMPARE 1 ROUTINE.
  133 EDC9:DFE0            [ 4]         STX    TOC1+1       ; PUT IT IN THE INTERRUPT VECTOR.
  134 EDCB:8603            [ 2]         LDAA   #SWPRE+1     ; ADD 1 TO NORMAL PRE SCALER.
  135 EDCD:973C            [ 3]         STAA   TIMEPRE      ; SET UP THE SOFTWARE PRESCALER.
  136 EDCF:4F              [ 2]         clra
  137 EDD0:5F              [ 2]         clrb
  138 EDD1:DD38            [ 4]         std    TIMEREG      ; ZERO THE TIME REGISTER.
  139 EDD3:DD3A            [ 4]         std    TIMECMP      ; zero the time compare register.
  140 EDD5:DE61            [ 4]         LDX    IOBaseV
  141 EDD7:8D23 (EDFC)     [ 6]         BSR    TIMINTS      ; GO SETUP THE TIMER FOR THE FIRST INTERRUPT.
  142 EDD9:8680            [ 2]         LDAA   #$80         ; ENABLE INTERRUPTS FROM OC1.
  143 EDDB:A722            [ 4]         STAA   TMSK1,X
  144                                   
  145 EDDD:CEEE 36         [ 3]         LDX    #IRQINT     ; GET THE ADDRESS OF THE IRQ SERVICE ROUTINE.
  146 EDE0:DFEF            [ 4]         STX    IRQI+1      ; PUT IT IN THE IRQ VECTOR.
  147 EDE2:CEEE 3C         [ 3]         LDX    #PACCINT    ; GET THE ADDRESS OF THE PACC INT ROUTINE.
  148 EDE5:DFCB            [ 4]         STX    PACCIE+1    ; SET ADDRESS IN INPUT EDGE INTERRUPT VECTOR.
  149 EDE7:DFCE            [ 4]         STX    PACCOVF+1   ; SET ADDRESS IN PACC OVERFLOW INTERRUPT VECTOR.
  150 EDE9:4F              [ 2]         CLRA
  151 EDEA:5F              [ 2]         CLRB
  152 EDEB:DD3D            [ 4]         STD    ONTIMLIN    ; INITALIZE THE LINE POINTERS.
  153 EDED:DD3F            [ 4]         STD    ONIRQLIN
  154 EDEF:DD41            [ 4]         STD    ONPACLIN
  155                           *
  156                           *
  157                           *
  158 EDF1:FEFF CC         [ 5]         LDX    UserInit
  159 EDF4:AD00            [ 6]         JSR    0,X      ; INITALIZE THE ACIA & SCI.
  160 EDF6:7EE0 03         [ 3]         JMP    MAIN         ; GO TO BASIC.
  161                           *
  162                           *
  163                           *
  164 EDF9:8D01 (EDFC)     [ 6] TIMEINT:        BSR    TIMINTS
  165 EDFB:3B              [12] RETII:  RTI                 ; RETURN FROM ALL INTERRUPT SOURCES.
  166                           *
  167                           *
  168 EDFC:DE61            [ 4] TIMINTS:        LDX    IOBaseV  ; Point to the I/O Base Address.
  169 EDFE:EC16            [ 5]         LDD    TOC1REG,X    ; GET THE VALUE OF THE TIMER/COUNTER.
  170 EE00:F3FF CA         [ 6] TIMINTS3:       ADDD   TimeVal      ; ADD IN 62500 FOR NEXT COMPARE ( 2 HZ INT.).
  171 EE03:ED16            [ 5]         STD    TOC1REG,X    ; PUT IT IN THE OUTPUT COMPARE REGISTER.
  172 EE05:8680            [ 2]         LDAA   #$80         ; SETUP TO CLEAR THE OC1 FLAG.
  173 EE07:A723            [ 4]         STAA   TFLAG1,X
  174 EE09:7A00 3C         [ 6]         DEC    TIMEPRE      ; HAVE TWO OUTPUT COMPARES OCCURED?
  175 EE0C:2627 (EE35)     [ 3]         BNE    TIMINTS1     ; NO. JUST RETURN.
  176 EE0E:8602            [ 2]         LDAA   #SWPRE       ; YES. RELOAD THE REGISTER.
  177 EE10:973C            [ 3]         STAA   TIMEPRE
  178 EE12:DC38            [ 4]         LDD    TIMEREG      ; GET THE CURRENT VALUE OF "TIME".
  179 EE14:C300 01         [ 4]         ADDD   #1           ; ADD 1 SECOND TO THE COUNT.
  180 EE17:DD38            [ 4]         STD    TIMEREG      ; UPDATE THE TIME REGISTER.
  181 EE19:DC3A            [ 4]         LDD    TIMECMP      ; GET THE VALUE TO COMPARE TO FOR "ONTIME".
  182 EE1B:2718 (EE35)     [ 3]         BEQ    TIMINTS1     ; IF IT'S 0, THE "ONTIME" FUNCTION IS OFF.
  183 EE1D:1A93 38         [ 6]         CPD    TIMEREG      ; DOES THE COMPARE VALUE MATCH THE TIME REGISTER?
  184 EE20:2613 (EE35)     [ 3]         BNE    TIMINTS1     ; NO. JUST RETURN.
  185 EE22:18DE 3D         [ 5]         LDY    ONTIMLIN     ; MAKE THE POINTER TO THE LINE NUMBER THE NEW IP.
  186 EE25:31              [ 3]         INS                 ; GET RID OF THE RETURN ADDRESS.
  187 EE26:31              [ 3]         INS
  188 EE27:7C00 19         [ 6] TIMINTS2:       INC    IMMID        ; FAKE THE GOTO ROUTINE OUT.
  189 EE2A:DC29            [ 4]         LDD    CURLINE      ; SAVE THE CURRENT LINE NUMBER IN MAIN PROGRAM.
  190 EE2C:DD45            [ 4]         STD    SCURLINE
  191 EE2E:DC2B            [ 4]         LDD    ADRNXLIN     ; SAVE THE ADDRESS OF THE NEXT LINE IN MAIN PROG.
  192 EE30:DD47            [ 4]         STD    SADRNXLN
  193 EE32:7EF4 45         [ 3]         JMP    RGOTO3       ; GOTO THE SERVICE ROUTINE.
  194 EE35:39              [ 5] TIMINTS1:       RTS                 ; RETURN.
  195                           *
  196                           *
  197                           *
  198      EE36                 IRQINT: EQU    *
  199 EE36:18DE 3F         [ 5]         LDY    ONIRQLIN     ; GET POINTER TO LINE NUMBER OF THE IRQ SERVICE.
  200 EE39:26EC (EE27)     [ 3]         BNE    TIMINTS2     ; GO DO IT.
  201 EE3B:3B              [12]         RTI                 ; IF IT'S 0, "ONIRQ" HAS NOT BEEN EXECUTED.
  202                           *
  203                           *
  204      EE3C                 PACCINT:        EQU    *
  205 EE3C:DE61            [ 4]         LDX    IOBaseV
  206 EE3E:8630            [ 2]         LDAA   #$30         ; RESET BOTH THE TIMER OVERFLOW & INPUT FLAG.
  207 EE40:A725            [ 4]         STAA   TFLG2,X
  208 EE42:18DE 41         [ 5]         LDY    ONPACLIN     ; GET POINTER TO LINE NUMBER OF THE SERVICE ROUT.
  209 EE45:26E0 (EE27)     [ 3]         BNE    TIMINTS2
  210 EE47:3B              [12]         RTI
  211                           *
  212                           *
*** END   INCLUDE FILE: INITS.ASM *** (RESUMING FILE: BASIC11.ASM)
   14                           #Include  'COMMAND1.Asm'
*** BEGIN INCLUDE FILE: COMMAND1.ASM ***
    1                           *        title    COMMAND1
    2                           *        page
    3                           */***** chckcmds() *****/
    4                           *
    5                           *chckcmds()
    6                           *{
    7                           * if(match("LIST")) clist();
    8                           * else if(match("RUN")) crun();
    9                           * else if(match("NEW")) cnew();
   10                           * else if(match("CONT")) ccont();
   11                           * else if(match("CLEAR")) cclear();
   12                           * else return(0);
   13                           * return(1);
   14                           *}
   15                           *
   16                           *
   17      EE48                 CHCKCMDS:       EQU    *
   18 EE48:BDE3 C3         [ 6]         JSR    GETCHR        ; GET FIRST CHAR FROM THE INPUT BUFFER.
   19 EE4B:810D            [ 2]         CMPA   #EOL          ; IS IT AN EOL?
   20 EE4D:2604 (EE53)     [ 3]         BNE    CHKCMDS1      ; NO. GO CHECK FOR COMMANDS.
   21 EE4F:CC00 00         [ 3] CHKCMDS5:       LDD    #0            ; YES. JUST RETURN.
   22 EE52:39              [ 5]         RTS
   23 EE53:CEEE 71         [ 3] CHKCMDS1:       LDX    #CMDTBL       ; POINT TO COMMAND TABLE.
   24 EE56:BDE3 A5         [ 6] CHKCMDS2:       JSR    STREQ         ; GO CHECK FOR A COMMAND.
   25 EE59:250E (EE69)     [ 3]         BCS    CHKCMDS3      ; IF WE FOUND ONE GO EXECUTE IT.
   26 EE5B:08              [ 3] CHKCMDS4:       INX                  ; ADVANCE POINTER TO NEXT CHAR IN TABLE ENTRY.
   27 EE5C:A600            [ 4]         LDAA   0,X           ; GET THE CHAR. ARE WE AT THE END OF THIS ENTRY?
   28 EE5E:26FB (EE5B)     [ 3]         BNE    CHKCMDS4      ; NO. KEEP GOING TILL WE ARE PAST IT.
   29 EE60:08              [ 3]         INX                  ; BYPASS END OF COMMAND MARKER & EXECUTION ADDR.
   30 EE61:08              [ 3]         INX
   31 EE62:08              [ 3]         INX
   32 EE63:6D00            [ 6]         TST    0,X           ; ARE WE AT THE END OF THE TABLE?
   33 EE65:26EF (EE56)     [ 3]         BNE    CHKCMDS2      ; NO. GO CHECK THE NEXT TABLE ENTRY.
   34 EE67:20E6 (EE4F)     [ 3]         BRA    CHKCMDS5      ; YES. RETURN W/ ENTRY NOT FOUND INDICATION.
   35 EE69:EE01            [ 5] CHKCMDS3:       LDX    1,X           ; GET ADDRESS OF COMMAND.
   36 EE6B:AD00            [ 6]         JSR    0,X           ; GO DO IT.
   37 EE6D:CC00 01         [ 3]         LDD    #1            ; SHOW WE EXECUTED A COMMAND.
   38 EE70:39              [ 5]         RTS                  ; RETURN.
   39                           *
   40                           *
   41      EE71                 CMDTBL: EQU    *
   42 EE71.4C49 5354                    FCC    "LIST"
   43 EE75.00                           FCB    0
   44 EE76.EEC5                         FDB    CLIST
   45 EE78.5255 4E                      FCC    "RUN"
   46 EE7B.00                           FCB    0
   47 EE7C.F159                         FDB    CRUN
   48 EE7E.4E45 57                      FCC    "NEW"
   49 EE81.00                           FCB    0
   50 EE82.F2C7                         FDB    CNEW
   51 EE84.434F 4E54                    FCC    "CONT"
   52 EE88.00                           FCB    0
   53 EE89.F2B2                         FDB    CCONT
   54 EE8B.434C 4541 52                 FCC    "CLEAR"
   55 EE90.00                           FCB    0
   56 EE91.F2DB                         FDB    CCLEAR
   57 EE93.4553 4156 45                 FCC    "ESAVE"
   58 EE98.00                           FCB    0
   59 EE99.F2F2                         FDB    CESAVE
   60 EE9B.454C 4F41 44                 FCC    "ELOAD"
   61 EEA0.00                           FCB    0
   62 EEA1.F356                         FDB    CELOAD
   63 EEA3.4C4C 4953 54                 FCC    "LLIST"
   64 EEA8.00                           FCB    0
   65 EEA9.F390                         FDB    CLLIST
   66 EEAB.4155 544F 5354               FCC    "AUTOST"
   67 EEB1.00                           FCB    0
   68 EEB2.F39B                         FDB    CAUTOST
   69 EEB4.4E4F 4155 544F               FCC    "NOAUTO"
   70 EEBA.00                           FCB    0
   71 EEBB.F3A6                         FDB    CNOAUTO
   72 EEBD.4652 4545                    FCC     "FREE"
   73 EEC1.00                           FCB     0
   74 EEC2.F3D7                         FDB     CFREE
   75 EEC4.00                           FCB    0             ;END OF TABLE MARKER.
   76                                   
   77                                   
   78                           */***** clist() *****/
   79                           *
   80                           *clist()
   81                           *{
   82                           * int *intptr;
   83                           * char token;
   84                           * if(basbeg==basend) return;             /* if basic buffer empty, return */
   85                           * skipspcs();                    /* skip any spaces after "LIST" */
   86                           *
   87                           *
   88      EEC5                 CLIST:  EQU    *
   89 EEC5:BDE1 0E         [ 6]         JSR    NL2
   90 EEC8:DC04            [ 4]         LDD    BASBEG
   91 EECA:1A93 06         [ 6]         CPD    BASEND
   92 EECD:2601 (EED0)     [ 3]         BNE    CLIST1
   93 EECF:39              [ 5]         RTS
   94 EED0:BDE0 5B         [ 6] CLIST1: JSR    SKIPSPCS
   95                           *
   96                           *
   97                           * if(numeric(getchr()))
   98                           * {
   99                           *  firstlin=getlinum();
  100                           *  if(getchr()=='-')
  101                           *  {
  102                           *   incibp();
  103                           *   lastlin=getlinum;
  104                           *  }
  105                           * }
  106                           * else
  107                           * {
  108                           *  intptr=basbeg;
  109                           *  lastlin=hiline;
  110                           *  firstlin=*intptr;
  111                           * }
  112                           * if(firstlin<lastlin) return;
  113                           * tokptr=intptr=findline(firstlin);
  114                           *
  115                           *
  116 EED3:BDE3 C3         [ 6]         JSR    GETCHR
  117 EED6:BDE1 BB         [ 6]         JSR    NUMERIC
  118 EED9:2427 (EF02)     [ 3]         BCC    CLIST2
  119 EEDB:BDE1 6C         [ 6]         JSR    GETLINUM
  120 EEDE:DD12            [ 4]         STD    FIRSTLIN
  121 EEE0:BDE3 C3         [ 6]         JSR    GETCHR
  122 EEE3:812D            [ 2]         CMPA   #'-'
  123 EEE5:270A (EEF1)     [ 3]         BEQ    CLIST3
  124 EEE7:DC12            [ 4]         LDD    FIRSTLIN
  125 EEE9:DD14            [ 4]         STD    LASTLIN
  126 EEEB:1A93 0C         [ 6]         CPD    HILINE
  127 EEEE:2321 (EF11)     [ 3]         BLS    CLIST4
  128 EEF0:39              [ 5]         RTS
  129 EEF1:BDE3 CC         [ 6] CLIST3: JSR    INCIBP
  130 EEF4:BDE1 6C         [ 6]         JSR    GETLINUM
  131 EEF7:1A93 0C         [ 6]         CPD    HILINE
  132 EEFA:2302 (EEFE)     [ 3]         BLS    CLIST13
  133 EEFC:DC0C            [ 4]         LDD    HILINE
  134 EEFE:DD14            [ 4] CLIST13:        STD    LASTLIN
  135 EF00:200F (EF11)     [ 3]         BRA    CLIST4
  136 EF02:810D            [ 2] CLIST2: CMPA   #EOL
  137 EF04:2701 (EF07)     [ 3]         BEQ    CLIST14
  138 EF06:39              [ 5]         RTS
  139 EF07:DE04            [ 4] CLIST14:        LDX    BASBEG
  140 EF09:EC00            [ 5]         LDD    0,X
  141 EF0B:DD12            [ 4]         STD    FIRSTLIN
  142 EF0D:DC0C            [ 4]         LDD    HILINE
  143 EF0F:DD14            [ 4]         STD    LASTLIN
  144 EF11:DC12            [ 4] CLIST4: LDD    FIRSTLIN
  145 EF13:1A93 14         [ 6]         CPD    LASTLIN
  146 EF16:2301 (EF19)     [ 3]         BLS    CLIST5
  147 EF18:39              [ 5]         RTS
  148 EF19:DC12            [ 4] CLIST5: LDD    FIRSTLIN
  149 EF1B:BDEB E9         [ 6]         JSR    FINDLINE
  150 EF1E:DF6A            [ 4]         STX    TOKPTR
  151 EF20:DC14            [ 4]         LDD    LASTLIN
  152 EF22:BDEB E9         [ 6]         JSR    FINDLINE
  153 EF25:EC00            [ 5]         LDD    0,X
  154 EF27:1A93 14         [ 6]         CPD    LASTLIN
  155 EF2A:2603 (EF2F)     [ 3]         BNE    CLIST12
  156 EF2C:E602            [ 4]         LDAB   2,X
  157 EF2E:3A              [ 3]         ABX
  158 EF2F:DF14            [ 4] CLIST12:        STX    LASTLIN
  159                           *
  160                           *
  161                           *
  162                           * while(*intptr<lastlin)
  163                           * {
  164                           *  intptr=tokptr;
  165                           *  outdeci(*intptr);
  166                           *  tokptr+=3;
  167                           *  while(*tokptr!=EOLTOK)
  168                           *  {
  169                           *   token=gettok;
  170                           *   if(token>=0x80)
  171                           *   {
  172                           *    lvarcon();
  173                           *   }
  174                           *   else
  175                           *   {
  176                           *    lkeyword();
  177                           *   }
  178                           *  }
  179                           *  nl();
  180                           *  ++tokptr;
  181                           * }
  182                           * return;
  183                           *}
  184                           *
  185                           *
  186 EF31:DC6A            [ 4] CLIST6: LDD    TOKPTR
  187 EF33:1A93 14         [ 6]         CPD    LASTLIN
  188 EF36:2601 (EF39)     [ 3]         BNE    CLIST7
  189 EF38:39              [ 5]         RTS
  190 EF39:DE6A            [ 4] CLIST7: LDX    TOKPTR
  191 EF3B:EC00            [ 5]         LDD    0,X
  192 EF3D:08              [ 3]         INX
  193 EF3E:08              [ 3]         INX
  194 EF3F:08              [ 3]         INX
  195 EF40:DF6A            [ 4]         STX    TOKPTR
  196 EF42:BDEB 1A         [ 6]         JSR    OUTDECI
  197 EF45:DE6A            [ 4] CLIST8: LDX    TOKPTR
  198 EF47:A600            [ 4]         LDAA   0,X
  199 EF49:817D            [ 2]         CMPA   #EOLTOK
  200 EF4B:270D (EF5A)     [ 3]         BEQ    CLIST9
  201 EF4D:4D              [ 2]         TSTA
  202 EF4E:2B05 (EF55)     [ 3]         BMI    CLIST10
  203 EF50:BDEF D8         [ 6]         JSR    LKEYWORD
  204 EF53:20F0 (EF45)     [ 3]         BRA    CLIST8
  205 EF55:BDEF 64         [ 6] CLIST10:        JSR    LVARCON
  206 EF58:20EB (EF45)     [ 3]         BRA    CLIST8
  207 EF5A:BDE1 10         [ 6] CLIST9: JSR    NL
  208 EF5D:DE6A            [ 4]         LDX    TOKPTR
  209 EF5F:08              [ 3]         INX
  210 EF60:DF6A            [ 4]         STX    TOKPTR
  211 EF62:20CD (EF31)     [ 3]         BRA    CLIST6
  212                           *
  213                           *
  214                           */***** lvarcon() *****/
  215                           *
  216                           *lvarcon()
  217                           *{
  218                           * char tok;
  219                           * tok=gettok;
  220                           * if(tok<=0x88)
  221                           * {
  222                           *  if(tok==FVARTOK) lfvar();
  223                           *  else if(tok==SVARTOK) lsvar();
  224                           *  else if(tok==IVARTOK) livar();
  225                           *  else { errcode=ILTOKERR; return; }
  226                           * }
  227                           *
  228                           *
  229                           * else if(tok<=0xA8)
  230                           * {
  231                           *  if(tok==FCONTOK) lfcon();
  232                           *  else if(tok==SCONTOK) lscon();
  233                           *  else if(tok==LCONTOK) llcon();
  234                           *  else if(tok==ICONTOK) licon();
  235                           *  else { errcode=ILTOKERR; return; }
  236                           * }
  237                           * else { errcode=ILTOKERR; return; }
  238                           *}
  239                           *
  240      EF64                 LVARCON:        EQU    *
  241 EF64:DE6A            [ 4]         LDX    TOKPTR
  242 EF66:A600            [ 4]         LDAA   0,X
  243 EF68:84EF            [ 2]         ANDA   #$EF          ; MASK OFF ARRAY INDICATOR IF PRESENT.
  244 EF6A:CEEF 82         [ 3]         LDX    #VCTOKTBL
  245 EF6D:A100            [ 4] LVARCON1:       CMPA   0,X
  246 EF6F:270C (EF7D)     [ 3]         BEQ    LVARCON2
  247 EF71:08              [ 3]         INX
  248 EF72:08              [ 3]         INX
  249 EF73:08              [ 3]         INX
  250 EF74:6D00            [ 6]         TST    0,X
  251 EF76:26F5 (EF6D)     [ 3]         BNE    LVARCON1
  252 EF78:8608            [ 2]         LDAA   #ILTOKERR
  253 EF7A:7EEA 98         [ 3]         JMP    RPTERR
  254 EF7D:EE01            [ 5] LVARCON2:       LDX    1,X
  255 EF7F:AD00            [ 6]         JSR    0,X
  256 EF81:39              [ 5]         RTS
  257                           *
  258                           *
  259      EF82                 VCTOKTBL:       EQU    *
  260 EF82.84                           FCB    IVARTOK
  261 EF83.EF8F                         FDB    LIVAR
  262 EF85.A2                           FCB    SCONTOK
  263 EF86.EFC4                         FDB    LSCON
  264 EF88.A8                           FCB    LCONTOK
  265 EF89.EFCB                         FDB    LLCON
  266 EF8B.A4                           FCB    ICONTOK
  267 EF8C.EFBD                         FDB    LICON
  268 EF8E.00                           FCB    0                     ; END OF TABLE MARKER.
  269                           *
  270                           *
  271                           *
  272                           *
  273                           */***** livar() *****/
  274                           *
  275                           *livar()
  276                           *{
  277                           * lfvar();
  278                           * outbyte('%');
  279                           * return;
  280                           *}
  281                           *
  282                           *
  283      EF8F                 LIVAR:  EQU    *
  284 EF8F:DE6A            [ 4]         LDX    TOKPTR
  285 EF91:08              [ 3]         INX
  286 EF92:EC00            [ 5]         LDD    0,X
  287 EF94:D308            [ 5]         ADDD   VARBEGIN
  288 EF96:08              [ 3]         INX
  289 EF97:08              [ 3]         INX
  290 EF98:DF6A            [ 4]         STX    TOKPTR
  291 EF9A:8F              [ 3]         XGDX
  292 EF9B:A601            [ 4] LIVAR2: LDAA   1,X
  293 EF9D:BDFE CD         [ 6]         JSR    OUTBYTE
  294 EFA0:A602            [ 4]         LDAA   2,X
  295 EFA2:2703 (EFA7)     [ 3]         BEQ    LIVAR1
  296 EFA4:BDFE CD         [ 6]         JSR    OUTBYTE
  297 EFA7:39              [ 5] LIVAR1: RTS
  298                           *
  299                           *
  300      EFA8                 LFCON:  EQU    *
  301 EFA8:DC6A            [ 4]         LDD    TOKPTR
  302 EFAA:C300 06         [ 4]         ADDD   #FSIZ+1
  303 EFAD:8F              [ 3] LFCON2: XGDX
  304 EFAE:E600            [ 4]         LDAB   0,X
  305 EFB0:08              [ 3]         INX
  306 EFB1:A600            [ 4] LFCON1: LDAA   0,X
  307 EFB3:BDFE CD         [ 6]         JSR    OUTBYTE
  308 EFB6:08              [ 3]         INX
  309 EFB7:5A              [ 2]         DECB
  310 EFB8:26F7 (EFB1)     [ 3]         BNE    LFCON1
  311 EFBA:DF6A            [ 4]         STX    TOKPTR
  312 EFBC:39              [ 5]         RTS
  313                           *
  314                           *
  315                           */***** licon() *****/
  316                           *
  317                           *licon()
  318                           *{
  319                           * int count;
  320                           * tokptr=tokptr+ISIZ+1;
  321                           * count=*tokptr++;
  322                           * while(count--)
  323                           * {
  324                           *  outbyte(*tokptr++);
  325                           * }
  326                           * return;
  327                           *}
  328                           *
  329                           *
  330      EFBD                 LICON:  EQU    *
  331 EFBD:DC6A            [ 4]         LDD    TOKPTR
  332 EFBF:C300 03         [ 4]         ADDD   #ISIZ+1
  333 EFC2:20E9 (EFAD)     [ 3]         BRA    LFCON2
  334                           *
  335                           *
  336                           */***** lscon() *****/
  337                           *
  338                           *lscon()
  339                           *{
  340                           * int count;
  341                           * ++tokptr;
  342                           * count=*tokptr++;
  343                           * while(count--)
  344                           * {
  345                           *  outbyte(*tokptr++);
  346                           * }
  347                           * return;
  348                           *}
  349                           *
  350                           *
  351      EFC4                 LSCON:  EQU    *
  352 EFC4:DC6A            [ 4]         LDD    TOKPTR
  353 EFC6:C300 01         [ 4]         ADDD   #1
  354 EFC9:20E2 (EFAD)     [ 3]         BRA    LFCON2
  355                           *
  356                           *
  357                           */***** llcon *****/
  358                           *
  359                           *llcon()
  360                           *{
  361                           * int *intptr;
  362                           * intptr=++tokptr;
  363                           * tokptr+=2;
  364                           * outdeci(*intptr);
  365                           * return;
  366                           *}
  367                           *
  368                           *
  369      EFCB                 LLCON:  EQU    *
  370 EFCB:DE6A            [ 4]         LDX    TOKPTR
  371 EFCD:08              [ 3]         INX
  372 EFCE:EC00            [ 5]         LDD    0,X
  373 EFD0:08              [ 3]         INX
  374 EFD1:08              [ 3]         INX
  375 EFD2:DF6A            [ 4]         STX    TOKPTR
  376 EFD4:BDEB 1A         [ 6]         JSR    OUTDECI
  377 EFD7:39              [ 5]         RTS
  378                           *
  379                           *
  380                           */***** lkeyword *****/
  381                           *
  382                           *lkeyword()
  383                           *{
  384                           * char *charptr,token;
  385                           * token=*tokptr++
  386                           *
  387                           *
  388      EFD8                 LKEYWORD:       EQU    *
  389 EFD8:DE6A            [ 4]         LDX    TOKPTR
  390 EFDA:A600            [ 4]         LDAA   0,X
  391 EFDC:08              [ 3]         INX
  392 EFDD:DF6A            [ 4]         STX    TOKPTR
  393 EFDF:817F            [ 2]         CMPA   #MSCNTOK
  394 EFE1:2603 (EFE6)     [ 3]         BNE    LKEYWRD3
  395 EFE3:7EF0 1C         [ 3]         JMP    LMSPCS
  396 EFE6:810A            [ 2] LKEYWRD3:       CMPA   #REMTOK
  397 EFE8:2603 (EFED)     [ 3]         BNE    LKEYWRD4
  398 EFEA:7EF0 34         [ 3]         JMP    LREMLINE
  399 EFED:810C            [ 2] LKEYWRD4:       CMPA   #DATATOK
  400 EFEF:2603 (EFF4)     [ 3]         BNE    LKEYWRD5
  401 EFF1:7EF0 2C         [ 3]         JMP    LDATALIN
  402 EFF4:8136            [ 2] LKEYWRD5:       CMPA   #FUNCTFLG
  403 EFF6:260C (F004)     [ 3]         BNE    LKEYWRD6
  404 EFF8:DE6A            [ 4]         LDX    TOKPTR
  405 EFFA:A600            [ 4]         LDAA   0,X
  406 EFFC:08              [ 3]         INX
  407 EFFD:DF6A            [ 4]         STX    TOKPTR
  408 EFFF:CEF1 0B         [ 3]         LDX    #LFUNCTBL
  409 F002:2003 (F007)     [ 3]         BRA    LKEYWRD1
  410 F004:CEF0 4D         [ 3] LKEYWRD6:       LDX    #TOKTBL
  411 F007:A100            [ 4] LKEYWRD1:       CMPA   0,X
  412 F009:270C (F017)     [ 3]         BEQ    LKEYWRD2
  413 F00B:08              [ 3]         INX
  414 F00C:08              [ 3]         INX
  415 F00D:08              [ 3]         INX
  416 F00E:6D00            [ 6]         TST    0,X
  417 F010:26F5 (F007)     [ 3]         BNE    LKEYWRD1
  418 F012:8608            [ 2]         LDAA   #ILTOKERR
  419 F014:7EEA 98         [ 3]         JMP    RPTERR
  420 F017:EE01            [ 5] LKEYWRD2:       LDX    1,X
  421 F019:7EE1 1C         [ 3]         JMP    PL
  422                           *
  423                           *
  424      F01C                 LMSPCS: EQU    *
  425 F01C:DE6A            [ 4]         LDX    TOKPTR
  426 F01E:E600            [ 4]         LDAB   0,X
  427 F020:08              [ 3]         INX
  428 F021:DF6A            [ 4]         STX    TOKPTR
  429 F023:8620            [ 2]         LDAA   #$20
  430 F025:BDFE CD         [ 6] LMSPCS1:        JSR    OUTBYTE
  431 F028:5A              [ 2]         DECB
  432 F029:26FA (F025)     [ 3]         BNE    LMSPCS1
  433 F02B:39              [ 5]         RTS
  434                           *
  435                           *
  436      F02C                 LDATALIN:       EQU    *
  437 F02C:CEE2 46         [ 3]         LDX    #DATA
  438 F02F:BDE1 1C         [ 6]         JSR    PL
  439 F032:2006 (F03A)     [ 3]         BRA    LREM3
  440                           *
  441                           *
  442      F034                 LREMLINE:       EQU    *
  443 F034:CEE2 EA         [ 3]         LDX    #REM
  444 F037:BDE1 1C         [ 6]         JSR    PL
  445 F03A:DE6A            [ 4] LREM3:  LDX    TOKPTR
  446 F03C:08              [ 3]         INX                 ; PUT POINTER PAST LENGTH BYTE.
  447 F03D:A600            [ 4] LREM1:  LDAA   0,X
  448 F03F:810D            [ 2]         CMPA   #EOL
  449 F041:2604 (F047)     [ 3]         BNE    LREM2
  450 F043:08              [ 3]         INX
  451 F044:DF6A            [ 4]         STX    TOKPTR
  452 F046:39              [ 5]         RTS
  453 F047:BDFE CD         [ 6] LREM2:  JSR    OUTBYTE
  454 F04A:08              [ 3]         INX
  455 F04B:20F0 (F03D)     [ 3]         BRA    LREM1
  456                           *
  457                           *
  458      F04D                 TOKTBL: EQU     *
  459 F04D.01                           FCB     LETTOK
  460 F04E.E24E                         FDB     LET
  461 F050.0D                           FCB     READTOK
  462 F051.E255                         FDB     READ
  463 F053.0E                           FCB     RESTRTOK
  464 F054.E25D                         FDB     RESTORE
  465 F056.0F                           FCB     GOSUBTOK
  466 F057.E268                         FDB     GOSUB
  467 F059.12                           FCB     GOTOTOK
  468 F05A.E271                         FDB     GOTO
  469 F05C.13                           FCB     ONTOK
  470 F05D.E296                         FDB     ON
  471 F05F.14                           FCB     RETNTOK
  472 F060.E29C                         FDB     RETURN
  473 F062.15                           FCB     IFTOK
  474 F063.E2A6                         FDB     IIF
  475 F065.38                           FCB     THENTOK
  476 F066.E966                         FDB     THENS
  477 F068.39                           FCB     ELSETOK
  478 F069.E96B                         FDB     ELSES
  479 F06B.16                           FCB     INPUTTOK
  480 F06C.E2AC                         FDB     INPUT
  481 F06E.03                           FCB     PRINTTOK
  482 F06F.E2B5                         FDB     PRINT
  483 F071.04                           FCB     FORTOK
  484 F072.E2C3                         FDB     FOR
  485 F074.05                           FCB     NEXTTOK
  486 F075.E2CA                         FDB     NEXT
  487 F077.17                           FCB     STOPTOK
  488 F078.E2D2                         FDB     STOPSS
  489 F07A.18                           FCB     ENDTOK
  490 F07B.E2E3                         FDB     ENDS
  491 F07D.06                           FCB     TRONTOK
  492 F07E.E2F1                         FDB     TRON
  493 F080.07                           FCB     TROFFTOK
  494 F081.E2F9                         FDB     TROFF
  495 F083.19                           FCB     WHILETOK
  496 F084.E302                         FDB     WHILE
  497 F086.1A                           FCB     ENDWHTOK
  498 F087.E2DA                         FDB     ENDWH
  499 F089.3A                           FCB     STEPTOK
  500 F08A.E9C6                         FDB     STEP
  501 F08C.37                           FCB     TOTOK
  502 F08D.E9C3                         FDB     TO
  503 F08F.7C                           FCB     COMMATOK
  504 F090.F149                         FDB     COMMAC
  505 F092.7B                           FCB     SEMITOK
  506 F093.F147                         FDB     SEMIC
  507 F095.7A                           FCB     MEOLTOK
  508 F096.F145                         FDB     COLLINC
  509 F098.02                           FCB     IMLETTOK
  510 F099.F144                         FDB     IMLET
  511 F09B.08                           FCB     POKETOK
  512 F09C.E30B                         FDB     POKE
  513 F09E.79                           FCB     EQUALTOK
  514 F09F.E54A                         FDB     EQ
  515 F0A1.10                           FCB     OPARNTOK
  516 F0A2.F14B                         FDB     OPARN
  517 F0A4.11                           FCB     CPARNTOK
  518 F0A5.F14D                         FDB     CPARN
  519 F0A7.20                           FCB     ANDTOK
  520 F0A8.E523                         FDB     ANDS
  521 F0AA.21                           FCB     ORTOK
  522 F0AB.E52A                         FDB     ORS
  523 F0AD.22                           FCB     EORTOK
  524 F0AE.E530                         FDB     EORS
  525 F0B0.30                           FCB     LTTOK
  526 F0B1.E544                         FDB     LT
  527 F0B3.31                           FCB     GTTOK
  528 F0B4.E547                         FDB     GT
  529 F0B6.32                           FCB     LTEQTOK
  530 F0B7.E538                         FDB     LTEQ
  531 F0B9.33                           FCB     GTEQTOK
  532 F0BA.E53C                         FDB     GTEQ
  533 F0BC.34                           FCB     EQTOK
  534 F0BD.E54A                         FDB     EQ
  535 F0BF.35                           FCB     NOTEQTOK
  536 F0C0.E540                         FDB     NOTEQ
  537 F0C2.40                           FCB     PLUSTOK
  538 F0C3.E513                         FDB     PLUS
  539 F0C5.41                           FCB     MINUSTOK
  540 F0C6.E516                         FDB     MINUS
  541 F0C8.50                           FCB     MULTTOK
  542 F0C9.E519                         FDB     MULT
  543 F0CB.51                           FCB     DIVTOK
  544 F0CC.E51C                         FDB     DIV
  545 F0CE.52                           FCB     MODTOK
  546 F0CF.E51F                         FDB     MODS
  547 F0D1.71                           FCB     NOTTOK
  548 F0D2.E551                         FDB     NOTS
  549 F0D4.2A                           FCB     RTIMETOK
  550 F0D5.E370                         FDB     RTIMES
  551 F0D7.72                           FCB     NEGTOK
  552 F0D8.E54E                         FDB     NEGS
  553 F0DA.7E                           FCB     SSCNTOK
  554 F0DB.F14F                         FDB     SPACE
  555 F0DD.09                           FCB     DIMTOK
  556 F0DE.E313                         FDB     DIM
  557 F0E0.1B                           FCB     EEPTOK
  558 F0E1.E31A                         FDB     EEP
  559 F0E3.1C                           FCB     PORTATOK
  560 F0E4.E321                         FDB     PORTA
  561 F0E6.1D                           FCB     PORTBTOK
  562 F0E7.E32A                         FDB     PORTB
  563 F0E9.1E                           FCB     PORTCTOK
  564 F0EA.E333                         FDB     PORTC
  565 F0EC.1F                           FCB     PORTDTOK
  566 F0ED.E33C                         FDB     PORTD
  567 F0EF.78                           FCB     PNUMTOK
  568 F0F0.F157                         FDB     POUNDSGN
  569 F0F2.23                           FCB     INBYTTOK
  570 F0F3.E345                         FDB     INBYTES
  571 F0F5.24                           FCB     TIMETOK
  572 F0F6.E34F                         FDB     TIME
  573 F0F8.25                           FCB     ONTIMTOK
  574 F0F9.E279                         FDB     ONTIME
  575 F0FB.26                           FCB     ONIRQTOK
  576 F0FC.E283                         FDB     ONIRQ
  577 F0FE.27                           FCB     RETITOK
  578 F0FF.E357                         FDB     RETI
  579 F101.0B                           FCB     PACCTOK
  580 F102.E35F                         FDB     PACC
  581 F104.28                           FCB     ONPACTOK
  582 F105.E28C                         FDB     ONPACC
  583 F107.29                           FCB     SLEEPTOK
  584 F108.E367                         FDB     SLEEP
  585 F10A.00                           FCB     0            ; END OF TABLE MARKER.
  586                           *
  587                           *
  588      F10B                 LFUNCTBL:       EQU    *
  589 F10B.01                           FCB    FDIVTOK
  590 F10C.E788                         FDB    FDIVS
  591 F10E.02                           FCB    CHRTOK
  592 F10F.E790                         FDB    CHRS
  593 F111.03                           FCB    ADCTOK
  594 F112.E7B4                         FDB    ADCS
  595 F114.04                           FCB    ABSTOK
  596 F115.E798                         FDB    ABS
  597 F117.05                           FCB    RNDTOK
  598 F118.E79F                         FDB    RND
  599 F11A.06                           FCB    SGNTOK
  600 F11B.E7A6                         FDB    SGN
  601 F11D.07                           FCB    TABTOK
  602 F11E.E7AD                         FDB    TABS
  603 F120.08                           FCB    CALLTOK
  604 F121.E7BB                         FDB    CALL
  605 F123.09                           FCB    PEEKTOK
  606 F124.E7C3                         FDB    PEEK
  607 F126.0A                           FCB    FEEPTOK
  608 F127.E31A                         FDB    EEP
  609 F129.0B                           FCB    HEXTOK
  610 F12A.E7DA                         FDB    HEX
  611 F12C.0C                           FCB    FPRTATOK
  612 F12D.E321                         FDB    PORTA
  613 F12F.0D                           FCB    FPRTBTOK
  614 F130.E32A                         FDB    PORTB
  615 F132.0E                           FCB    FPRTCTOK
  616 F133.E333                         FDB    PORTC
  617 F135.0F                           FCB    FPRTDTOK
  618 F136.E33C                         FDB    PORTD
  619 F138.10                           FCB    FPRTETOK
  620 F139.F151                         FDB    PORTE
  621 F13B.11                           FCB    FTIMETOK
  622 F13C.E34F                         FDB    TIME
  623 F13E.12                           FCB    HEX2TOK
  624 F13F.E7D2                         FDB    HEX2
  625 F141.13                           FCB    FPACCTOK
  626 F142.E35F                         FDB    PACC
  627 F144.00                   IMLET:  FCB    0            ;  NO KETWORD TO PRINT FOR AN IMPLIED LET.
  628 F145.3A                   COLLINC:        FCC    ":"
  629 F146.00                           FCB    0
  630 F147.3B                   SEMIC:  FCC    ";"
  631 F148.00                           FCB    0
  632 F149.2C                   COMMAC: FCC    ","
  633 F14A.00                           FCB    0
  634 F14B.28                   OPARN:  FCC    "("
  635 F14C.00                           FCB    0
  636 F14D.29                   CPARN:  FCC    ")"
  637 F14E.00                           FCB    0
  638 F14F.20                   SPACE:  FCC    " "
  639 F150.00                           FCB    0
  640 F151.504F 5254 45         PORTE:  FCC    "PORTE"
  641 F156.00                           FCB    0
  642 F157.23                   POUNDSGN:       FCC    "#"
  643 F158.00                           FCB    0
  644                           *
  645                           *
  646      F159                 CRUN:   EQU    *
  647 F159:BDE1 0E         [ 6]         JSR    NL2          ; DO 2 CR/LF SEQUENCES.
  648 F15C:BDF2 86         [ 6]         JSR    RUNINIT      ; INITALIZE RUNTIME VARIABLES.
  649 F15F:8601            [ 2]         LDAA   #1           ; SET THE RUN MODE FLAG.
  650 F161:971D            [ 3]         STAA   RUNFLAG
  651                           *
  652                           *        END OF POINTER INITIALIZATIONS
  653                           *
  654 F163:18DE 04         [ 5]         LDY    BASBEG       ; POINT TO THE START OF THE PROGRAM.
  655 F166:189C 06         [ 6]         CPY    BASEND       ; IS THERE A PROGRAM IN MEMORY?
  656 F169:2601 (F16C)     [ 3]         BNE    CRUN5        ; YES. GO RUN IT.
  657 F16B:39              [ 5]         RTS                 ; NO. RETURN.
  658                           *
  659 F16C:18EC 00         [ 6] CRUN5:  LDD    0,Y          ; GET NUMBER OF FIRST/NEXT LINE OF BASIC PROGRAM.
  660 F16F:DD29            [ 4]         STD    CURLINE      ; MAKE IT THE CURRENT LINE.
  661 F171:7D00 1B         [ 6]         TST    TRFLAG       ; IS THE TRACE MODE TURNED ON?
  662 F174:2712 (F188)     [ 3]         BEQ    CRUN6        ; NO. CONTINUE.
  663 F176:865B            [ 2]         LDAA   #'['         ; YES. PRINT THE CURRENT LINE.
  664 F178:BDFE CD         [ 6]         JSR    OUTBYTE
  665 F17B:DC29            [ 4]         LDD    CURLINE
  666 F17D:BDEB 1A         [ 6]         JSR    OUTDECI
  667 F180:865D            [ 2]         LDAA   #']'
  668 F182:BDFE CD         [ 6]         JSR    OUTBYTE
  669 F185:BDE1 10         [ 6]         JSR    NL
  670 F188:183C            [ 5] CRUN6:  PSHY                ; SAVE POINTER TO START OF NEW LINE.
  671 F18A:18E6 02         [ 5]         LDAB   2,Y          ; GET LENGTH OF LINE.
  672 F18D:183A            [ 4]         ABY                 ; POINT TO START OF NEXT LINE.
  673 F18F:18DF 2B         [ 5]         STY    ADRNXLIN     ; SAVE THE ADDRESS OF THE NEXT LINE.
  674 F192:1838            [ 6]         PULY
  675 F194:C603            [ 2]         LDAB   #3           ; BYTE COUNT OF LINE NUMBER & LENGTH.
  676 F196:183A            [ 4]         ABY                 ; POINT TO THE FIRST TOKEN.
  677 F198:8D30 (F1CA)     [ 6] CRUN4:  BSR    RSKIPSPC     ; SKIP SPACES IF PRESENT.
  678 F19A:18E6 00         [ 5]         LDAB   0,Y          ; GET KEYWORD TOKEN.
  679 F19D:1808            [ 4]         INY                 ; POINT PAST THE KEYWORD.
  680 F19F:8D29 (F1CA)     [ 6]         BSR    RSKIPSPC     ; SKIP SPACES AFTER KEYWORD.
  681 F1A1:5A              [ 2]         DECB                ; SUBTRACT ONE FOR INDEXING.
  682 F1A2:58              [ 2]         LSLB                ; MULTIPLY BY THE # OF BYTES PER ADDRESS.
  683 F1A3:CEF1 DA         [ 3]         LDX    #RKEYWORD    ; POINT TO RUN TIME ADDRESS TABLE.
  684 F1A6:3A              [ 3]         ABX                 ; POINT TO ADDRESS
  685 F1A7:EE00            [ 5]         LDX    0,X          ; POINT TO RUNTIME ROUTINE.
  686 F1A9:AD00            [ 6]         JSR    0,X          ; GO DO IT.
  687                           *
  688                           *
  689 F1AB:7A00 1A         [ 6] CRUN2:  DEC    BREAKCNT     ; SHOULD WE CHECK FOR A BREAK YET?
  690 F1AE:2603 (F1B3)     [ 3]         BNE    CRUN7        ; NO. CONTINUE.
  691 F1B0:BDF2 5F         [ 6]         JSR    CHCKBRK      ; CHECK FOR BREAK FROM CONSOLE.
  692                           *
  693 F1B3:8D15 (F1CA)     [ 6] CRUN7:  BSR    RSKIPSPC     ; SKIP ANY SPACES.
  694 F1B5:18A6 00         [ 5]         LDAA   0,Y          ; GET THE NEXT TOKEN IN THE LINE.
  695 F1B8:817D            [ 2]         CMPA   #EOLTOK      ; ARE WE AT THE END OF THE LINE?
  696 F1BA:260A (F1C6)     [ 3]         BNE    CRUN3
  697 F1BC:1808            [ 4]         INY                 ; YES. POINT TO START OF THE NEXT LINE.
  698 F1BE:189C 06         [ 6] CRUN1:  CPY    BASEND       ; HAVE WE REACHED THE END OF THE BASIC PROGRAM?
  699 F1C1:26A9 (F16C)     [ 3]         BNE    CRUN5        ; NO. GO EXECUTE THE NEXT LINE.
  700 F1C3:7EF4 C8         [ 3]         JMP    REND         ; GO DO  AN "END".
  701 F1C6:1808            [ 4] CRUN3:  INY                 ; MUST BE A MID EOL.
  702 F1C8:20CE (F198)     [ 3]         BRA    CRUN4        ; GO DO NEXT KEYWORD.
  703                           *
  704                           *
  705                           *
  706 F1CA:18A6 00         [ 5] RSKIPSPC:       LDAA   0,Y          ; GET A CHARACTER.
  707 F1CD:2B0A (F1D9)     [ 3]         BMI    RSKIP2
  708 F1CF:817E            [ 2]         CMPA   #SSCNTOK     ; IS IT A SINGLE SPACE?
  709 F1D1:2704 (F1D7)     [ 3]         BEQ    RSKIP1       ; YES. BUMP IP BY 1.
  710 F1D3:2504 (F1D9)     [ 3]         BLO    RSKIP2
  711 F1D5:1808            [ 4]         INY                 ; BUMP IP BY 2 FOR MULTIPLE SPACES.
  712 F1D7:1808            [ 4] RSKIP1: INY                 ; BUMP IP.
  713 F1D9:39              [ 5] RSKIP2: RTS                 ; RETURN.
  714                           *
  715                           *
  716      F1DA                 RKEYWORD:       EQU    *
  717 F1DA.F3EC                         FDB    RLET
  718 F1DC.F3EC                         FDB    RLET
  719 F1DE.F614                         FDB    RPRINT
  720 F1E0.F77D                         FDB    RFOR
  721 F1E2.F7D4                         FDB    RNEXT
  722 F1E4.F5FF                         FDB    RTRON
  723 F1E6.F604                         FDB    RTROFF
  724 F1E8.F5B9                         FDB    RPOKE
  725 F1EA.F70C                         FDB    RDIM
  726 F1EC.F3E6                         FDB    RREM
  727 F1EE.FA4C                         FDB    RPACC
  728 F1F0.F3E6                         FDB    RDATA
  729 F1F2.F8F4                         FDB    RREAD
  730 F1F4.F917                         FDB    RRESTOR
  731 F1F6.F479                         FDB    RGOSUB
  732 F1F8.0000                         FDB    0
  733 F1FA.0000                         FDB    0
  734 F1FC.F436                         FDB    RGOTO
  735 F1FE.F556                         FDB    RON
  736 F200.F4A5                         FDB    RRETURN
  737 F202.F951                         FDB    RIF
  738 F204.F814                         FDB    RINPUT
  739 F206.F4B8                         FDB    RSTOP
  740 F208.F4C8                         FDB    REND
  741 F20A.F4EC                         FDB    RWHILE
  742 F20C.F531                         FDB    RENDWH
  743 F20E.F97A                         FDB    REEP
  744 F210.F5D9                         FDB    RPORTA
  745 F212.F5F3                         FDB    RPORTB
  746 F214.F5F7                         FDB    RPORTC
  747 F216.F5FB                         FDB    RPORTD
  748 F218.0000                         FDB    0
  749 F21A.0000                         FDB    0
  750 F21C.0000                         FDB    0
  751 F21E.FA1D                         FDB    RINBYTE
  752 F220.FA2F                         FDB    RTIME
  753 F222.FA61                         FDB    RONTIME
  754 F224.FA78                         FDB    RONIRQ
  755 F226.FA96                         FDB    RRETI
  756 F228.FAB8                         FDB    RONPACC
  757 F22A.F608                         FDB    RSLEEP
  758 F22C.FA3A                         FDB    RRTIME
  759                           *
  760                           *
  761 F22E:BDE1 0E         [ 6] RUNLINE:        JSR    NL2
  762 F231:18DE 4B         [ 5]         LDY    TKNBUFS      ; POINT TO THE TOKEN BUFFER.
  763 F234:18EC 00         [ 6]         LDD    0,Y          ; GET CURRENT LINE NUMBER.
  764 F237:DD29            [ 4]         STD    CURLINE      ; MAKE "0" THE CURRENT LINE #.
  765 F239:C603            [ 2]         LDAB   #3           ; POINT PAST THE LINE NUMBER & LENGTH.
  766 F23B:183A            [ 4]         ABY
  767 F23D:8D8B (F1CA)     [ 6] RUNLINE2:       BSR    RSKIPSPC     ; SKIP SPACES.
  768 F23F:18E6 00         [ 5]         LDAB   0,Y          ; GET KEYWORD.
  769 F242:1808            [ 4]         INY                 ; POINT PAST KEYWORD.
  770 F244:8D84 (F1CA)     [ 6]         BSR    RSKIPSPC     ; SKIP SPACES.
  771 F246:5A              [ 2]         DECB                ; SUBTRACT ONE FOR INDEXING.
  772 F247:58              [ 2]         LSLB                ; MULT BY THE # OF BYTES/ADDRESS.
  773 F248:CEF1 DA         [ 3]         LDX    #RKEYWORD    ; POINT TO ADDRESS TABLE.
  774 F24B:3A              [ 3]         ABX                 ; POINT TO ADDRESS OF RUN TIME ROUTINE.
  775 F24C:EE00            [ 5]         LDX    0,X          ; GET ADDRESS.
  776 F24E:AD00            [ 6]         JSR    0,X          ; GO DO IT.
  777 F250:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES.
  778 F253:18A6 00         [ 5]         LDAA   0,Y
  779 F256:817D            [ 2]         CMPA   #EOLTOK      ; ARE WE AT THE END OF THE LINE?
  780 F258:2601 (F25B)     [ 3]         BNE    RUNLINE1
  781 F25A:39              [ 5]         RTS
  782 F25B:1808            [ 4] RUNLINE1:       INY                 ; MUST BE A MID EOL.
  783 F25D:20DE (F23D)     [ 3]         BRA    RUNLINE2
  784                           *
  785                           *
  786      F25F                 CHCKBRK:        EQU    *
  787 F25F:860A            [ 2]         LDAA   #10          ; RELOAD THE BREAK CHECK COUNT.
  788 F261:971A            [ 3]         STAA   BREAKCNT
  789 F263:9D9E            [ 5]         JSR    CONSTAT      ; GET CONSOLE STATUS. CHARACTER TYPED?
  790 F265:2601 (F268)     [ 3]         BNE    CHCKBRK1     ; YES. GO CHECK IT OUT.
  791 F267:39              [ 5]         RTS                 ; NO. RETURN.
  792 F268:9DA1            [ 5] CHCKBRK1:       JSR    INCONNE      ; GET BYTE FROM CONSOLE BUT DON'T ECHO.
  793 F26A:8103            [ 2]         CMPA   #$03         ; WAS IT A CONTROL-C?
  794 F26C:2701 (F26F)     [ 3]         BEQ    CHCKBRK2     ; YES. GO DO A BREAK.
  795 F26E:39              [ 5]         RTS                 ; NO. RETURN.
  796 F26F:18DF 31         [ 5] CHCKBRK2:       STY    IPSAVE       ; SAVE THE IP POINTER IN CASE OF A CONTINUE.
  797 F272:BDE1 10         [ 6]         JSR    NL
  798 F275:CEEB 09         [ 3]         LDX    #BREAKS      ; POINT TO BREAK STRING.
  799 F278:BDE1 1C         [ 6]         JSR    PL
  800 F27B:DC29            [ 4]         LDD    CURLINE
  801 F27D:BDEB 1A         [ 6]         JSR    OUTDECI
  802 F280:BDE1 10         [ 6]         JSR    NL
  803 F283:7EE0 16         [ 3]         JMP    MAINW
  804                           *
  805                           *
  806                           *
  807                           *
  808      F286                 RUNINIT:        EQU    *
  809 F286:BDF2 DB         [ 6]         JSR    CCLEAR       ; GO CLEAR ALL VARIABLE STORAGE.
  810 F289:DE53            [ 4] RUNINIT1:       LDX    STNUMS      ; GET START OF NUMERIC OPERAND STACK.
  811 F28B:DF1F            [ 4]         STX    NUMSTACK     ; INITALIZE THE OPERAND STACK POINTER.
  812 F28D:DE4F            [ 4]         LDX    STOPS       ; GET THE START OF THE OPERATOR STACK.
  813 F28F:DF21            [ 4]         STX    OPSTACK      ; INITALIZE THE OPREATOR STACK POINTER.
  814 F291:DE57            [ 4]         LDX    STFORSTK    ; GET THE START OF THE FOR-NEXT STACK.
  815 F293:DF23            [ 4]         STX    FORSTACK     ; INITALIZE THE FOR NEXT STACK POINTER.
  816 F295:DE5B            [ 4]         LDX    STWHSTK     ; GET THE START OF THE WHILE STACK.
  817 F297:DF25            [ 4]         STX    WHSTACK      ; INITALIZE THE WHILE STACK POINTER.
  818 F299:DE5F            [ 4]         LDX    STGOSTK     ; GET THE START OF THE GOSUB STACK.
  819 F29B:DF27            [ 4]         STX    GOSTACK      ; SET THE START OF THE GOSUB STACK.
  820 F29D:DE0A            [ 4]         LDX    VAREND       ; GET THE VARIABLE END POINTER.
  821 F29F:08              [ 3]         INX                 ; POINT TO THE NEXT AVAILABLE BYTE.
  822 F2A0:DF2D            [ 4]         STX    STRASTG      ; INITALIZE THE STRING/ARRAY STORAGE POINTER.
  823 F2A2:7F00 1E         [ 6]         CLR    PRINTPOS     ; SET THE CURRENT PRINT POSITION TO 0.
  824 F2A5:860A            [ 2]         LDAA   #10          ; SET COUNT FOR BREAK CHECK.
  825 F2A7:971A            [ 3]         STAA   BREAKCNT
  826 F2A9:7F00 1C         [ 6]         CLR    CONTFLAG     ; CLEAR THE CONTINUE FLAG.
  827 F2AC:CE00 00         [ 3]         LDX    #0           ; CLEAR THE DATA POINTER.
  828 F2AF:DF33            [ 4]         STX    DATAPTR
  829 F2B1:39              [ 5]         RTS
  830                           *
  831                           *
  832      F2B2                 CCONT:  EQU    *
  833 F2B2:BDE1 0E         [ 6]         JSR    NL2
  834 F2B5:7D00 1C         [ 6]         TST    CONTFLAG
  835 F2B8:2606 (F2C0)     [ 3]         BNE    CCONT1
  836 F2BA:18DE 31         [ 5]         LDY    IPSAVE
  837 F2BD:7EF1 B3         [ 3]         JMP    CRUN7
  838 F2C0:8625            [ 2] CCONT1: LDAA   #CNTCNERR
  839 F2C2:9718            [ 3]         STAA   ERRCODE
  840 F2C4:7EEA D6         [ 3]         JMP    RPTERR5
  841                           *
  842                           *
  843      F2C7                 CNEW:   EQU    *
  844 F2C7:FEFF C4         [ 5]         ldx    EEStart
  845 F2CA:A60A            [ 4]         LDAA   AUTOSTF,X   ;  GET THE AUTO START FLAG.
  846 F2CC:8155            [ 2]         CMPA   #$55         ; IS IT SET?
  847 F2CE:2607 (F2D7)     [ 3]         BNE    CNEW1        ; NO. GO INITIALIZE EVERYTHING.
  848 F2D0:86FF            [ 2]         LDAA   #$FF         ; YES. RESET (ERASE) IT.
  849 F2D2:A70A            [ 4]         STAA   AUTOSTF,X
  850 F2D4:BDFA 14         [ 6]         JSR    DLY10MS
  851 F2D7:BDEC FA         [ 6] CNEW1:  JSR    INITVARS     ; INITIALIZE EVERYTHING.
  852 F2DA:39              [ 5]         RTS                 ; RETURN.
  853                           *
  854                           *
  855      F2DB                 CCLEAR: EQU    *
  856 F2DB:BDF2 89         [ 6]         JSR    RUNINIT1     ; GO INITALIZE ALL STACKS ETC.
  857 F2DE:DE08            [ 4] CCLEAR3:        LDX    VARBEGIN
  858 F2E0:A600            [ 4] CCLEAR1:        LDAA   0,X
  859 F2E2:2708 (F2EC)     [ 3]         BEQ    CCLEAR2
  860 F2E4:08              [ 3]         INX
  861 F2E5:08              [ 3]         INX
  862 F2E6:08              [ 3]         INX
  863 F2E7:BDE6 52         [ 6]         JSR    CLRVAR
  864 F2EA:20F4 (F2E0)     [ 3]         BRA    CCLEAR1
  865 F2EC:DE0A            [ 4] CCLEAR2:        LDX    VAREND
  866 F2EE:08              [ 3]         INX
  867 F2EF:DF2D            [ 4]         STX    STRASTG
  868 F2F1:39              [ 5]         RTS
  869                           *
  870                           *
*** END   INCLUDE FILE: COMMAND1.ASM *** (RESUMING FILE: BASIC11.ASM)
   15                           #Include  'COMMAND2.Asm'
*** BEGIN INCLUDE FILE: COMMAND2.ASM ***
    1                           *        name    COMMAND2
    2                           *        page
    3                           *
    4                           *
    5      F2F2                 CESAVE: EQU    *
    6 F2F2:DC04            [ 4]         LDD    BASBEG   ; GET POINTER TO THE START OF THE BASIC PROGRAM.
    7 F2F4:1A93 06         [ 6]         CPD    BASEND   ; IS THERE A PROGRAM IN MEMORY?
    8 F2F7:2601 (F2FA)     [ 3]         BNE    CESAVE1  ; YES. GO SAVE IT.
    9 F2F9:39              [ 5]         RTS             ; NO. RETURN.
   10 F2FA:DC0A            [ 4] CESAVE1:        LDD     VAREND
   11 F2FC:9304            [ 5]         SUBD    BASBEG
   12 F2FE:1AB3 FFC6       [ 7]         CPD     EESIZE
   13 F302:2305 (F309)     [ 3]         BLS     CESAVE5
   14 F304:8637            [ 2]         LDAA    #EETOSMAL
   15 F306:7EEA 98         [ 3]         JMP     RPTERR
   16 F309:FEFF C4         [ 5] CESAVE5:        LDX     EEStart ; point to the start of the EEPROM.
   17 F30C:18CE 0004       [ 4]         LDY     #BASBEG
   18 F310:C604            [ 2]         LDAB    #4
   19 F312:D71A            [ 3]         STAB    COUNT
   20 F314:18EC 00         [ 6] CESAVE3:        LDD     0,Y
   21 F317:B3FF C0         [ 6]         SUBD    RAMSTART
   22 F31A:A700            [ 4]         STAA    0,X
   23 F31C:BDFA 14         [ 6]         JSR     DLY10MS
   24 F31F:08              [ 3]         INX
   25 F320:17              [ 2]         TBA
   26 F321:A700            [ 4]         STAA    0,X
   27 F323:BDFA 14         [ 6]         JSR     DLY10MS
   28 F326:08              [ 3]         INX
   29 F327:1808            [ 4]         INY
   30 F329:1808            [ 4]         INY
   31 F32B:7A00 1A         [ 6]         DEC     COUNT
   32 F32E:26E4 (F314)     [ 3]         BNE     CESAVE3
   33                           *
   34 F330:18EC 00         [ 6]         LDD     0,Y
   35 F333:A700            [ 4]         STAA    0,X
   36 F335:BDFA 14         [ 6]         JSR     DLY10MS
   37 F338:08              [ 3]         INX
   38 F339:17              [ 2]         TBA
   39 F33A:A700            [ 4]         STAA    0,X
   40 F33C:BDFA 14         [ 6]         JSR     DLY10MS
   41                           
   42                           *
   43 F33F:FEFF C4         [ 5]         LDX     EEStart
   44 F342:18DE 04         [ 5]         LDY     BASBEG
   45 F345:18A6 00         [ 5] CESAVE4:        LDAA    0,Y
   46 F348:A70B            [ 4]         STAA    SSTART,X
   47 F34A:BDFA 14         [ 6]         JSR     DLY10MS
   48 F34D:08              [ 3]         INX
   49 F34E:1808            [ 4]         INY
   50 F350:189C 0A         [ 6]         CPY     VAREND
   51 F353:23F0 (F345)     [ 3]         BLS     CESAVE4
   52 F355:39              [ 5]         RTS                    ;RETURN.
   53                           *
   54                           *
   55      F356                 CELOAD: EQU    *
   56 F356:FEFF C4         [ 5]         LDX     EEStart ; point to the start of the program storage EEPROM.
   57 F359:18CE 0004       [ 4]         LDY     #BASBEG ; point to the start of the program pointer storage area.
   58 F35D:C604            [ 2]         LDAB    #4      ; number of words to move.
   59 F35F:D71A            [ 3]         STAB    COUNT   ; save the count.
   60 F361:EC00            [ 5] CELOAD3:        LDD     0,X     ; get the offset that was saved.
   61 F363:F3FF C0         [ 6]         ADDD    RAMSTART        ; add the starting address of the RAM to it.
   62 F366:18ED 00         [ 6]         STD     0,Y     ; save the resulting pointer
   63 F369:08              [ 3]         INX             ; point to the next offset.
   64 F36A:08              [ 3]         INX
   65 F36B:1808            [ 4]         INY             ; point to the next pointer in RAM
   66 F36D:1808            [ 4]         INY
   67 F36F:7A00 1A         [ 6]         DEC     COUNT   ; have we gotten all the pointers yet?
   68 F372:26ED (F361)     [ 3]         BNE     CELOAD3 ; no. keep going.
   69                           *
   70 F374:EC00            [ 5]         LDD     0,X     ; yes. get the high line number.
   71 F376:18ED 00         [ 6]         STD     0,Y     ; save it in RAM.
   72                           
   73                           *
   74                           *       now load the actual program from EEPROM
   75                           *
   76 F379:FEFF C4         [ 5]         LDX     EEStart ; point to the start of the EEPROM
   77 F37C:18DE 04         [ 5]         LDY     BASBEG  ; point to the start of the BASIC program buffer.
   78 F37F:A60B            [ 4] CELOAD4:        LDAA    SSTART,X        ; get a byte of the program.
   79 F381:18A7 00         [ 5]         STAA    0,Y     ; put it in the program buffer.
   80 F384:08              [ 3]         INX             ; point to the next program byte
   81 F385:1808            [ 4]         INY             ; point to the next buffer location.
   82 F387:189C 0A         [ 6]         CPY     VAREND  ; have we finished loading the program.
   83 F38A:23F3 (F37F)     [ 3]         BLS     CELOAD4 ; no. keep loading.
   84 F38C:18DF 2D         [ 5]         STY     STRASTG ; yes. initialize the array storage area.
   85 F38F:39              [ 5]         RTS             ; RETURN.
   86                                   
   87                           *
   88                           *
   89      F390                 CLLIST: EQU    *
   90 F390:8601            [ 2]         LDAA   #$01     ; USE DEVICE #1 FOR HARD COPY LISTING.
   91 F392:9737            [ 3]         STAA   DEVNUM
   92 F394:BDEE C5         [ 6]         JSR    CLIST    ; GO DO A STANDARD LIST COMMAND.
   93 F397:7F00 37         [ 6]         CLR    DEVNUM
   94 F39A:39              [ 5]         RTS             ; RETURN.
   95                           *
   96                           *
   97                           *
   98      F39B                 CAUTOST:        EQU    *            ; SET AUTO START MODE FOR BASIC PROGRAM.
   99 F39B:8655            [ 2]         LDAA   #$55         ; GET FLAG.
  100 F39D:FEFF C4         [ 5] CAUTOST1:       LDX    EEStart
  101 F3A0:A70A            [ 4]         STAA   AUTOSTF,x    ; PROGRAM IT INTO THE EEPROM
  102 F3A2:BDFA 14         [ 6]         JSR    DLY10MS      ; WAIT WHILE IT PROGRAMS.
  103 F3A5:39              [ 5]         RTS                 ; RETURN.
  104                           *
  105                           *
  106                           *
  107      F3A6                 CNOAUTO:        EQU    *
  108 F3A6:86FF            [ 2]         LDAA   #$FF
  109 F3A8:20F3 (F39D)     [ 3]         BRA    CAUTOST1
  110                           *
  111                           *
  112                           *
  113      F3AA                 AUTOLOAD:       EQU     *
  114 F3AA:FEFF C4         [ 5]          ldx    EESTART
  115 F3AD:FCFF C4         [ 5]          LDD    EESTART
  116 F3B0:C300 0B         [ 4]          ADDD   #SSTART
  117 F3B3:DD04            [ 4]          STD    BASBEG
  118 F3B5:FCFF C4         [ 5]          LDD    EESTART
  119 F3B8:E302            [ 6]          ADDD   SBASEND,x
  120 F3BA:C300 0B         [ 4]          ADDD   #SSTART
  121 F3BD:DD06            [ 4]          STD    BASEND
  122                           *
  123 F3BF:EC06            [ 5]          LDD    SVAREND,x
  124 F3C1:A304            [ 6]          SUBD   SVARBEG,x
  125 F3C3:F3FF C0         [ 6]          ADDD   RAMSTART
  126 F3C6:DD0A            [ 4]          STD    VAREND
  127 F3C8:FCFF C0         [ 5]          LDD    RAMSTART
  128 F3CB:DD08            [ 4]          STD    VARBEGIN
  129 F3CD:188F            [ 4]          XGDY
  130 F3CF:FCFF C4         [ 5]          LDD    EESTART
  131 F3D2:E304            [ 6]          ADDD   SVARBEG,X
  132 F3D4:8F              [ 3]          XGDX
  133 F3D5:20A8 (F37F)     [ 3]          BRA    CELOAD4
  134                           *
  135                           *
  136      F3D7                 CFREE:          EQU     *
  137 F3D7:BDE1 0E         [ 6]         JSR     NL2
  138 F3DA:DC10            [ 4]         LDD     VARMEND
  139 F3DC:932D            [ 5]         SUBD    STRASTG
  140 F3DE:BDEB 1A         [ 6]         JSR     OUTDECI
  141 F3E1:BDE1 10         [ 6]         JSR     NL
  142 F3E4:39              [ 5]         RTS
  143                           *
  144                           *
  145      F3E5                 CDUMP:          EQU     *
  146                           *       JSR     NL2             ; PRINT TWO BLANK LINES.
  147                           *       CLR     DNAME+2         ; ZERO THE LAST BYTE OF THE VARIABLE NAME 'ARRAY'
  148                           *       LDX     VARBEGIN                ; POINT TO THE START OF THE VARIABLE TABLE.
  149                           *CDUMP2  LDAA   0,X             ; GET AN ENTRY. IS IT THE END OF THE TABLE?
  150                           *        BNE    CDUMP3          ; YES. WE'RE DONE.
  151 F3E5:39              [ 5]         RTS
  152                           *CDUMP3 LDAA    1,X             ; NO. GET THE FIRST CHARACTER OF THE NAME.
  153                           *       STAA    DNAME
  154                           *       LDAA    2,X
  155                           *       STAA    DNAME+1
  156                           *       LDX     #DNAME
  157                           *       JSR     PL
  158                           *       LDAA    0,X             ; GET THE VARIABLE TOKEN.
  159                           *       CMPA    #IVARTOK                ; IS IT AN INTEGER?
  160                           *       BEQ     CDUMP9          ; YES. DUMP ITS VALUE.
  161                           ;       CMPA    #IAVARTOK       ; NO. IS IT AN INTEGER ARRAY?
  162                           ;       BNE     CDUMP99         ; NO.
  163                           *       LDD     3,X             ; YES. GET THE POINTER TO THE ARRAY STORAGE. HAS IT BEEN DIMENSIONED?
  164                           *       BNE     CDUMP5          ; YES. GO PRINT ALL THE VALUES.
  165                           *       LDX     #UNDIM
  166                           *       JSR     PL
  167                           *CDUMP6 LDAB    #5
  168                           *       ABX
  169                           *       BRA     CDUMP2
  170                           *CDUMP5 PSHX                    ; SAVE THE POINTER TO THE VARIABLE TABLE.
  171                           *       XGDX                    ; POINT TO THE ARRAY STORAGE AREA.
  172                           *       LDD     0,X             ; GET THE MAXIMUM SUBSCRIPT.
  173                           *       STD     SUBMAX
  174                           *       CLRA
  175                           *       CLRB
  176                           *       STD     SUBCNT
  177                           *CDUMP77        LDAA    #'('
  178                           *       JSR     OUTBYTE
  179                           *       LDD     SUBCNT
  180                           *       JSR     OUTDECI
  181                           *       LDX     #CPEQ
  182                           *       JSR     PL
  183                           *       INX
  184                           *       INX
  185                           *       LDD     0,X
  186                           *       JSR     OUTDECI
  187                           *       JSR     NL
  188                           *       LDD     SUBCNT
  189                           *       ADDD    #1
  190                           *       CMPD    SUBMAX
  191                           *       BHI     CDUMP88
  192                           *       STD     SUBCNT
  193                           *       LDX     #DNAME
  194                           *       JSR     PL
  195                           *       BRA     CDUMP77
  196                           *CDUMP88        PULX
  197                           *       BRA     CDUMP6
  198                           *CDUMP9 LDAA    #'='
  199                           *       JSR     OUTBYTE
  200                           *       LDD     3,X
  201                           *       JSR     OUTDECI
  202                           *       JSR     NL
  203                           *       BRA     CDUMP6
  204                           *
  205                           *
  206                           *UNDIM  FCB     '=[?]',0
  207                           *CPEQ   FCB     ')=',0
*** END   INCLUDE FILE: COMMAND2.ASM *** (RESUMING FILE: BASIC11.ASM)
   16                           #Include  'RUNTIME1.Asm'
*** BEGIN INCLUDE FILE: RUNTIME1.ASM ***
    1                           *        title    RUNTIME1
    2                           *        page
    3                           *
    4                           *
    5      F3E6                 RREM:   EQU    *            ; NON-EXECUTIBLE STATEMENT JUST SKIP IT.
    6      F3E6                 RDATA:  EQU    *
    7 F3E6:18E6 00         [ 5]         LDAB   0,Y          ; GET LENGTH OF REMARK OR DATA LINE.
    8 F3E9:183A            [ 4]         ABY                 ; POINT TO THE EOLTOK.
    9 F3EB:39              [ 5]         RTS                 ; RETURN.
   10                           *
   11                           *
   12                           *
   13                           *
   14      F3EC                 RLET:   EQU    *
   15 F3EC:18A6 00         [ 5]         LDAA   0,Y          ; GET VARIABLE FLAG.
   16 F3EF:8D0E (F3FF)     [ 6]         BSR    RVARPTR      ; GET POINTER TO ASIGNMENT VARIABLE.
   17                           *        PSHD                SAVE POINTER TO VARIABLE.
   18 F3F1:37              [ 3]         PSHB
   19 F3F2:36              [ 3]         PSHA
   20 F3F3:1808            [ 4]         INY                 ; PUT IP PAST THE "=" TOKEN.
   21 F3F5:BDFB 12         [ 6]         JSR    DONEXP       ; EVALUATE THE EXPRESSION.
   22 F3F8:BDFB B9         [ 6]         JSR    PULNUM       ; GET VALUE INTO D.
   23 F3FB:38              [ 5]         PULX                ; POINT TO THE DICTIONARY ENTRY.
   24 F3FC:ED00            [ 5]         STD    0,X          ; STORE VALUE.
   25 F3FE:39              [ 5]         RTS                 ; BACK TO MAIN INTERPRET LOOP.
   26                           *
   27                           *
   28 F3FF:18A6 00         [ 5] RVARPTR:        LDAA   0,Y          ; GET VARIABLE FLAG.
   29 F402:8502            [ 2]         BITA   #$02         ; IS IT A STRING VARIABLE?
   30 F404:261D (F423)     [ 3]         BNE    RVARPTR2     ; YES. GO GET POINTER FOR A STRING DESCRIPTOR.
   31 F406:8510            [ 2]         BITA   #$10         ; IS IT A NUMERIC ARRAY VARIABLE?
   32 F408:260F (F419)     [ 3]         BNE    RVARPTR1     ; YES. GO CALCULATE THE SUBSCRIPT.
   33 F40A:18EC 01         [ 6] RVARPTR3:       LDD    1,Y          ; GET THE OFFSET TO THE DICTIONARY ENTRY.
   34 F40D:D308            [ 5]         ADDD   VARBEGIN     ; ADD IN THE START ADDRESS OF THE DCTIONARY.
   35 F40F:C300 03         [ 4]         ADDD   #3           ; MAKE POINTER POINT TO THE ACTUAL STORAGE LOCATION
   36 F412:37              [ 3]         PSHB                ; SAVE B.
   37 F413:C603            [ 2]         LDAB   #3           ; POINT TO THE FIRST ELEMENT PAST THE VARIABLE.
   38 F415:183A            [ 4]         ABY
   39 F417:33              [ 4]         PULB                ; RESTORE B.
   40 F418:39              [ 5]         RTS
   41      F419                 RVARPTR1:       EQU    *
   42 F419:BDFB 90         [ 6]         JSR    CALCSUB      ; GO GET BASE ADDR & EVALUATE SUBSCRIPT EXPRESSION.
   43 F41C:3C              [ 4]         PSHX                ; PUSH BASE ADDRESS ONTO STACK.
   44 F41D:30              [ 3]         TSX                 ; POINT TO IT.
   45 F41E:05              [ 3]         LSLD                ; MULT THE SUBSCRIPT BY THE # OF BYTES/ELEMENT.
   46 F41F:E300            [ 6] RVARPTR4:       ADDD   0,X          ; GET ADDRESS OF ELEMENT.
   47 F421:38              [ 5]         PULX                ; RESTORE X.
   48 F422:39              [ 5]         RTS                 ; RETURN.
   49      F423                 RVARPTR2:       EQU    *
   50 F423:8510            [ 2]         BITA   #$10         ; IS IT A STRING ARRAY?
   51 F425:27E3 (F40A)     [ 3]         BEQ    RVARPTR3     ; NO. JUST GO GET POINTER TO DESCRIPTOR.
   52 F427:BDFB 90         [ 6]         JSR    CALCSUB      ; GET BASE ADDR. & CALC SUBSCRIPT.
   53 F42A:3C              [ 4]         PSHX                ; SAVE THE BASE ADDRESS.
   54                           *        PSHD                SAVE THE SUBSCRIPT VALUE.
   55 F42B:37              [ 3]         PSHB
   56 F42C:36              [ 3]         PSHA
   57 F42D:30              [ 3]         TSX                 ; POINT TO THE VALUES.
   58 F42E:05              [ 3]         LSLD                ; MULT BY 2.
   59 F42F:E300            [ 6]         ADDD   0,X          ; MULT BY 3.
   60 F431:31              [ 3]         INS                 ; GET RID OF SUBSCRIPT VALUE.
   61 F432:31              [ 3]         INS
   62 F433:30              [ 3]         TSX                 ; POINT TO BASE ADDRESS.
   63 F434:20E9 (F41F)     [ 3]         BRA    RVARPTR4
   64                           *
   65                           *
   66                           *
   67                           *
   68      F436                 RGOTO:  EQU    *
   69 F436:7D00 19         [ 6]         TST    IMMID        ; DID WE ENTER HERE FROM THE IMMIDIATE MODE?
   70 F439:2704 (F43F)     [ 3]         BEQ    RGOTO7       ; NO. JUST GO DO A GOTO.
   71 F43B:DC06            [ 4]         LDD    BASEND       ; YES. SET ADRNXLIN TO END OF PROGRAM SO THE
   72 F43D:DD2B            [ 4]         STD    ADRNXLIN     ; SEARCH STARTS AT THE FIRST LINE.
   73 F43F:DE2B            [ 4] RGOTO7: LDX    ADRNXLIN     ; POINT TO THE START OF THE NEXT LINE.
   74 F441:9C06            [ 5]         CPX    BASEND       ; IS THIS THE LAST LINE OF THE PROGRAM?
   75 F443:2604 (F449)     [ 3]         BNE    RGOTO1       ; NO. SEARCH STARTING AT THE NEXT LINE.
   76 F445:DE04            [ 4] RGOTO3: LDX    BASBEG       ; YES. POINT TO THE START OF THE BASIC PROGRAM.
   77 F447:2007 (F450)     [ 3]         BRA    RGOTO2
   78 F449:EC00            [ 5] RGOTO1: LDD    0,X          ; GET THE NEXT LINE NUMBER IN THE PGM.
   79 F44B:CDA3 01         [ 7]         CPD    1,Y          ; IS IT > THE LINE NUMBER WE ARE TO "GOTO"?
   80 F44E:22F5 (F445)     [ 3]         BHI    RGOTO3       ; YES. START THE SEARCH AT THE BEGINING.
   81 F450:EC00            [ 5] RGOTO2: LDD    0,X          ; GET THE NEXT LINE NUMBER INTO D.
   82 F452:CDA3 01         [ 7]         CPD    1,Y          ; IS THIS THE CORRECT LINE?
   83 F455:2710 (F467)     [ 3]         BEQ    RGOTO4       ; YES. "GOTO" THE NEW LINE.
   84 F457:2505 (F45E)     [ 3]         BLO    RGOTO5       ; NO. IS IT LESS THAN THE "TARGET LINE"?
   85 F459:861B            [ 2] RGOTO6: LDAA   #LNFERR      ; NO. THE LINE MUST NOT EXIST.
   86 F45B:7EEA EF         [ 3]         JMP    RPTRERR      ; REPORT THE ERROR & RETURN TO MAIN LOOP.
   87 F45E:E602            [ 4] RGOTO5: LDAB   2,X          ; GET THE LENGTH OF THIS LINE.
   88 F460:3A              [ 3]         ABX                 ; POINT TO THE START OF THE NEXT LINE.
   89 F461:9C06            [ 5]         CPX    BASEND       ; DID WE HIT THE END OF THE PROGRAM?
   90 F463:27F4 (F459)     [ 3]         BEQ    RGOTO6       ; YES. THE LINE DOESN'T EXIST.
   91 F465:20E9 (F450)     [ 3]         BRA    RGOTO2       ; NO. GO SEE IF THIS IS THE CORRECT LINE.
   92 F467:8F              [ 3] RGOTO4: XGDX                ; MAKE IT THE NEW IP.
   93 F468:188F            [ 4]         XGDY
   94 F46A:7D00 19         [ 6]         TST    IMMID
   95 F46D:2706 (F475)     [ 3]         BEQ    RGOTO8
   96 F46F:7F00 19         [ 6]         CLR    IMMID
   97 F472:7EF1 BE         [ 3] RGOTO9: JMP    CRUN1
   98 F475:31              [ 3] RGOTO8: INS
   99 F476:31              [ 3]         INS
  100 F477:20F9 (F472)     [ 3]         BRA    RGOTO9
  101                           *
  102                           *
  103      F479                 RGOSUB: EQU    *
  104 F479:183C            [ 5]         PSHY                ; SAVE THE I.P. TO THE LINE NUMBER.
  105 F47B:7D00 19         [ 6]         TST    IMMID        ; DID WE GET HERE FROM THE IMMIDIATE MODE?
  106 F47E:2707 (F487)     [ 3]         BEQ    RGOSUB3      ; NO. GO DO A NORMAL GOSUB.
  107 F480:18DE 06         [ 5]         LDY    BASEND       ; YES. MAKE RETURN POINT TO THE LAST EOL TOKEN
  108 F483:1809            [ 4]         DEY                 ; IN THE PROGRAM.
  109 F485:2004 (F48B)     [ 3]         BRA    RGOSUB2      ; GO PUT IT ON THE ARGUMENT STACK.
  110 F487:C603            [ 2] RGOSUB3:        LDAB   #3           ; BYPASS THE LINE NUMBER.
  111 F489:183A            [ 4]         ABY
  112 F48B:BDF1 CA         [ 6] RGOSUB2:        JSR    RSKIPSPC     ; SKIP SPACES AFTER THE LINE NUMBER.
  113 F48E:DE27            [ 4]         LDX    GOSTACK      ; GET THE GOSUB STACK POINTER.
  114 F490:09              [ 3]         DEX                 ; POINT TO THE NEXT ENTRY ON THE STACK.
  115 F491:09              [ 3]         DEX
  116 F492:9C5D            [ 5]         CPX    EGOSTK       ; OUT OF STACK SPACE?
  117 F494:2405 (F49B)     [ 3]         BHS    RGOSUB1      ; NO. GO PUSH THE "RETURN ADDRESS" ON THE STACK.
  118 F496:861C            [ 2]         LDAA   #GOSOVERR    ; YES. GET THE ERRCODE.
  119 F498:7EEA EF         [ 3]         JMP    RPTRERR      ; GO REPORT THE ERROR.
  120 F49B:DF27            [ 4] RGOSUB1:        STX    GOSTACK      ; SAVE THE "GOSUB" STACK POINTER.
  121 F49D:1AEF 00         [ 6]         STY    0,X          ; PUT THE RETURN ADDRESS ON THE STACK.
  122 F4A0:1838            [ 6]         PULY                ; GET THE POINTER TO THE LINE NUMBER.
  123 F4A2:7EF4 36         [ 3]         JMP    RGOTO        ; GO DO A "GOTO".
  124                           *
  125                           *
  126      F4A5                 RRETURN:        EQU    *
  127 F4A5:DE27            [ 4]         LDX    GOSTACK      ; GET THE GOSUB STACK POINTER.
  128 F4A7:9C5F            [ 5]         CPX    STGOSTK      ; IS THERE A RETURN ADDRESS ON THE GOSUB STACK?
  129 F4A9:2605 (F4B0)     [ 3]         BNE    RRETURN1     ; YES. GO RETURN.
  130 F4AB:861D            [ 2]         LDAA   #RWOGERR     ; NO. RETURN W/O GOSUB ERROR.
  131 F4AD:7EEA EF         [ 3]         JMP    RPTRERR      ; REPORT THE ERROR.
  132 F4B0:1AEE 00         [ 6] RRETURN1:       LDY    0,X          ; GET THE RETURN ADDRESS IN THE IP.
  133 F4B3:08              [ 3]         INX                 ; REMOVE THE ADDRESS FROM THE STACK.
  134 F4B4:08              [ 3]         INX
  135 F4B5:DF27            [ 4]         STX    GOSTACK      ; SAVE THE STACK POINTER.
  136 F4B7:39              [ 5]         RTS                 ; BACK TO THE MAIN INTERPRET LOOP.
  137                           *
  138                           *
  139      F4B8                 RSTOP:  EQU    *
  140 F4B8:CEF4 D7         [ 3]         LDX    #STOPSTR
  141 F4BB:BDE1 1C         [ 6]         JSR    PL
  142 F4BE:DC29            [ 4]         LDD    CURLINE
  143 F4C0:BDEB 1A         [ 6]         JSR    OUTDECI
  144 F4C3:18DF 31         [ 5]         STY    IPSAVE
  145 F4C6:2007 (F4CF)     [ 3]         BRA    REND1
  146      F4C8                 REND:   EQU    *
  147 F4C8:BDE1 10         [ 6]         JSR    NL
  148 F4CB:8601            [ 2]         LDAA   #1
  149 F4CD:971C            [ 3]         STAA   CONTFLAG
  150 F4CF:CC00 00         [ 3] REND1:  LDD    #0
  151 F4D2:DD29            [ 4]         STD    CURLINE
  152 F4D4:7EE0 16         [ 3]         JMP    MAINW
  153                           *
  154                           *
  155 F4D7.0A                   STOPSTR:        FCB    $0A,$0D
  155 F4D8.0D                   
  156 F4D9.5354 4F50 5045               FCC    "STOPPED AT LINE # "
  156      4420 4154 204C  
  156      494E 4520 2320  
  157 F4EB.00                           FCB    0
  158                           *
  159                           *
  160      F4EC                 RWHILE: EQU    *
  161 F4EC:DE25            [ 4]         LDX    WHSTACK      ; GET THE WHILE STACK POINTER.
  162 F4EE:09              [ 3]         DEX                 ; POINT TO THE NEXT STACK LOCATION.
  163 F4EF:09              [ 3]         DEX
  164 F4F0:9C59            [ 5]         CPX    EWHSTK       ; ARE WE AT THE END OF THE STACK?
  165 F4F2:2405 (F4F9)     [ 3]         BHS    RWHILE4      ; NO. GO STACK IT.
  166 F4F4:861E            [ 2]         LDAA   #WHSOVERR    ; YES. WHILE STACK OVER FLOW.
  167 F4F6:7EEA EF         [ 3]         JMP    RPTRERR      ; REPORT THE ERROR.
  168 F4F9:DF25            [ 4] RWHILE4:        STX    WHSTACK      ; SAVE THE WHILE STACK POINTER.
  169 F4FB:1AEF 00         [ 6]         STY    0,X          ; PUT IT ON THE STACK.
  170 F4FE:C601            [ 2]         LDAB   #$01         ; GET THE WHILE COUNT INTO B. (FOR NESTED WHILE'S)
  171 F500:37              [ 3] RWHILE3:        PSHB
  172 F501:18DE 2B         [ 5]         LDY    ADRNXLIN     ; GET THE ADDRESS OF THE NEXT LINE.
  173 F504:2601 (F507)     [ 3]         BNE    RWHILE2
  174 F506:39              [ 5]         RTS
  175 F507:183C            [ 5] RWHILE2:        PSHY                ; SAVE THE IP.
  176 F509:189C 06         [ 6]         CPY    BASEND       ; ARE WE AT THE END OF THE PROGRAM?
  177 F50C:27BA (F4C8)     [ 3]         BEQ    REND         ; YES. DO AN END.
  178 F50E:DE2B            [ 4]         LDX    ADRNXLIN     ; NO. GET THE ADDRESS OF THE NEXT LINE IN X.
  179 F510:E602            [ 4]         LDAB   2,X          ; GET THE LENGTH OF THIS LINE.
  180 F512:3A              [ 3]         ABX                 ; POINT TO THE START OF THE NEXT LINE.
  181 F513:DF2B            [ 4]         STX    ADRNXLIN     ; SAVE IT.
  182 F515:C603            [ 2]         LDAB   #3           ; POINT PAST THE LINE NUMBER & LINE LENGTH.
  183 F517:183A            [ 4]         ABY
  184 F519:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP ANY SPACES.
  185 F51C:18A6 00         [ 5]         LDAA   0,Y          ; GET THE KEYWORD TOKEN.
  186 F51F:1838            [ 6]         PULY                ; RESTORE THE IP.
  187 F521:33              [ 4]         PULB                ; GET THE NESTED WHILE COUNT.
  188 F522:8119            [ 2]         CMPA   #WHILETOK    ; IS IT ANOTHER WHILE?
  189 F524:2601 (F527)     [ 3]         BNE    RWHILE1      ; NO. GO CHECK FOR ENDWH.
  190 F526:5C              [ 2]         INCB                ; YES. UP THE NESTED WHILE COUNT.
  191 F527:811A            [ 2] RWHILE1:        CMPA   #ENDWHTOK    ; IS IT THE END WHILE STATEMENT?
  192 F529:26D5 (F500)     [ 3]         BNE    RWHILE3      ; NO. GO LOOK AT THE NEXT LINE.
  193 F52B:5A              [ 2]         DECB                ; YES. IS IT THE CORRECT 'ENDWH'?
  194 F52C:26D2 (F500)     [ 3]         BNE    RWHILE3      ; NO. LOOK FOR ANOTHER ONE.
  195 F52E:7EF4 75         [ 3]         JMP    RGOTO8       ; BACK TO INTERPRET LOOP.
  196                           *
  197                           *
  198                           *
  199                           *
  200      F531                 RENDWH: EQU    *
  201 F531:DE25            [ 4]         LDX    WHSTACK      ; GET THE WHILE STACK POINTER.
  202 F533:9C5B            [ 5]         CPX    STWHSTK      ; HAS A WHILE STATEMENT BEEN EXECUTED?
  203 F535:2605 (F53C)     [ 3]         BNE    RENDWH1      ; YES. GO GET THE ADDRESS OF THE WHILE STATEMENT.
  204 F537:861F            [ 2]         LDAA   #ENDWHERR    ; NO. GET ENDWHILE ERROR.
  205 F539:7EEA EF         [ 3]         JMP    RPTRERR      ; REPORT THE ERROR.
  206 F53C:183C            [ 5] RENDWH1:        PSHY                ; SAVE THE IP IN CASE THE WHILE TEST FAILS.
  207 F53E:1AEE 00         [ 6]         LDY    0,X          ; GET THE IP POINTER TO THE WHILE EXPRESSION.
  208 F541:BDFB 12         [ 6]         JSR    DONEXP       ; YES. GO EVALUATE A NUMERIC EXPRESSION.
  209 F544:BDFB B9         [ 6]         JSR    PULNUM       ; GET RESULT OFF NUMERIC STACK. IS IT TRUE?
  210 F547:260A (F553)     [ 3]         BNE    RENDWH3      ; YES. GO EXECUTE CODE BETWEEN WHILE & ENDWH.
  211 F549:1838            [ 6]         PULY                ; NO. GET THE ADDRESS OF THE NEXT LINE/STATEMENT.
  212 F54B:DE25            [ 4]         LDX    WHSTACK      ; GET WHILE STACK POINTER.
  213 F54D:08              [ 3]         INX                 ; TAKE ADDRESS OFF OF WHILE STACK.
  214 F54E:08              [ 3]         INX
  215 F54F:DF25            [ 4]         STX    WHSTACK      ; SAVE STACK POINTER.
  216 F551:2002 (F555)     [ 3]         BRA    RENDWH5      ; GO TO INTERPRET LOOP.
  217 F553:31              [ 3] RENDWH3:        INS                 ; REMOVE POINTER TO STATEMENT AFTER "ENDWH"
  218 F554:31              [ 3]         INS                 ; FROM STACK.
  219 F555:39              [ 5] RENDWH5:        RTS                 ; GO EXECUTE LINES TILL "ENDWH".
  220                           *
  221                           *
  222      F556                 RON:    EQU    *
  223 F556:BDFB 12         [ 6]         JSR    DONEXP       ; GO EVALUATE THE EXPRESSION.
  224 F559:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES AFTER EXPRESSION.
  225 F55C:18A6 00         [ 5]         LDAA   0,Y          ; GET EITHER "GOTO" OR "GOSUB" TOKEN.
  226 F55F:36              [ 3]         PSHA                ; SAVE IT.
  227 F560:1808            [ 4]         INY                 ; POINT TO NEXT TOKEN.
  228 F562:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES.
  229 F565:DE1F            [ 4]         LDX    NUMSTACK     ; POINT TO THE OPERAND STACK.
  230 F567:EC00            [ 5]         LDD    0,X          ; GET EXPRESSION VALUE.
  231 F569:2A07 (F572)     [ 3]         BPL    RON1         ; IS IT NEGATIVE?
  232 F56B:2605 (F572)     [ 3]         BNE    RON1         ; OR ZERO?
  233 F56D:8620            [ 2] RON5:   LDAA   #ONARGERR    ; YES. REPORT ERROR.
  234 F56F:7EEA EF         [ 3]         JMP    RPTRERR
  235 F572:EC00            [ 5] RON1:   LDD    0,X          ; GET THE EXPRESSION VALUE.
  236 F574:8300 01         [ 4]         SUBD   #1           ; SUBTRACT 1. HAVE WE FOUND THE LINE NUMBER?
  237 F577:2717 (F590)     [ 3]         BEQ    RON4         ; YES. GO DO "GOTO" OR "GOSUB".
  238 F579:ED00            [ 5]         STD    0,X          ; NO. SAVE REMAINDER.
  239 F57B:C603            [ 2]         LDAB   #3           ; POINT PAST THE LINE NUMBER VALUE.
  240 F57D:183A            [ 4]         ABY
  241 F57F:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES PAST THE LINE NUMBER.
  242 F582:18A6 00         [ 5]         LDAA   0,Y          ; GET NEXT TOKEN.
  243 F585:817D            [ 2]         CMPA   #EOLTOK      ; HAVE WE HIT THE END OF THE LINE?
  244 F587:27E4 (F56D)     [ 3]         BEQ    RON5         ; YES. ERROR.
  245 F589:1808            [ 4] RON3:   INY                 ; NO. MUST BE A COMMA. BYPASS IT.
  246 F58B:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES AFTER THE COMMA.
  247 F58E:20E2 (F572)     [ 3]         BRA    RON1         ; GO SEE IF THE NEXT LINE NUMBER IS THE ONE.
  248 F590:BDFB B9         [ 6] RON4:   JSR    PULNUM       ; GET RID OF ARGUMENT.
  249 F593:32              [ 4]         PULA                ; GET "GO" TOKEN.
  250 F594:8112            [ 2]         CMPA   #GOTOTOK     ; IS IT A "GOTO" TOKEN?
  251 F596:2603 (F59B)     [ 3]         BNE    RON6         ; NO. MUST BE A "GOSUB"
  252 F598:7EF4 36         [ 3]         JMP    RGOTO        ; GO DO A "GOTO".
  253 F59B:183C            [ 5] RON6:   PSHY                ; SAVE THE POINTER TO THE LINE NUMBER.
  254 F59D:C603            [ 2] RON8:   LDAB   #3           ; POINT PAST THE LINE NUMBER.
  255 F59F:183A            [ 4]         ABY
  256 F5A1:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES AFTER LINE NUMBER.
  257 F5A4:18A6 00         [ 5]         LDAA   0,Y          ; GET NEXT TERMINATOR CHARACTER.
  258 F5A7:817D            [ 2]         CMPA   #EOLTOK      ; HIT THE END OF THE LINE YET?
  259 F5A9:270B (F5B6)     [ 3]         BEQ    RON7         ; YES. GO DO THE GOSUB.
  260 F5AB:817A            [ 2]         CMPA   #MEOLTOK     ; NO. HIT THE LOGICAL END OF THE LINE YET?
  261 F5AD:2707 (F5B6)     [ 3]         BEQ    RON7         ; YES. GO DO THE GOSUB.
  262 F5AF:1808            [ 4]         INY                 ; NO. MUST BE A COMMA.
  263 F5B1:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES AFTER THE COMMA.
  264 F5B4:20E7 (F59D)     [ 3]         BRA    RON8         ; GO FIND THE END OF THE LINE.
  265 F5B6:7EF4 8B         [ 3] RON7:   JMP    RGOSUB2      ; GO DO A "GOSUB".
  266                           *
  267                           *
  268      F5B9                 RPOKE:  EQU    *
  269 F5B9:1808            [ 4]         INY                 ; PASS UP THE OPEN PAREN.
  270 F5BB:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; PASS UP ANY SPACES.
  271 F5BE:BDFB 12         [ 6]         JSR    DONEXP       ; GO EVALUATE THE ADDRESS EXPRESSION.
  272 F5C1:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP ANY SPACES.
  273 F5C4:1808            [ 4]         INY                 ; SKIP THE COMMA.
  274 F5C6:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP ANY SPACES.
  275 F5C9:BDFB 12         [ 6]         JSR    DONEXP       ; GET THE VALUE TO PUT INTO MEMORY.
  276 F5CC:1808            [ 4]         INY                 ; PASS UP THE CLOSING PAREN.
  277 F5CE:BDFB B9         [ 6]         JSR    PULNUM       ; GET THE MEMORY VALUE.
  278 F5D1:8F              [ 3]         XGDX                ; SAVE IT.
  279 F5D2:BDFB B9         [ 6]         JSR    PULNUM       ; GET THE ADDRESS.
  280 F5D5:8F              [ 3]         XGDX                ; PUT ADDRESS INTO X & MEM VALUE INTO D.
  281 F5D6:E700            [ 4]         STAB   0,X          ; PUT VALUE INTO MEMORY.
  282 F5D8:39              [ 5]         RTS                 ; BACK TO THE INTERPRET LOOP.
  283                           *
  284                           *
  285 F5D9:C600            [ 2] RPORTA: LDAB   #PORTAIO
  286 F5DB:DE61            [ 4] RPORTA1:        LDX    IOBaseV     ;  GET ADDRESS OF PORTA I/O REGISTER.
  287 F5DD:3A              [ 3]         ABX
  288 F5DE:3C              [ 4]         PSHX                ; SAVE POINTER TO VARIABLE.
  289 F5DF:1808            [ 4]         INY                 ; PUT IP PAST THE "=" TOKEN.
  290 F5E1:BDFB 12         [ 6]         JSR    DONEXP       ; EVALUATE THE EXPRESSION.
  291 F5E4:BDFB B9         [ 6]         JSR    PULNUM       ; GET VALUE INTO D.
  292 F5E7:4D              [ 2]         TSTA                ; IS THE VALUE <0 AND >255?
  293 F5E8:2705 (F5EF)     [ 3]         BEQ    RPORTA2      ; NO. GO PUT THE VALUE IN THE PORT.
  294 F5EA:862E            [ 2]         LDAA   #PRTASERR    ; YES. ERROR.
  295 F5EC:7EEA EF         [ 3]         JMP    RPTRERR      ; REPORT THE ERROR.
  296 F5EF:38              [ 5] RPORTA2:        PULX                ; POINT TO THE DICTIONARY ENTRY.
  297 F5F0:E700            [ 4]         STAB   0,X          ; STORE VALUE.
  298 F5F2:39              [ 5]         RTS                 ; BACK TO MAIN INTERPRET LOOP.
  299                           
  300                           *
  301                           *
  302 F5F3:C604            [ 2] RPORTB: LDAB   #PORTBIO     ; GET ADDRESS OF PORTB I/O REGISTER.
  303 F5F5:20E4 (F5DB)     [ 3]         BRA    RPORTA1      ; GO DO AN ASIGNMENT.
  304                           *
  305                           *
  306 F5F7:C603            [ 2] RPORTC: LDAB   #PORTCIO     ; GET ADDRESS OF PORTC I/O REGISTER.
  307 F5F9:20E0 (F5DB)     [ 3]         BRA    RPORTA1      ; GO DO AN ASIGNMENT.
  308                           *
  309                           *
  310 F5FB:C608            [ 2] RPORTD: LDAB   #PORTDIO     ; GET ADDRESS OF PORTD I/O REGISTER.
  311 F5FD:20DC (F5DB)     [ 3]         BRA    RPORTA1      ; GO DO AN ASIGNMENT.
  312                           *
  313                           *
*** END   INCLUDE FILE: RUNTIME1.ASM *** (RESUMING FILE: BASIC11.ASM)
   17                           #Include  'RUNTIME2.Asm'
*** BEGIN INCLUDE FILE: RUNTIME2.ASM ***
    1                           *         title    RUNTIME2
    2                           *         page
    3                           *
    4                           *
    5      F5FF                 RTRON:  EQU    *
    6 F5FF:86FF            [ 2]         LDAA   #$FF         ; SET FLAG TO TURN TRACE MODE ON.
    7 F601:971B            [ 3]         STAA   TRFLAG       ; PUT IT IN THE FLAG BYTE.
    8 F603:39              [ 5] RTRON1: RTS                 ; BACK TO THE INTERPRET LOOP.
    9                           *
   10                           *
   11      F604                 RTROFF: EQU    *
   12 F604:7F00 1B         [ 6]         CLR    TRFLAG       ; TURN THE TRACE MODE OFF.
   13 F607:39              [ 5]         RTS                 ; BACK TO THE INTERPRET LOOP.
   14                           *
   15                           *
   16      F608                 RSLEEP: EQU     *
   17 F608:0F              [ 2]         SEI             ; DON'T ALLOW AN INTERRUPT TO BRING US OUT OF THE SLEEP MODE.
   18 F609:07              [ 2]         TPA             ; GET THE CONDITION CODE REGISTER.
   19 F60A:847F            [ 2]         ANDA    #$7F    ; CLEAR THE STOP BIT
   20 F60C:06              [ 2]         TAP             ; TRANSFER THE RESULT BACK TO THE CCR.
   21 F60D:CF              [ 2]         STOP            ; HALT THE CPU.
   22 F60E:07              [ 2]         TPA             ; ON EXIT FROM THE STOP MODE, GET THE CCR.
   23 F60F:8A80            [ 2]         ORAA    #$80    ; DISABLE THE STOP INSTRUCTION.
   24 F611:06              [ 2]         TAP             ; TRANSFER THE RESULT BACK TO THE CCR.
   25 F612:0E              [ 2]         CLI             ; ALLOW INTERRUPTS.
   26 F613:39              [ 5]         RTS             ; RETURN TO WHAT WE WERE DOING.
   27                           *
   28                           *
   29      F614                 RPRINT: EQU    *
   30 F614:BDF8 52         [ 6]         JSR    CHCKDEV      ; GO CHECK FOR ALTERNATE OUTPUT DEVICE.
   31 F617:18A6 00         [ 5]         LDAA   0,Y          ; GET FIRST TOKEN.
   32 F61A:817D            [ 2]         CMPA   #EOLTOK      ; IS IT AN EOL TOKEN?
   33 F61C:2704 (F622)     [ 3]         BEQ    RPRINT1      ; YES. JUST PRINT A CR/LF.
   34 F61E:817A            [ 2]         CMPA   #MEOLTOK     ; IS IT A MID EOL TOKEN?
   35 F620:2607 (F629)     [ 3]         BNE    RPRINT2      ; NO. GO PRINT A STRING OR NUMBER.
   36 F622:BDE1 10         [ 6] RPRINT1:        JSR    NL           ; YES. JUST PRINT A CR/LF.
   37 F625:7F00 37         [ 6]         CLR    DEVNUM       ; GO BACK TO DEVICE #0.
   38 F628:39              [ 5]         RTS                 ; BACK TO MAIN INTERPRET LOOP.
   39 F629:81A2            [ 2] RPRINT2:        CMPA   #SCONTOK     ; IS IT A STRING CONSTANT?
   40 F62B:2616 (F643)     [ 3]         BNE    RPRINT3      ; NO. GO CHECK FOR A "PRINT FUNCTION".
   41 F62D:183C            [ 5]         PSHY
   42 F62F:C602            [ 2]         LDAB   #2           ; COMPENSATE FOR CONSTANT & LENGTH BYTE.
   43 F631:18EB 01         [ 5]         ADDB   1,Y          ; ADD IN LENGTH BYTE.
   44 F634:183A            [ 4]         ABY                 ; POINT BEYOND PROMPT.
   45 F636:38              [ 5]         PULX                ; GET POINTER INTO X.
   46 F637:08              [ 3]         INX                 ; POINT TO LENGTH BYTE.
   47 F638:E600            [ 4]         LDAB   0,X          ; GET IT.
   48 F63A:C002            [ 2]         SUBB   #2           ; SUBTRACT OUT THE DELIMETER COUNT.
   49 F63C:08              [ 3]         INX                 ; POINT TO STRING.
   50 F63D:08              [ 3]         INX
   51 F63E:BDF8 D0         [ 6]         JSR    OUTSTR       ; GO PRINT THE STRING.
   52 F641:2039 (F67C)     [ 3]         BRA    RPRINT4      ; GO DO NEXT EXPRESSION.
   53 F643:8136            [ 2] RPRINT3:        CMPA   #FUNCTFLG    ; IS IT A FUNCTION?
   54 F645:261E (F665)     [ 3]         BNE    RPRINT10     ; NO. GO EVALUATE A NUMERIC EXPRESSION.
   55 F647:18A6 01         [ 5]         LDAA   1,Y          ; GET THE FUNCTION TYPE.
   56 F64A:8107            [ 2]         CMPA   #TABTOK      ; IS IT A TAB?
   57 F64C:2605 (F653)     [ 3]         BNE    RPRINT11     ; NO GO CHECK FOR "CHR$".
   58 F64E:BDF6 B9         [ 6]         JSR    RTAB         ; GO DO TAB.
   59 F651:2029 (F67C)     [ 3]         BRA    RPRINT4      ; GO SEE IF THERE'S MORE TO PRINT.
   60 F653:8102            [ 2] RPRINT11:       CMPA   #CHRTOK      ; IS IT THE CHR$ FUNCTION.
   61 F655:2605 (F65C)     [ 3]         BNE    RPRINT12     ; NO. GO CHECK FOR HEX().
   62 F657:BDF6 CE         [ 6]         JSR    RCHRS        ; YES. GO DO CHR$.
   63 F65A:2020 (F67C)     [ 3]         BRA    RPRINT4      ; GO SEE IF THERE'S MORE TO PRINT.
   64 F65C:810B            [ 2] RPRINT12:       CMPA   #HEXTOK      ; IS IT THE HEX() FUNCTION?
   65 F65E:2605 (F665)     [ 3]         BNE    RPRINT10     ; NO. GO DO A NUMERIC EXPRESSION.
   66 F660:BDF6 E2         [ 6]         JSR    RHEX         ; YES. GO PRINT THE NUMBER AS HEX.
   67 F663:2017 (F67C)     [ 3]         BRA    RPRINT4      ; GO SEE IF THERE'S MORE TO PRINT.
   68 F665:8112            [ 2] RPRINT10:       CMPA   #HEX2TOK     ; IS IT THE HEX2() FUNCTION?
   69 F667:2605 (F66E)     [ 3]         BNE    RPRINT14     ; NO. GO DO A NUMERIC EXPRESSION.
   70 F669:BDF6 DA         [ 6]         JSR    RHEX2        ; YES GO PRINT A NUMBER >=255 AS 2 HEX BYTES.
   71 F66C:200E (F67C)     [ 3]         BRA    RPRINT4      ; GO SEE IF THERE'S MORE TO PRINT.
   72 F66E:BDFB 12         [ 6] RPRINT14:       JSR    DONEXP       ; GO DO A NUMERIC EXPRESSION.
   73 F671:BDFB B9         [ 6]         JSR    PULNUM       ; GET THE NUMBER OFF THE NUMERIC STACK.
   74 F674:BDEB 1A         [ 6]         JSR    OUTDECI      ; PRINT IT.
   75 F677:8620            [ 2]         LDAA   #SPC          ; PUT A TRAILING SPACE AFTER ALL NUMBERS.
   76 F679:BDFE CD         [ 6]         JSR    OUTBYTE      ; PRINT IT.
   77 F67C:BDF1 CA         [ 6] RPRINT4:        JSR    RSKIPSPC     ; SKIP SPACES.
   78 F67F:18A6 00         [ 5]         LDAA   0,Y          ; GET SEPERATOR CHARACTER.
   79 F682:817C            [ 2]         CMPA   #COMMATOK    ; IS IT A COMMA?
   80 F684:2708 (F68E)     [ 3]         BEQ    RPRINT5      ; NO.
   81 F686:817B            [ 2]         CMPA   #SEMITOK     ; IS IT A SEMICOLIN?
   82 F688:2628 (F6B2)     [ 3]         BNE    RPRINT6      ; NO. MUST BE AN EOLTOK.
   83 F68A:1808            [ 4]         INY                 ; DO NOTHING BUT BUMP THE IP.
   84 F68C:2013 (F6A1)     [ 3]         BRA    RPRINT7      ; GO CHECK FOR EOL AFTER COMMA OR SEMICOLIN.
   85 F68E:1808            [ 4] RPRINT5:        INY                 ; BUMP IP PAST THE COMMATOK.
   86 F690:D61E            [ 3]         LDAB   PRINTPOS     ; YES. "TAB" TO NEXT PRINT FIELD.
   87 F692:C407            [ 2]         ANDB   #$07         ; MASK OFF ALL BUT THE FIELD WIDTH.
   88 F694:50              [ 2]         NEGB                ; MAKE IT NEGATIVE.
   89 F695:CB08            [ 2]         ADDB   #8           ; ADD IN THE FIELD WIDTH. ARE WE ON A FIELD BOUND?
   90 F697:2708 (F6A1)     [ 3]         BEQ    RPRINT7      ; YES. GO CHECK FOR AN EOL.
   91 F699:8620            [ 2]         LDAA   #SPC          ; NO. GET A SPACE & PRINT TILL WE GET THERE.
   92 F69B:BDFE CD         [ 6] RPRINT8:        JSR    OUTBYTE      ; PRINT A SPACE.
   93 F69E:5A              [ 2]         DECB                ; DECREMENT THE COUNT. ARE WE DONE?
   94 F69F:26FA (F69B)     [ 3]         BNE    RPRINT8      ; NO. KEEP GOING.
   95 F6A1:BDF1 CA         [ 6] RPRINT7:        JSR    RSKIPSPC     ; SKIP ANY SPACES.
   96 F6A4:18A6 00         [ 5]         LDAA   0,Y          ; GET THE NEXT TOKEN IN THE LINE.
   97 F6A7:817D            [ 2]         CMPA   #EOLTOK      ; IS IT AN EOL TOKEN?
   98 F6A9:270A (F6B5)     [ 3]         BEQ    RPRINT9      ; YES. DONT DO A CR/LF AFTER A COMMA OR SEMI.
   99 F6AB:817A            [ 2]         CMPA   #MEOLTOK     ; NO. IS IT A MID EOL?
  100 F6AD:2706 (F6B5)     [ 3]         BEQ    RPRINT9      ; SAME AS BEFORE.
  101 F6AF:7EF6 29         [ 3]         JMP    RPRINT2      ; IF NEITHER, GO PRINT THE NEXT EXPRESSION.
  102 F6B2:BDE1 10         [ 6] RPRINT6:        JSR    NL           ; DO A CR/LF IF EOL OR MIDEOL FOLLOWS EXPRESSION.
  103 F6B5:7F00 37         [ 6] RPRINT9:        CLR    DEVNUM       ; GO BACK TO DEVICE #0.
  104 F6B8:39              [ 5]         RTS                 ; GO DO NEXT LINE.
  105                           *
  106                           *
  107      F6B9                 RTAB:   EQU    *
  108 F6B9:8D43 (F6FE)     [ 6]         BSR    PFUNCOM      ; GO GET ARG. & CHECK MAGNITUDE. IS ARG. OK?
  109 F6BB:2705 (F6C2)     [ 3]         BEQ    RTAB1        ; YES. GO DO TAB.
  110 F6BD:862A            [ 2]         LDAA   #TABARGER    ; NO. ERROR.
  111 F6BF:7EEA EF         [ 3] RTAB3:  JMP    RPTRERR      ; REPORT ERROR.
  112 F6C2:D11E            [ 3] RTAB1:  CMPB   PRINTPOS     ; ARE WE ALREADY PAST THE "TAB" POSITION?
  113 F6C4:2307 (F6CD)     [ 3]         BLS    RTAB2        ; YES. DONE.
  114 F6C6:8620            [ 2]         LDAA   #SPC          ; GET A SPACE.
  115 F6C8:BDFE CD         [ 6]         JSR    OUTBYTE      ; PRINT IT.
  116 F6CB:20F5 (F6C2)     [ 3]         BRA    RTAB1
  117 F6CD:39              [ 5] RTAB2:  RTS                 ; RETURN.
  118                           *
  119                           *
  120      F6CE                 RCHRS:  EQU    *
  121 F6CE:8D2E (F6FE)     [ 6]         BSR    PFUNCOM      ; GO GET ARG. & CHECK MAGNITUDE. IS ARG. OK?
  122 F6D0:2704 (F6D6)     [ 3]         BEQ    RCHRS1       ; YES. GO DO TAB.
  123 F6D2:862B            [ 2]         LDAA   #CHRARGER    ; NO. ERROR.
  124 F6D4:20E9 (F6BF)     [ 3]         BRA    RTAB3        ; REPORT ERROR.
  125 F6D6:17              [ 2] RCHRS1: TBA                 ; PUT BYTE INTO A
  126 F6D7:7EFE CD         [ 3]         JMP    OUTBYTE      ; PRINT THE BYTE & RETURN.
  127                           *
  128                           *
  129      F6DA                 RHEX2:  EQU    *
  130 F6DA:8D22 (F6FE)     [ 6]         BSR    PFUNCOM      ; GO GET ARG. & CHECK MAGNITUDE. IS ARG. OK?
  131 F6DC:2708 (F6E6)     [ 3]         BEQ    RHEX1        ; YES. GO PRINT 2 HEX CHARACTERS & RETURN.
  132 F6DE:8632            [ 2]         LDAA   #HEX2AERR    ; NO. ARG. MUST BE >=0 & <=255.
  133 F6E0:20DD (F6BF)     [ 3]         BRA    RTAB3        ; GO REPORT ERROR.
  134                           *
  135                           *
  136      F6E2                 RHEX:   EQU    *
  137 F6E2:8D1A (F6FE)     [ 6]         BSR    PFUNCOM      ; GO DO COMMON CODE FOR PRINT FUNCTIONS
  138 F6E4:8D01 (F6E7)     [ 6]         BSR    PRNT2HEX     ; GO PRINT 2 HEX CHARACTERS.
  139 F6E6:17              [ 2] RHEX1:  TBA                 ; PUT LOWER BYTE IN A.
  140                           *                       ; FALL THRU TO PRINT 2 HEX CHARACTERS & RETURN.
  141                           *
  142                           *
  143      F6E7                 PRNT2HEX:       EQU    *
  144 F6E7:36              [ 3]         PSHA                ; SAVE THE CHARACTER.
  145 F6E8:8D03 (F6ED)     [ 6]         BSR    PRNTHXL      ; PRINT THE LEFT HEX NYBBLE.
  146 F6EA:32              [ 4]         PULA                ; GET BYTE BACK.
  147 F6EB:2004 (F6F1)     [ 3]         BRA    PRNTHXR      ; PRINT RIGHT NYBBLE & RETURN.
  148                           *
  149                           *
  150 F6ED:44              [ 2] PRNTHXL:        LSRA                ; GET UPPER NYBBLE INTO LOWER ONE.
  151 F6EE:44              [ 2]         LSRA
  152 F6EF:44              [ 2]         LSRA
  153 F6F0:44              [ 2]         LSRA
  154 F6F1:840F            [ 2] PRNTHXR:        ANDA   #$0F         ; MASK OFF UPPER NYBBLE.
  155 F6F3:8B30            [ 2]         ADDA   #$30         ; MAKE IT A HEX NUMBER.
  156 F6F5:8139            [ 2]         CMPA   #$39         ; IS IT?
  157 F6F7:2302 (F6FB)     [ 3]         BLS    PRNTHXR1     ; YES. PRINT IT.
  158 F6F9:8B07            [ 2]         ADDA   #$07         ; NO. MAKE IT A HEX LETTER.
  159 F6FB:7EFE CD         [ 3] PRNTHXR1:       JMP    OUTBYTE      ; PRINT IT & RETURN.
  160                           *
  161                           *
  162      F6FE                 PFUNCOM:        EQU    *
  163 F6FE:C603            [ 2]         LDAB   #3           ; POINT PAST FUNCTION FLAG, FUNCTION TOKEN, &
  164 F700:183A            [ 4]         ABY                 ; OPEN PAREN.
  165 F702:BDFB 12         [ 6]         JSR    DONEXP       ; GO GET POSITION TO TAB TO.
  166 F705:1808            [ 4]         INY                 ; BUMP IP PAST CLOSING PAREN.
  167 F707:BDFB B9         [ 6]         JSR    PULNUM       ; GET OPERAND OFF STACK.
  168 F70A:4D              [ 2]         TSTA                ; CHECK THAT OPERAND IS >0 & <=255 FOR FUNCTIONS
  169                           *                       ; THAT REQUIRE IT.
  170 F70B:39              [ 5]         RTS             ; RETURN.
  171                           *
  172                           *
  173                           *
  174      F70C                 RDIM:   EQU    *
  175 F70C:18A6 00         [ 5]         LDAA   0,Y          ; GET VARIABLE FLAG/TYPE.
  176 F70F:8510            [ 2]         BITA   #$10         ; IS IT A SUBSCRIPTED VARIABLE?
  177 F711:2605 (F718)     [ 3]         BNE    RDIM1        ; YES. GO DIMENSION IT.
  178 F713:8621            [ 2]         LDAA   #NOSUBERR    ; NO. GET ERROR.
  179 F715:7EEA EF         [ 3] RDIM3:  JMP    RPTRERR      ; GO REPORT THE ERROR.
  180 F718:18EC 01         [ 6] RDIM1:  LDD    1,Y          ; GET THE OFFSET INTO THE DICTIONARY.
  181 F71B:D308            [ 5]         ADDD   VARBEGIN     ; ADD IN THE START OF THE DICTIONARY.
  182 F71D:8F              [ 3]         XGDX                ; PUT THE ADDRESS INTO X.
  183 F71E:EC03            [ 5]         LDD    3,X          ; GET THE POINTER TO THE STORAGE. BEEN DIMENSIONED?
  184 F720:2704 (F726)     [ 3]         BEQ    RDIM2        ; NO. GO DIMENSION IT.
  185 F722:8622            [ 2]         LDAA   #REDIMERR    ; YES. ERROR.
  186 F724:20EF (F715)     [ 3]         BRA    RDIM3
  187 F726:3C              [ 4] RDIM2:  PSHX                ; SAVE THE POINTER TO THE DICTIONARY.
  188 F727:C604            [ 2]         LDAB   #4           ; POINT TO 1ST TOKEN IN EXPRESSION.
  189 F729:183A            [ 4]         ABY
  190 F72B:BDFB 12         [ 6]         JSR    DONEXP       ; EVALUATE THE SUBSCRIPT.
  191 F72E:1808            [ 4]         INY                 ; PASS UP THE CLOSING PAREN.
  192 F730:38              [ 5]         PULX                ; RESTORE POINTER TO DICTIONARY.
  193 F731:DC2D            [ 4]         LDD    STRASTG      ; GET THE DYNAMIC MEMORY POOL POINTER.
  194 F733:ED03            [ 5]         STD    3,X          ; PUT THE POINTER IN THE DICTIONARY ENTRY.
  195 F735:C300 02         [ 4]         ADDD   #2           ; UP THE POINTER.
  196 F738:DD2D            [ 4]         STD    STRASTG      ; SAVE NEW POINTER FOR NOW.
  197 F73A:BDFB B9         [ 6]         JSR    PULNUM       ; GET SUBSCRIPT OFF OF NUMERIC STACK.
  198 F73D:2A04 (F743)     [ 3]         BPL    RDIM8        ; ONLY POSITIVE SUBSCRIPTS ALLOWED.
  199 F73F:8627            [ 2]         LDAA   #NEGSUBER    ; NEGATIVE NUMBER.
  200 F741:2018 (F75B)     [ 3]         BRA    RDIM9        ; REPORT ERROR.
  201 F743:3C              [ 4] RDIM8:  PSHX
  202 F744:EE03            [ 5]         LDX    3,X          ; GET POINTER TO STORAGE.
  203 F746:ED00            [ 5]         STD    0,X          ; PUT MAX SUBSCRIPT IN POOL STORAGE.
  204 F748:C300 01         [ 4]         ADDD   #1           ; COMPENSATE FOR "0" SUBSCRIPT.
  205 F74B:38              [ 5]         PULX                ; RESTORE POINTER TO DICTIONARY ENTRY.
  206 F74C:05              [ 3]         LSLD                ; MULT. BY 2 (2 BYTES/INTEGER).
  207 F74D:D32D            [ 5]         ADDD   STRASTG      ; ADD IN CURRENT POINTER TO POOL.
  208 F74F:1A93 2D         [ 6]         CPD    STRASTG      ; WAS THE SUBSCRIPT SO BIG WE WRAPPED AROUND?
  209 F752:2305 (F759)     [ 3]         BLS    RDIM4        ; YES. ERROR.
  210 F754:1A93 10         [ 6]         CPD    VARMEND      ; DO WE HAVE ENOUGH MEMORY?
  211 F757:2305 (F75E)     [ 3]         BLS    RDIM5        ; YES.
  212 F759:8609            [ 2] RDIM4:  LDAA   #OMEMERR     ; NO. ERROR.
  213 F75B:7EEA EF         [ 3] RDIM9:  JMP    RPTRERR      ; GO REPORT THE ERROR.
  214 F75E:DD2D            [ 4] RDIM5:  STD    STRASTG      ; SAVE POINTER.
  215 F760:EE03            [ 5]         LDX    3,X          ; POINT TO START OF STORAGE.
  216 F762:08              [ 3]         INX
  217 F763:08              [ 3]         INX                 ; POINT PAST THE SUBSCRIPT LIMIT.
  218 F764:6F00            [ 6] RDIM6:  CLR    0,X          ; CLEAR THE STORAGE.
  219 F766:08              [ 3]         INX                 ; POINT TO THE NEXT LOCATION.
  220 F767:9C2D            [ 5]         CPX    STRASTG      ; ARE WE DONE?
  221 F769:26F9 (F764)     [ 3]         BNE    RDIM6        ; NO. KEEP GOING.
  222 F76B:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES.
  223 F76E:18A6 00         [ 5]         LDAA   0,Y          ; GET THE NEXT CHARACTER.
  224 F771:817D            [ 2]         CMPA   #EOLTOK      ; ARE WE AT THE END OF THE LINE.
  225 F773:2707 (F77C)     [ 3]         BEQ    RDIM7        ; YES.
  226 F775:1808            [ 4]         INY                 ; BUMP IP PAST THE COMMA.
  227 F777:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES.
  228 F77A:2090 (F70C)     [ 3]         BRA    RDIM         ; DO DIMENSION THE NEXT VARIABLE.
  229 F77C:39              [ 5] RDIM7:  RTS                 ; BACK TO MAIN INTERPRET LOOP.
  230                           *
  231                           *
  232                           *
*** END   INCLUDE FILE: RUNTIME2.ASM *** (RESUMING FILE: BASIC11.ASM)
   18                           #Include  'RUNTIME3.Asm'
*** BEGIN INCLUDE FILE: RUNTIME3.ASM ***
    1                           *         title    RUNTIME3.TXT
    2                           *         page
    3                           *
    4                           *
    5      F77D                 RFOR:   EQU    *
    6 F77D:DC23            [ 4]         LDD    FORSTACK     ; GET FOR STACK POINTER.
    7 F77F:8300 0A         [ 4]         SUBD   #10          ; ALLOCATE NEW FOR-NEXT DESCRIPTOR BLOCK.
    8 F782:1A93 55         [ 6]         CPD    EFORSTK      ; HAVE WE RUN OUT OF FOR-NEXT STACK SPACE?
    9 F785:2405 (F78C)     [ 3]         BHS    RFOR1        ; NO. CONTINUE.
   10 F787:8623            [ 2]         LDAA   #FORNXERR    ; YES. ERROR.
   11 F789:7EEA EF         [ 3]         JMP    RPTRERR      ; REPORT ERROR.
   12 F78C:DD23            [ 4] RFOR1:  STD    FORSTACK     ; SAVE NEW STACK POINTER.
   13 F78E:183C            [ 5]         PSHY                ; SAVE IP ON STACK.
   14 F790:BDF3 FF         [ 6]         JSR    RVARPTR      ; GET POINTER TO ASIGNMENT VARIABLE.
   15 F793:1838            [ 6]         PULY                ; RESTORE IP.
   16 F795:DE23            [ 4]         LDX    FORSTACK     ; GET FOR STACK POINTER.
   17 F797:ED00            [ 5]         STD    0,X          ; PUT POINTER TO CONTROL VARIABLE IN STACK.
   18 F799:DC29            [ 4]         LDD    CURLINE      ; GET CURRENT LINE NUMBER.
   19 F79B:ED08            [ 5]         STD    8,X          ; SAVE CURRENT LINE NUMBER IN STACK.
   20 F79D:BDF3 EC         [ 6]         JSR    RLET         ; GO DO ASIGNMENT PART OF FOR.
   21 F7A0:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES.
   22 F7A3:1808            [ 4]         INY                 ; SKIP PAST "TO" TOKEN.
   23 F7A5:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES.
   24 F7A8:BDFB 12         [ 6]         JSR    DONEXP       ; CALCULATE THE TERMINATING LOOP VALUE.
   25 F7AB:BDFB B9         [ 6]         JSR    PULNUM       ; GET NUMBER OFF OF THE STACK.
   26 F7AE:DE23            [ 4]         LDX    FORSTACK     ; GET STACK POINTER.
   27 F7B0:ED04            [ 5]         STD    4,X          ; PUT VALUE IN STACK BLOCK.
   28 F7B2:CC00 01         [ 3]         LDD    #1           ; ASSUME A "STEP" VALUE OF 1.
   29 F7B5:ED02            [ 5] RFOR3:  STD    2,X          ; PUT IT IN THE STACK.
   30 F7B7:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES.
   31 F7BA:18A6 00         [ 5]         LDAA   0,Y          ; GET NEXT TOKEN.
   32 F7BD:813A            [ 2]         CMPA   #STEPTOK     ; IS THE STEP CLAUSE PRESENT?
   33 F7BF:2704 (F7C5)     [ 3]         BEQ    RFOR2        ; YES. GO GET THE "STEP" VALUE.
   34 F7C1:1AEF 06         [ 6]         STY    6,X          ; PUT TERMINATING CHARACTER OF "FOR" STATEMENT ON.
   35 F7C4:39              [ 5]         RTS                 ; EXECUTE NEXT STATEMENT.
   36 F7C5:1808            [ 4] RFOR2:  INY                 ; SKIP PAST THE "STEP" TOKEN.
   37 F7C7:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES.
   38 F7CA:BDFB 12         [ 6]         JSR    DONEXP       ; GO CALCULATE THE "STEP" VALUE.
   39 F7CD:BDFB B9         [ 6]         JSR    PULNUM       ; GET VALUE OFF OPERAND STACK.
   40 F7D0:DE23            [ 4]         LDX    FORSTACK     ; GET POINTER TO FOR STACK.
   41 F7D2:20E1 (F7B5)     [ 3]         BRA    RFOR3        ; GO PUT VALUE IN STACK.
   42                           *
   43                           *
   44      F7D4                 RNEXT:  EQU    *
   45 F7D4:BDF3 FF         [ 6]         JSR    RVARPTR      ; GET POINTER TO LOOP INDEX VARIABLE.
   46 F7D7:DE23            [ 4]         LDX    FORSTACK     ; GET "FOR" STACK POINTER.
   47 F7D9:1AA3 00         [ 7]         CPD    0,X          ; IS THE LOOP VARIABLE THE SAME?
   48 F7DC:2705 (F7E3)     [ 3]         BEQ    RNEXT1       ; YES. CONTINUE.
   49 F7DE:8624            [ 2]         LDAA   #MFRNXERR    ; NO. ERROR.
   50 F7E0:7EEA EF         [ 3]         JMP    RPTRERR      ; GO REPORT IT.
   51 F7E3:183C            [ 5] RNEXT1: PSHY                ; SAVE IP.
   52 F7E5:1AEE 00         [ 6]         LDY    0,X          ; GET POINTER TO CONTROL VARIABLE.
   53 F7E8:18EC 00         [ 6]         LDD    0,Y          ; GET CONTROL VARIABLE VALUE.
   54 F7EB:E302            [ 6]         ADDD   2,X          ; ADD THE STEP VALUE TO IT.
   55 F7ED:18ED 00         [ 6]         STD    0,Y          ; SAVE THE RESULT.
   56 F7F0:6D02            [ 6]         TST    2,X          ; IS THE STEP VALUE NEGATIVE?
   57 F7F2:2B11 (F805)     [ 3]         BMI    RNEXT2       ; YES. GO DO TEST.
   58 F7F4:1AA3 04         [ 7]         CPD    4,X          ; NO. ARE WE DONE?
   59 F7F7:2F11 (F80A)     [ 3]         BLE    RNEXT3       ; NO. GO DO THE LOOP AGAIN.
   60 F7F9:1838            [ 6] RNEXT4: PULY                ; RESTORE THE CURRENT IP.
   61 F7FB:8F              [ 3]         XGDX                ; PUT "FOR - NEXT" STACK POINTER IN D.
   62 F7FC:C300 0A         [ 4]         ADDD   #10          ; REMOVE DESCRIPTOR FROM STACK.
   63 F7FF:DD23            [ 4]         STD    FORSTACK     ; SAVE NEW STACK VALUE.
   64 F801:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES AFTER CONTROL VARIABLE.
   65 F804:39              [ 5]         RTS                 ; DO THE STATEMENT AFTER THE NEXT.
   66 F805:1AA3 04         [ 7] RNEXT2: CPD    4,X          ; ARE WE DONE?
   67 F808:2DEF (F7F9)     [ 3]         BLT    RNEXT4       ; YES. CONTINUE.
   68 F80A:1838            [ 6] RNEXT3: PULY                ; CLEAN Y OFF OF STACK.
   69 F80C:1AEE 06         [ 6]         LDY    6,X          ; GET NEW IP.
   70 F80F:EC08            [ 5]         LDD    8,X          ; GET LINE NUMBER OF FOR STATEMENT.
   71 F811:DD29            [ 4]         STD    CURLINE      ; MAKE IT THE CURRENT LINE.
   72 F813:39              [ 5]         RTS
   73                           *
   74                           *
   75                           *
   76                           *
   77      F814                 RINPUT: EQU    *
   78 F814:8D3C (F852)     [ 6]         BSR    CHCKDEV      ; CHECK FOR ALTERNATE INPUT DEVICE.
   79 F816:18A6 00         [ 5]         LDAA   0,Y          ; GET A TOKEN.
   80 F819:81A2            [ 2]         CMPA   #SCONTOK     ; IS THERE A PROMPT TO PRINT?
   81 F81B:261B (F838)     [ 3]         BNE    RINPUT1      ; NO JUST GO GET THE DATA.
   82 F81D:183C            [ 5]         PSHY                ; YES. SAVE POINTER.
   83 F81F:C602            [ 2]         LDAB   #2           ; COMPENSATE FOR CONSTANT & LENGTH BYTE.
   84 F821:18EB 01         [ 5]         ADDB   1,Y          ; ADD IN LENGTH BYTE.
   85 F824:183A            [ 4]         ABY                 ; POINT BEYOND PROMPT.
   86 F826:38              [ 5]         PULX                ; GET POINTER INTO X.
   87 F827:08              [ 3]         INX                 ; POINT TO LENGTH BYTE.
   88 F828:E600            [ 4]         LDAB   0,X          ; GET IT.
   89 F82A:C002            [ 2]         SUBB   #2           ; SUBTRACT OUT THE DELIMETER COUNT.
   90 F82C:08              [ 3]         INX                 ; POINT TO STRING.
   91 F82D:08              [ 3]         INX
   92 F82E:BDF8 D0         [ 6]         JSR    OUTSTR       ; GO PRINT THE STRING.
   93 F831:1808            [ 4]         INY                 ; BYPASS COMMA.
   94 F833:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES AFTER COMMA.
   95 F836:2003 (F83B)     [ 3]         BRA    RINPUT6
   96 F838:BDE1 10         [ 6] RINPUT1:        JSR    NL
   97      F83B                 RINPUT6:        EQU    *
   98 F83B:CEF8 4F         [ 3]         LDX    #QSP         ; POINT TO PROMPT.
   99 F83E:BDE1 1C         [ 6]         JSR    PL           ; PRINT IT.
  100 F841:BDE0 BB         [ 6]         JSR    GETLINE      ; GET THE DATA IN THE INPUT BUFFER.
  101 F844:8D3B (F881)     [ 6]         BSR    RINRDC
  102 F846:25F0 (F838)     [ 3]         BCS    RINPUT1
  103 F848:BDE1 10         [ 6]         JSR    NL
  104 F84B:7F00 37         [ 6]         CLR    DEVNUM       ; SET DEVICE NUMBER BACK TO 0.
  105 F84E:39              [ 5]         RTS
  106                           *
  107                           *
  108 F84F.3F20                 QSP:    FCC    "? "
  109 F851.00                           FCB    0
  110                           *
  111                           *
  112 F852:18A6 00         [ 5] CHCKDEV:        LDAA   0,Y          ; GET A TOKEN.
  113 F855:8178            [ 2]         CMPA   #PNUMTOK     ; IS AN ALTERNATE DEVICE SPECIFYED?
  114 F857:2701 (F85A)     [ 3]         BEQ    CHCKDEV1     ; YES. CONTINUE.
  115 F859:39              [ 5]         RTS                 ; NO. RETURN.
  116 F85A:1808            [ 4] CHCKDEV1:       INY                 ; YES. PASS THE '#' TOKEN.
  117 F85C:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES.
  118 F85F:BDFB 12         [ 6]         JSR    DONEXP       ; GO EVALUATE THE NUMERIC EXPRESSION.
  119 F862:BDFB B9         [ 6]         JSR    PULNUM       ; GET THE NUMBER OFF THE STACK.
  120 F865:2A05 (F86C)     [ 3]         BPL    CHCKDEV2     ; NEGATIVE NUMBERS NOT ALLOWED.
  121 F867:8630            [ 2] CHCKDEV3:       LDAA   #ILLIOERR    ; REPORT THE ERROR.
  122 F869:7EEA EF         [ 3]         JMP    RPTRERR
  123 F86C:1A83 0007       [ 5] CHCKDEV2:       CPD    #$0007       ; IS IT LARGER THAN 7?
  124 F870:22F5 (F867)     [ 3]         BHI    CHCKDEV3
  125 F872:D737            [ 3]         STAB   DEVNUM       ; MAKE IT THE NEW DEVICE NUMBER.
  126 F874:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES.
  127 F877:817D            [ 2]         CMPA   #EOLTOK      ; IF THIS IS A PRINT STATEMENT, IS IT EOL?
  128 F879:2705 (F880)     [ 3]         BEQ    CHCKDEV4     ; YES. DON'T BUMP THE IP.
  129 F87B:1808            [ 4]         INY                 ; BYPASS THE COMMA.
  130 F87D:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES.
  131 F880:39              [ 5] CHCKDEV4:       RTS                 ; RETURN.
  132                           *
  133                           *
  134                           *
  135 F881:BDE0 5B         [ 6] RINRDC: JSR    SKIPSPCS
  136 F884:810D            [ 2]         CMPA   #EOL
  137 F886:2602 (F88A)     [ 3]         BNE    RINRDC1
  138 F888:0D              [ 2]         SEC
  139 F889:39              [ 5]         RTS
  140 F88A:8D17 (F8A3)     [ 6] RINRDC1:        BSR    INNUMD
  141 F88C:BDF1 CA         [ 6]         JSR    RSKIPSPC
  142 F88F:18A6 00         [ 5]         LDAA   0,Y
  143 F892:817D            [ 2]         CMPA   #EOLTOK
  144 F894:270B (F8A1)     [ 3]         BEQ    RINRDC2
  145 F896:817A            [ 2]         CMPA   #MEOLTOK
  146 F898:2707 (F8A1)     [ 3]         BEQ    RINRDC2
  147 F89A:1808            [ 4]         INY                 ; BUMP PAST THE COMMA.
  148 F89C:BDF1 CA         [ 6]         JSR    RSKIPSPC
  149 F89F:20E0 (F881)     [ 3]         BRA    RINRDC
  150 F8A1:0C              [ 2] RINRDC2:        CLC
  151 F8A2:39              [ 5]         RTS
  152                           *
  153                           *
  154      F8A3                 INNUMD: EQU    *
  155 F8A3:8124            [ 2]         CMPA   #'$'
  156 F8A5:2608 (F8AF)     [ 3]         BNE    INNUM2
  157 F8A7:BDE3 CC         [ 6]         JSR    INCIBP
  158 F8AA:BDE6 CF         [ 6]         JSR    GETHEX
  159 F8AD:2003 (F8B2)     [ 3]         BRA    INNUM3
  160 F8AF:BDF8 DD         [ 6] INNUM2: JSR    INDECI
  161      F8B2                 INNUM3: EQU    *
  162                           *        PSHD
  163 F8B2:37              [ 3]         PSHB
  164 F8B3:36              [ 3]         PSHA
  165 F8B4:BDE0 5B         [ 6]         JSR    SKIPSPCS
  166 F8B7:812C            [ 2]         CMPA   #COMMA
  167 F8B9:2709 (F8C4)     [ 3]         BEQ    INNUM4
  168 F8BB:810D            [ 2]         CMPA   #EOL
  169 F8BD:2708 (F8C7)     [ 3]         BEQ    INNUM7
  170 F8BF:8615            [ 2]         LDAA   #MCOMAERR
  171 F8C1:7EEA EF         [ 3]         JMP    RPTRERR
  172 F8C4:BDE3 CC         [ 6] INNUM4: JSR    INCIBP
  173 F8C7:BDF3 FF         [ 6] INNUM7: JSR    RVARPTR
  174 F8CA:8F              [ 3]         XGDX
  175 F8CB:32              [ 4]         PULA
  176 F8CC:33              [ 4]         PULB
  177 F8CD:ED00            [ 5]         STD    0,X
  178 F8CF:39              [ 5]         RTS
  179                           *
  180      F8D0                 OUTSTR   EQU    *
  181 F8D0:5D              [ 2]         TSTB
  182 F8D1:2709 (F8DC)     [ 3]         BEQ    OUTSTR2
  183 F8D3:A600            [ 4] OUTSTR1  LDAA   0,X
  184 F8D5:08              [ 3]         INX
  185 F8D6:BDFE CD         [ 6]         JSR    OUTBYTE
  186 F8D9:5A              [ 2]         DECB
  187 F8DA:26F7 (F8D3)     [ 3]         BNE    OUTSTR1
  188 F8DC:39              [ 5] OUTSTR2  RTS
  189                           *
  190                           *
  191      F8DD                 INDECI: EQU    *
  192 F8DD:BDE3 C3         [ 6]         JSR    GETCHR       ; GET A CHARACTER.
  193 F8E0:812D            [ 2]         CMPA   #'-'     ; IS IT A NEGATIVE NUMBER?
  194 F8E2:260C (F8F0)     [ 3]         BNE    INDECI1      ; NO. GO GET POSITIVE NUMBER.
  195 F8E4:BDE3 CC         [ 6]         JSR    INCIBP       ; YES. BUMP INPUT BUFFER PAST IT.
  196 F8E7:BDE6 A1         [ 6]         JSR    GETDECI      ; GET THE NUMBER.
  197 F8EA:43              [ 2]         COMA            ; NEGATE IT.
  198 F8EB:53              [ 2]         COMB
  199 F8EC:C300 01         [ 4]         ADDD   #1
  200 F8EF:39              [ 5]         RTS             ; RETURN.
  201 F8F0:BDE6 A1         [ 6] INDECI1:        JSR    GETDECI
  202 F8F3:39              [ 5]         RTS
  203                           *
  204                           *
  205      F8F4                 RREAD:  EQU    *
  206 F8F4:DE33            [ 4]         LDX    DATAPTR      ; GET POINTER TO DATA. IS IT POINTING TO DATA?
  207 F8F6:2604 (F8FC)     [ 3]         BNE    RREAD1       ; YES. CONTINUE TO READ DATA.
  208 F8F8:8D1D (F917)     [ 6]         BSR    RRESTOR      ; NO. GO GET POINTER TO FIRST DATA STATEMENT.
  209 F8FA:DE33            [ 4]         LDX    DATAPTR      ; GET POINTER TO DATA.
  210 F8FC:DF00            [ 4] RREAD1: STX    IBUFPTR      ; PUT IT IN THE INPUT BUFFER POINTER.
  211 F8FE:BDF8 81         [ 6]         JSR    RINRDC       ; GO USE INPUT/READ COMMON CODE.
  212 F901:2505 (F908)     [ 3]         BCS    RREAD2       ; IF CARRY SET, MORE DATA TO READ.
  213 F903:DE00            [ 4]         LDX    IBUFPTR      ; GET POINTER TO DATA LINE.
  214 F905:DF33            [ 4]         STX    DATAPTR      ; SAVE DATA POINTER FOR NEXT READ.
  215 F907:39              [ 5]         RTS                 ; RETURN.
  216 F908:183C            [ 5] RREAD2: PSHY                ; SAVE Y.
  217 F90A:18DE 00         [ 5]         LDY    IBUFPTR
  218 F90D:1808            [ 4]         INY
  219 F90F:1808            [ 4]         INY
  220 F911:8D3A (F94D)     [ 6]         BSR    RESTOR4      ; GO FIND NEXT "DATA" STATEMENT.
  221 F913:1838            [ 6]         PULY                ; RESTORE Y.
  222 F915:20DD (F8F4)     [ 3]         BRA    RREAD        ; KEEP READING DATA.
  223                           *
  224                           *
  225      F917                 RRESTOR:        EQU    *
  226 F917:183C            [ 5]         PSHY                ; SAVE Y.
  227 F919:18DE 04         [ 5]         LDY    BASBEG       ; START SEARCH FOR "DATA" STATEMENTS AT THE BEGIN.
  228 F91C:183C            [ 5] RESTOR2:        PSHY                ; SAVE POINTER TO THIS LINE.
  229 F91E:18E6 02         [ 5]         LDAB   2,Y          ; GET LINE LENGTH.
  230 F921:183A            [ 4]         ABY                 ; GET START OF NEXT LINE.
  231 F923:18DF 33         [ 5]         STY    DATAPTR      ; SAVE IN "DATAPTR".
  232 F926:1838            [ 6]         PULY                ; RESTORE POINTER.
  233 F928:C603            [ 2]         LDAB   #3
  234 F92A:183A            [ 4]         ABY                 ; POINT TO FIRST TOKEN IN LINE.
  235 F92C:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES.
  236 F92F:18A6 00         [ 5]         LDAA   0,Y          ; GET THE KEYWORD.
  237 F932:810C            [ 2]         CMPA   #DATATOK     ; IS IT A DATA LINE?
  238 F934:270D (F943)     [ 3]         BEQ    RESTOR1      ; YES. GO SET UP POINTER.
  239 F936:18DE 33         [ 5]         LDY    DATAPTR      ; GET ADDRESS OF NEXT LINE.
  240 F939:189C 06         [ 6] RESTOR3:        CPY    BASEND       ; ARE WE AT THE END OF THE PROGRAM?
  241 F93C:26DE (F91C)     [ 3]         BNE    RESTOR2      ; NO. KEEP LOOKING.
  242 F93E:8626            [ 2]         LDAA   #ODRDERR     ; OUT OF DATA ERROR.
  243 F940:7EEA EF         [ 3]         JMP    RPTRERR      ; REPORT THE ERROR.
  244 F943:1808            [ 4] RESTOR1:        INY                 ; POINT PAST DATA TOKEN & THE DATA LENGTH.
  245 F945:1808            [ 4]         INY
  246 F947:18DF 33         [ 5]         STY    DATAPTR      ; SAVE POINTER TO DATA.
  247 F94A:1838            [ 6]         PULY                ; RESTORE Y.
  248 F94C:39              [ 5]         RTS                 ; RETURN.
  249                           *
  250                           *
  251 F94D:183C            [ 5] RESTOR4:        PSHY                ; CALL TO COMPENSATE FOR PULL OF Y ON RETURN.
  252 F94F:20E8 (F939)     [ 3]         BRA    RESTOR3
  253                           *
  254                           *
  255      F951                 RIF:    EQU    *
  256 F951:BDFB 12         [ 6]         JSR    DONEXP       ; GO DO A NUMERIC EXPRESSION.
  257 F954:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES.
  258 F957:1808            [ 4]         INY                 ; SKIP PAST "THEN" TOKEN.
  259 F959:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES AFTER THEN.
  260 F95C:BDFB B9         [ 6]         JSR    PULNUM       ; GET RESULT OF EXPRESSION FROM OPERAND STACK.
  261 F95F:2703 (F964)     [ 3]         BEQ    RIF1         ; NOT TRUE. SEE IF ELSE CLAUSE PRESENT.
  262 F961:7EF4 36         [ 3] RIF3:   JMP    RGOTO        ; RESULT WAS TRUE. GOTO PROPER LINE NUMBER.
  263 F964:C603            [ 2] RIF1:   LDAB   #3           ; BUMP IP PAST LINE NUMBER.
  264 F966:183A            [ 4]         ABY
  265 F968:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES IF PRESENT.
  266 F96B:18A6 00         [ 5]         LDAA   0,Y          ; GET NEXT TOKEN.
  267 F96E:8139            [ 2]         CMPA   #ELSETOK     ; IS IT THE "ELSE" CLAUSE.
  268 F970:2607 (F979)     [ 3]         BNE    RIF2     ; NO RETURN.
  269 F972:1808            [ 4]         INY                 ; PASS ELSE TOKEN.
  270 F974:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES.
  271 F977:20E8 (F961)     [ 3]         BRA    RIF3         ; DO A GOTO.
  272 F979:39              [ 5] RIF2:   RTS                 ; RETURN.
  273                           *
  274                           *
  275      F97A                 REEP:   EQU    *            ; PROGRAM A WORD OF EEPROM.
  276 F97A:1808            [ 4]         INY                 ; PASS UP THE OPEN PAREN.
  277 F97C:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; PASS UP ANY SPACES.
  278 F97F:BDFB 12         [ 6]         JSR    DONEXP       ; GO GET THE "SUBSCRIPT" OF THE EEPROM LOCATION.
  279 F982:1808            [ 4]         INY                 ; PASS UP THE CLOSING PAREN.
  280 F984:1808            [ 4]         INY                 ; PASS UP THE EQUALS TOKEN.
  281 F986:BDFB 12         [ 6]         JSR    DONEXP       ; GET VALUE TO FROGRAM INTO EEPROM.
  282 F989:183C            [ 5]         PSHY                ; SAVE THE Y REG.
  283 F98B:18DE 1F         [ 5]         LDY    NUMSTACK     ; POINT TO THE NUMERIC STACK.
  284 F98E:18EC 02         [ 6]         LDD    2,Y          ; GET THE SUBSCRIPT FOR THE EEPROM LOCATION.
  285 F991:2B06 (F999)     [ 3]         BMI    REEP1        ; NEGATIVE SUBSCRIPTS NOT ALLOWED.
  286 F993:1A83 00FF       [ 5]         CPD    #MAXEESUB    ; IS THE SUBSCRIPT WITHIN RANGE?
  287 F997:2305 (F99E)     [ 3]         BLS    REEP2        ; YES. CONTINUE.
  288 F999:8628            [ 2] REEP1:  LDAA   #EESUBERR    ; EEPROM SUBSCRIPT ERROR.
  289 F99B:7EEA EF         [ 3]         JMP    RPTRERR      ; REPORT IT.
  290 F99E:05              [ 3] REEP2:  LSLD                ; MULT THE SUBSCRIPT BY 2.
  291 F99F:C3B6 00         [ 4]         ADDD   #EEPBASAD    ; ADD IN THE EEPROM BASE ADDRESS.
  292 F9A2:8F              [ 3]         XGDX                ; PUT THE ADDRESS INTO X.
  293 F9A3:A600            [ 4]         LDAA   0,X          ; GET THE MOST SIGNIFIGANT BYTE OF THE CURRENT NUM.
  294 F9A5:81FF            [ 2]         CMPA   #$FF         ; DOES IT NEED ERASING?
  295 F9A7:2702 (F9AB)     [ 3]         BEQ    REEP3        ; NO. SEE IF NEXT BYTE NEEDS ERASING.
  296 F9A9:8D1D (F9C8)     [ 6]         BSR    ERASEBYT     ; YES. GO ERASE IT.
  297 F9AB:08              [ 3] REEP3:  INX                 ; POINT TO NEXT BYTE.
  298 F9AC:A600            [ 4]         LDAA   0,X          ; GET NEXT BYTE.
  299 F9AE:81FF            [ 2]         CMPA   #$FF         ; DOES THIS BYTE NEED TO BE ERASED?
  300 F9B0:2702 (F9B4)     [ 3]         BEQ    REEP4        ; NO. GO WRITE DATA TO EEPROM.
  301 F9B2:8D14 (F9C8)     [ 6]         BSR    ERASEBYT     ; YES. GO ERASE THE BYTE.
  302 F9B4:18A6 01         [ 5] REEP4:  LDAA   1,Y          ; GET LS BYTE OF WORD.
  303 F9B7:8D32 (F9EB)     [ 6]         BSR    PROGBYTE     ; GO PROGRAM THE BYTE.
  304 F9B9:09              [ 3]         DEX                 ; POINT TO THE MOST SIGNIFIGANT EEPROM LOCATION.
  305 F9BA:18A6 00         [ 5]         LDAA   0,Y          ; GET THE MS BYTE OF THE WORD.
  306 F9BD:8D2C (F9EB)     [ 6]         BSR    PROGBYTE     ; GO PROGRAM THE BYTE.
  307 F9BF:1838            [ 6]         PULY                ; RESTORE Y.
  308 F9C1:BDFB B9         [ 6]         JSR    PULNUM       ; FIX UP NUM STACK.
  309 F9C4:BDFB B9         [ 6]         JSR    PULNUM
  310 F9C7:39              [ 5]         RTS                 ; RETURN.
  311                           *
  312                           *
  313      F9C8                 ERASEBYT:       EQU    *
  314 F9C8:183C            [ 5]         PSHY
  315 F9CA:18DE 61         [ 5]         LDY     IOBaseV ; Point to the base address of the I/O Registers.
  316 F9CD:C616            [ 2]         LDAB   #$16         ; SET UP BYTE ERASE MODE, ADDR LATCH, ERASE
  317 F9CF:18E7 3B         [ 5]         STAB   PPROG,Y      ; VOLTAGE OFF.
  318 F9D2:A700            [ 4]         STAA   0,X          ; LATCH ADDRESS.
  319 F9D4:07              [ 2]         TPA             ; GET CURRENT I-BIT STATUS.
  320 F9D5:36              [ 3]         PSHA            ; SAVE IT.
  321 F9D6:0F              [ 2]         SEI             ; INHIBIT INTERRUPTS WHILE ERASING.
  322 F9D7:C617            [ 2]         LDAB   #$17         ; TURN ON ERASE VOLTAGE
  323 F9D9:18E7 3B         [ 5]         STAB   PPROG,Y
  324 F9DC:8D36 (FA14)     [ 6]         BSR    DLY10MS      ; DELAY ABOUT 10 MS.
  325 F9DE:C616            [ 2]         LDAB   #$16         ; TURN PROGRAMING VOLTAGE OFF.
  326 F9E0:18E7 3B         [ 5]         STAB   PPROG,Y
  327 F9E3:32              [ 4]         PULA                ; GET ORIGINAL I-BIT STATUS.
  328 F9E4:06              [ 2]         TAP                 ; RESTORE IT.
  329 F9E5:186F 3B         [ 7]         CLR    PPROG,Y
  330 F9E8:1838            [ 6]         PULY
  331 F9EA:39              [ 5]         RTS                 ; RETURN.
  332                           *
  333                           *
  334      F9EB                 PROGBYTE:       EQU    *
  335 F9EB:183C            [ 5]         PSHY
  336 F9ED:18DE 61         [ 5]         LDY     IOBaseV ; Point to the base address of the I/O Registers.
  337 F9F0:C602            [ 2] PROGBYT2:       LDAB   #$02         ; SET UP NORMAL PROGRAMING MODE, ADDRESS/DATA
  338 F9F2:18E7 3B         [ 5]         STAB   PPROG,Y      ; LATCHED, PROGRAMING VOLTAGE OFF.
  339 F9F5:A700            [ 4]         STAA   0,X          ; LATCH DATA & ADDRESS.
  340 F9F7:36              [ 3]         PSHA                ; SAVE THE DATA FOR COMPARE AFTER PROGRAMING.
  341 F9F8:07              [ 2]         TPA                 ; GET CURRENT I-BIT STATUS.
  342 F9F9:36              [ 3]         PSHA                ; SAVE IT.
  343 F9FA:0F              [ 2]         SEI                 ; INHIBIT INTERRUPTS WHILE PROGRAMING.
  344 F9FB:C603            [ 2]         LDAB   #$03         ; TURN ON PROGRAMING VOLTAGE.
  345 F9FD:18E7 3B         [ 5]         STAB   PPROG,Y
  346 FA00:8D12 (FA14)     [ 6]         BSR    DLY10MS      ; LEAVE IT ON FOR 10 MS.
  347 FA02:C602            [ 2]         LDAB   #$02         ; NOW, TURN THE PROGRAMMING VOLTAGE OFF.
  348 FA04:18E7 3B         [ 5]         STAB   PPROG,Y
  349 FA07:32              [ 4]         PULA                ; GET ORIGINAL I-BIT STATUS.
  350 FA08:06              [ 2]         TAP                 ; RESTORE IT.
  351 FA09:186F 3B         [ 7]         CLR    PPROG,Y      ; PUT THE EEPROM BACK IN THE READ MODE.
  352 FA0C:32              [ 4]         PULA                ; RESTORE THE DATA TO SEE IF IT WAS PROGRAMMED.
  353 FA0D:A100            [ 4]         CMPA   0,X          ; WAS THE DATA WRITTEN PROPERLY?
  354 FA0F:26DF (F9F0)     [ 3]         BNE    PROGBYT2     ; NO. TRY AGAIN.
  355 FA11:1838            [ 6]         PULY            ; Restore Y.
  356 FA13:39              [ 5]         RTS                 ; YES. RETURN.
  357                           *
  358                           *
  359      FA14                 DLY10MS:        EQU    *
  360 FA14:3C              [ 4]         PSHX                ; SAVE X.
  361 FA15:CE0D 02         [ 3]         LDX    #3330        ; GET DELAY CONSTANT.
  362 FA18:09              [ 3] DLY10MS1:       DEX                 ; DECREMENT THE COUNT. DONE?
  363 FA19:26FD (FA18)     [ 3]         BNE    DLY10MS1     ; NO. DELAY SOME MORE.
  364 FA1B:38              [ 5]         PULX                ; RESTORE X.
  365 FA1C:39              [ 5]         RTS                 ; RETURN.
  366                           *
  367                           *
  368      FA1D                 RINBYTE:        EQU    *
  369 FA1D:BDF8 52         [ 6]         JSR    CHCKDEV      ; GO CHECK FOR AN ALTERNATE DEVICE DESIGNATION.
  370 FA20:BDF3 FF         [ 6]         JSR    RVARPTR      ; GO GET POINTER TO THE BYTE INPUT VARIABLE.
  371 FA23:8F              [ 3]         XGDX                ; PUT THE POINTER INTO X.
  372 FA24:BDFE EA         [ 6]         JSR    INBYTE       ; GO GET A BYTE FROM THE SPECIFIED INPUT DEVICE.
  373 FA27:16              [ 2]         TAB                 ; PUT THE BYTE IN THE L.S.BYTE.
  374 FA28:4F              [ 2]         CLRA                ; ZERO THE UPPER BYTE.
  375 FA29:ED00            [ 5]         STD    0,X          ; PUT IT IN THE VARIABLE.
  376 FA2B:7F00 37         [ 6]         CLR    DEVNUM       ; RESET TO DEVICE #0.
  377 FA2E:39              [ 5]         RTS                 ; RETURN.
  378                           *
  379                           *
  380      FA2F                 RTIME:  EQU    *
  381 FA2F:1808            [ 4]         INY                 ; POINT PAST THE EQUALS TOKEN.
  382 FA31:BDFB 12         [ 6]         JSR    DONEXP       ; GO EVALUATE THE EXPRESSION.
  383 FA34:BDFB B9         [ 6]         JSR    PULNUM       ; GET THE NUMBER OFF THE STACK.
  384 FA37:DD38            [ 4]         STD    TIMEREG      ; PUT IT IN THE TIME REGISTER.
  385 FA39:39              [ 5]         RTS                 ; RETURN.
  386                           *
  387                           *
  388      FA3A                 RRTIME: equ     *
  389 FA3A:0F              [ 2]         sei             ; disable interrupts.
  390 FA3B:8603            [ 2]         LDAA   #SWPRE+1 ; ADD 1 TO NORMAL PRE SCALER.
  391 FA3D:973C            [ 3]         STAA   TIMEPRE  ; SET UP THE SOFTWARE PRESCALER.
  392 FA3F:DE61            [ 4]         LDX     IOBaseV ; Point to the I/O Base Address.
  393 FA41:EC0E            [ 5]         ldd     TCNT,x  ; get the current value of the timer counter.
  394 FA43:BDEE 00         [ 6]         jsr     TIMINTS3        ; go initialize the TOC using the timer interrupt code.
  395 FA46:4F              [ 2]         clra
  396 FA47:5F              [ 2]         clrb
  397 FA48:DD38            [ 4]         STD    TIMEREG      ; PUT IT IN THE TIME REGISTER.
  398 FA4A:0E              [ 2]         cli
  399 FA4B:39              [ 5]         RTS                 ; RETURN.
  400                           *
  401                           *
  402      FA4C                 RPACC:  EQU    *
  403 FA4C:1808            [ 4]         INY                 ; POINT PAST EQUALS TOKEN.
  404 FA4E:BDFB 12         [ 6]         JSR    DONEXP       ; EVALUATE THE EXPRESSION.
  405 FA51:BDFB B9         [ 6]         JSR    PULNUM       ; GET THE NUMBER OFF THE STACK.
  406 FA54:4D              [ 2]         TSTA                ; IS THE NUMBER WITHIN RANGE?
  407 FA55:2705 (FA5C)     [ 3]         BEQ    RPACC1       ; YES. GO SETUP THE PACC REGISTER.
  408 FA57:8635            [ 2]         LDAA   #PACCARGE    ; NO. REPORT AN ERROR.
  409 FA59:7EEA EF         [ 3]         JMP    RPTRERR
  410 FA5C:DE61            [ 4] RPACC1: LDX    IOBaseV
  411 FA5E:E727            [ 4]         STAB   PACNT,X      ; PUT NUMBER IN PULSE ACC.
  412 FA60:39              [ 5]         RTS                 ; RETURN.
  413                           *
  414                           *
  415      FA61                 RONTIME:        EQU    *
  416 FA61:8D4A (FAAD)     [ 6]         BSR    CHCKIMID    ; NOT ALLOWED IN IMMIDIATE.
  417 FA63:BDFB 12         [ 6]         JSR    DONEXP      ; GO EVALUATE THE TIME "MATCH" EXPRESSION.
  418 FA66:BDFB B9         [ 6]         JSR    PULNUM      ; GET THE NUMBER OFF THE STACK.
  419 FA69:DD3A            [ 4]         STD    TIMECMP     ; PUT IN THE COMPARE REGISTER.
  420 FA6B:BDF1 CA         [ 6]         JSR    RSKIPSPC    ; SKIP SPACES.
  421 FA6E:1808            [ 4]         INY                ; PASS UP COMMA.
  422 FA70:BDF1 CA         [ 6]         JSR    RSKIPSPC    ; SKIP SPACES.
  423 FA73:18DF 3D         [ 5]         STY    ONTIMLIN    ; SAVE THE POINTER TO THE LINE NUMBER.
  424 FA76:2019 (FA91)     [ 3]         BRA    RONIRQ2     ; GO FINISH UP.
  425                           *
  426                           *
  427      FA78                 RONIRQ: EQU    *
  428 FA78:8D33 (FAAD)     [ 6]         BSR    CHCKIMID
  429 FA7A:BDFB 12         [ 6]         JSR    DONEXP      ; GO CHECK TO SEE IF WE ARE TO ENABLE OR DISABLE.
  430 FA7D:BDF1 CA         [ 6]         JSR    RSKIPSPC    ; SKIP SPACES UP TO COMMA.
  431 FA80:1808            [ 4]         INY                ; BYPASS COMMA.
  432 FA82:BDF1 CA         [ 6]         JSR    RSKIPSPC    ; SKIP SPACES UP TO LINE NUMBER.
  433 FA85:BDFB B9         [ 6]         JSR    PULNUM      ; GET MODE. SHOULD WE ENABLE THE FUNCTION?
  434 FA88:2604 (FA8E)     [ 3]         BNE    RONIRQ1     ; YES.
  435 FA8A:DD3F            [ 4]         STD    ONIRQLIN    ; NO. MAKE THE LINE NUMBER 0.
  436 FA8C:2003 (FA91)     [ 3]         BRA    RONIRQ2     ; GO FINISH UP.
  437 FA8E:18DF 3F         [ 5] RONIRQ1:        STY    ONIRQLIN    ; SAVE THE POINTER TO THE LINE NUMBER,
  438 FA91:C603            [ 2] RONIRQ2:        LDAB   #3          ; MOVE IP PAST THE LINE NUMBER.
  439 FA93:183A            [ 4]         ABY
  440 FA95:39              [ 5]         RTS                ; RETURN.
  441                           *
  442                           *
  443      FA96                 RRETI:  EQU    *
  444 FA96:8D15 (FAAD)     [ 6]         BSR    CHCKIMID
  445 FA98:07              [ 2]         TPA                 ; CHECK TO SEE IF THE INTERRUPT MASK IS SET.
  446 FA99:8510            [ 2]         BITA   #$10         ; ARE WE IN AN INTERRUPT ROUTINE?
  447 FA9B:2605 (FAA2)     [ 3]         BNE    RRETI1       ; SINCE THE IRQ MASK IS SET WE MUST BE.
  448 FA9D:8634            [ 2]         LDAA   #NOTINTER    ; NO. FLAG AN ERROR.
  449 FA9F:7EEA EF         [ 3]         JMP    RPTRERR      ; GO REPORT IT.
  450 FAA2:DC45            [ 4] RRETI1: LDD    SCURLINE     ; RESTORE THE MAIN PROGRAM CURRENT LINE.
  451 FAA4:DD29            [ 4]         STD    CURLINE
  452 FAA6:DC47            [ 4]         LDD    SADRNXLN     ; RESTORE MAIN PROGRAM "ADDRESS OF THE NEXT LINE".
  453 FAA8:DD2B            [ 4]         STD    ADRNXLIN
  454 FAAA:31              [ 3]         INS                 ; TAKE THE RETURN ADDRESS OFF THE STACK.
  455 FAAB:31              [ 3]         INS
  456 FAAC:3B              [12]         RTI                 ; GO BACK TO WHERE WE LEFT OFF.
  457                           *
  458                           *
  459      FAAD                 CHCKIMID:       EQU    *
  460 FAAD:7D00 19         [ 6]         TST    IMMID        ; ARE WE IN THE IMMIDIATE MODE?
  461 FAB0:2705 (FAB7)     [ 3]         BEQ    CHCKIMI1     ; NO. JUST RETURN.
  462 FAB2:8633            [ 2]         LDAA   #NOTALERR    ; YES. THIS COMMAND NOT ALLOWED.
  463 FAB4:7EEA EF         [ 3]         JMP    RPTRERR      ; REPORT THE ERROR.
  464 FAB7:39              [ 5] CHCKIMI1:       RTS                 ; RETURN.
  465                           *
  466                           *
  467      FAB8                 RONPACC:        EQU    *
  468 FAB8:8DF3 (FAAD)     [ 6]         BSR    CHCKIMID     ; THIS INSTRUCTION NOT ALLOWED IN IMMID MODE.
  469 FABA:BDFB 12         [ 6]         JSR    DONEXP       ; GO EVALUATE THE COUNT MODE EXPRESSION.
  470 FABD:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES.
  471 FAC0:1808            [ 4]         INY                 ; BYPASS THE COMMA.
  472 FAC2:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES AFTER COMMA.
  473 FAC5:BDFB 12         [ 6]         JSR    DONEXP       ; GO EVALUATE THE INTERRUPT MODE EXPRESSION.
  474 FAC8:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES.
  475 FACB:1808            [ 4]         INY                 ; BYPASS THE COMMA.
  476 FACD:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES AFTER THE COMMA.
  477 FAD0:07              [ 2]         TPA             ; GET CURRENT I-BIT STATUS.
  478 FAD1:36              [ 3]         PSHA                ; SAVE IT.
  479 FAD2:0F              [ 2]         SEI                 ; INHIBIT INTERRUPTS.
  480 FAD3:18DF 41         [ 5]         STY    ONPACLIN     ; SAVE POINTER TO INTERRUPT ROUTINE.
  481 FAD6:BDFB B9         [ 6]         JSR    PULNUM       ; GET INTERRUPT MODE OFF STACK.
  482 FAD9:1A83 0001       [ 5] RONPACC1:       CPD    #1           ; IS THE ARGUMENT <=1?
  483 FADD:2305 (FAE4)     [ 3]         BLS    RONPACC2     ; YES. ARG. OK.
  484 FADF:8636            [ 2] RONPACC5:       LDAA   #INTMODER    ; NO. GET ERROR CODE.
  485 FAE1:7EEA EF         [ 3]         JMP    RPTRERR
  486 FAE4:8610            [ 2] RONPACC2:       LDAA   #$10         ; GET BIT TO ENABLE INTERRUPT.
  487 FAE6:5D              [ 2]         TSTB                ; WAS THE ARGUMENT 0?
  488 FAE7:2701 (FAEA)     [ 3]         BEQ    RONPACC3     ; YES. GO ENABLE INTS. ON EACH COUNT.
  489 FAE9:48              [ 2]         LSLA                ; NO. ENABLE INTS. ON PACC OVERFLOW ONLY.
  490 FAEA:DE61            [ 4] RONPACC3:       LDX    IOBaseV
  491 FAEC:A724            [ 4]         STAA   TMSK2,X
  492 FAEE:BDFB B9         [ 6]         JSR    PULNUM       ; GET THE COUNT MODE OFF THE STACK.
  493 FAF1:2608 (FAFB)     [ 3]         BNE    RONPACC4     ; GO SET THE MODE IF NOT 0.
  494 FAF3:DE61            [ 4]         LDX    IOBaseV
  495 FAF5:6F26            [ 6]         CLR    PACTL,X      ; TURN OFF THE PULSE ACCUMULATOR.
  496 FAF7:DD41            [ 4]         STD    ONPACLIN     ; CLEAR POINTER TO LINE NUMBER.
  497 FAF9:2010 (FB0B)     [ 3]         BRA    RONPACC6     ; GO CLEAN UP & RETURN.
  498 FAFB:1A83 0004       [ 5] RONPACC4:       CPD    #4           ; IS THE ARGUMENT IN RANGE?
  499 FAFF:22DE (FADF)     [ 3]         BHI    RONPACC5     ; YES. REPORT AN ERROR.
  500 FB01:CB03            [ 2]         ADDB   #3           ; GET BIT TO ENABLE PACC.
  501 FB03:58              [ 2]         LSLB
  502 FB04:58              [ 2]         LSLB
  503 FB05:58              [ 2]         LSLB
  504 FB06:58              [ 2]         LSLB
  505 FB07:DE61            [ 4]         LDX    IOBaseV
  506 FB09:E726            [ 4]         STAB   PACTL,X      ; ENABLE THE PACC & SET MODE.
  507 FB0B:32              [ 4] RONPACC6:       PULA                ; GET OLD I-BIT STATUS OFF STACK.
  508 FB0C:06              [ 2]         TAP                 ; RESTORE OLD STATUS.
  509 FB0D:C603            [ 2]         LDAB   #3
  510 FB0F:183A            [ 4]         ABY                 ; PASS UP LINE NUMBER.
  511 FB11:39              [ 5]         RTS                 ; RETURN.
  512                           *
  513                           *
*** END   INCLUDE FILE: RUNTIME3.ASM *** (RESUMING FILE: BASIC11.ASM)
   19                           #Include  'REXPRES.Asm'
*** BEGIN INCLUDE FILE: REXPRES.ASM ***
    1                           *        title    REXPRES.TXT
    2                           *        page
    3                           ******************************************************************************
    4                           *                                                                            *
    5                           *               RUNTIME EXPRESSION EVALUATION SUBROUTINE                     *
    6                           *                                                                            *
    7                           ******************************************************************************
    8                           *
    9                           *
   10 FB12:8610            [ 2] DONEXP: LDAA   #OPARNTOK    ; USE AN OPEN PAREN AS AN END OF EXPRESSION MARKER.
   11 FB14:BDFC 1B         [ 6]         JSR    PSHOP        ; PUSH OPEN PAREN ON THE STACK.
   12 FB17:18A6 00         [ 5] DONEXP1:        LDAA   0,Y          ; GET THE NEXT CHARACTER IN THE EXPRESSION.
   13 FB1A:8110            [ 2]         CMPA   #OPARNTOK    ; IS IT AN OPEN PAREN?
   14 FB1C:2608 (FB26)     [ 3]         BNE    DONEXP4      ; NO. CONTINUE.
   15 FB1E:1808            [ 4]         INY                 ; POINT TO NEXT TOKEN.
   16 FB20:8DF0 (FB12)     [ 6]         BSR    DONEXP       ; GO DO A SUBEXPRESSION.
   17 FB22:1808            [ 4]         INY                 ; MOVE THE IP PAST THE CLOSING PAREN.
   18 FB24:20F1 (FB17)     [ 3]         BRA    DONEXP1      ; GO GET THE NEXT CHARACTER.
   19 FB26:4D              [ 2] DONEXP4:        TSTA                ; CHECK FOR OPERATOR OR OPERAND.
   20 FB27:2A04 (FB2D)     [ 3]         BPL    DONEXP2      ; IF NOT VARIABLE OR CONSTANT, GO CHECK FOR FUNCT.
   21 FB29:8D12 (FB3D)     [ 6]         BSR    PSHNUM       ; GO PUSH OPERAND ONTO STACK.
   22 FB2B:20EA (FB17)     [ 3]         BRA    DONEXP1      ; GO GET NEXT TOKEN.
   23 FB2D:BDFB C8         [ 6] DONEXP2:        JSR    CHKNFUN      ; GO CHECK FOR FUNCTION THAT RETURNS A NUMBER.
   24 FB30:BDFC 0B         [ 6]         JSR    CHCKEE       ; GO CHECK FOR END OF EXPRESSION.
   25 FB33:2401 (FB36)     [ 3]         BCC    DONEXP3      ; IF NOT END OF EXPRESSION, GO PUSH OPERATOR.
   26 FB35:39              [ 5]         RTS                 ; IF AT END, RETURN.
   27 FB36:1808            [ 4] DONEXP3:        INY                 ; POINT TO THE NEXT TOKEN.
   28 FB38:BDFC 1B         [ 6]         JSR    PSHOP        ; PUSH OPERATOR ONTO STACK.
   29 FB3B:20DA (FB17)     [ 3]         BRA    DONEXP1      ; GO GET NEXT TOKEN.
   30                           *
   31                           *
   32                           *
   33                           *        PSHNUM SUBROUTINE
   34                           *
   35                           *        PUSHES A NUMERIC OPERAND (CONSTANT OR VARIABLE) VALUE ONTO THE
   36                           *        OPERAND STACK.
   37                           *
   38                           *
   39 FB3D:8184            [ 2] PSHNUM: CMPA   #IVARTOK     ; IS IT AN INTEGER SCALER VARIABLE?
   40 FB3F:260E (FB4F)     [ 3]         BNE    PSHNUM1      ; NO. GO CHECK FOR CONSTANT.
   41 FB41:18EC 01         [ 6]         LDD    1,Y          ; YES. GET THE "OFFSET" ADDRESS.
   42 FB44:D308            [ 5]         ADDD   VARBEGIN     ; ADD IN THE START ADDRESS OF THE VARIABLE TABLE.
   43 FB46:8F              [ 3]         XGDX                ; GET THE ADDRESS INTO X.
   44 FB47:C603            [ 2]         LDAB   #$03         ; BUMP INTERPRETER POINTER PAST "VARIABLE".
   45 FB49:183A            [ 4]         ABY
   46 FB4B:EC03            [ 5]         LDD    3,X          ; GET THE VARIABLE VALUE.
   47 FB4D:202D (FB7C)     [ 3]         BRA    PSHNUM4      ; GO PUT IT ON THE STACK.
   48 FB4F:81A4            [ 2] PSHNUM1:        CMPA   #ICONTOK     ; IS IT AN INTEGER CONSTANT?
   49 FB51:260D (FB60)     [ 3]         BNE    PSHNUM2      ; NO. GO CHECK FOR AN INTEGER ARRAY VARIABLE.
   50 FB53:CDEE 01         [ 6]         LDX    1,Y          ; GET THE CONSTANT VALUE INTO X.
   51 FB56:C604            [ 2]         LDAB   #$04
   52 FB58:18EB 03         [ 5]         ADDB   3,Y
   53 FB5B:183A            [ 4]         ABY
   54 FB5D:8F              [ 3]         XGDX                ; PUT THE CONSTANT VALUE INTO D.
   55 FB5E:201C (FB7C)     [ 3]         BRA    PSHNUM4      ; GO PUT IT ON THE STACK.
   56 FB60:8194            [ 2] PSHNUM2:        CMPA   #IAVARTOK    ; IS IT AN INTEGER ARRAY?
   57 FB62:2613 (FB77)     [ 3]         BNE    PSHNUM3      ; NO. GO CHECK FOR A STRING VARIABLE.
   58 FB64:8D2A (FB90)     [ 6]         BSR    CALCSUB      ; GO GET BASE ADDR. & SUBSCRIPT OF ARRAY.
   59 FB66:183C            [ 5]         PSHY                ; SAVE THE INTERPRETER POINTER.
   60 FB68:3C              [ 4]         PSHX                ; PUT THE BASE ADDRESS OF THE ARRAY ON THE STACK.
   61 FB69:05              [ 3]         ASLD                ; MULTIPLY THE SUBSCRIPT BY THE # OF BYTES/ELEMENT.
   62 FB6A:1830            [ 4]         TSY                 ; POINT TO THE BASE ADDRESS.
   63 FB6C:18E3 00         [ 7]         ADDD   0,Y          ; GET ADDRESS OF THE ELEMENT.
   64 FB6F:38              [ 5]         PULX                ; RESTORE X.
   65 FB70:1838            [ 6]         PULY                ; RESTORE Y
   66 FB72:8F              [ 3]         XGDX                ; PUT ELEMENT ADDRESS INTO X.
   67 FB73:EC00            [ 5]         LDD    0,X          ; GET VALUE OF ELEMENT IN D.
   68 FB75:2005 (FB7C)     [ 3]         BRA    PSHNUM4
   69 FB77:8608            [ 2] PSHNUM3:        LDAA   #ILTOKERR
   70 FB79:7EEA EF         [ 3]         JMP    RPTRERR
   71 FB7C:DE1F            [ 4] PSHNUM4:        LDX    NUMSTACK     ; GET THE OPERAND STACK POINTER.
   72 FB7E:09              [ 3]         DEX                 ; MAKE ROOM ON THE STACK FOR NEW OPERAND.
   73 FB7F:09              [ 3]         DEX
   74 FB80:9C51            [ 5]         CPX    ENUMSTK      ; HAS THE STACK OVERFLOWED?
   75 FB82:2407 (FB8B)     [ 3]         BHS    PSHNUM5      ; NO. GO STACK THE VALUE.
   76 FB84:8617            [ 2]         LDAA   #MSTKOERR    ; YES.
   77 FB86:9718            [ 3]         STAA   ERRCODE
   78 FB88:7EEA EF         [ 3]         JMP    RPTRERR      ; GO REPORT THE ERROR.
   79 FB8B:DF1F            [ 4] PSHNUM5:        STX    NUMSTACK     ; SAVE THE STACK POINTER.
   80 FB8D:ED00            [ 5]         STD    0,X          ; PUT THE VALUE ON THE STACK.
   81 FB8F:39              [ 5]         RTS                 ; RETURN.
   82                           *
   83                           *
   84                           *        THIS SUBROUTINE CALCULATES BOTH THE BASE ADDRESS AND THE
   85                           *        SUBSCRIPT OF THE ARRAY VARIABLE THAT IS CURRENTLY POINTED TO BY
   86                           *        THE Y-REG. IT CHECKS TO SEE IF THE VARIABLE HAS BEEN DIMENTIONED
   87                           *        AND IF THE SUBSCRIPT IS IN RANGE. THE ROUTINE RETURNS WITH THE
   88                           *        ADDRESS OF THE ARRAY IN THE X-REG. & THE SUBSCRIPT IN THE D-REG.
   89                           *
   90 FB90:18EC 01         [ 6] CALCSUB:        LDD    1,Y          ; GET THE VARIABLE OFFSET ADDRESS.
   91 FB93:D308            [ 5]         ADDD   VARBEGIN     ; ADD IN THE START OF THE VARIABLE AREA.
   92 FB95:8F              [ 3]         XGDX                ; PUT ADDRESS INTO X.
   93 FB96:EE03            [ 5]         LDX    3,X          ; GET THE ACTUAL STORAGE ADDRESS.
   94                           *                             ; HAS THE ARRAY BEEN DIMENTIONED?
   95 FB98:2605 (FB9F)     [ 3]         BNE    CALCSUB2     ; YES. CONTINUE.
   96 FB9A:8618            [ 2]         LDAA   #UNDIMERR    ; NO. UNDIMENTIONED ARRAY REFERENCE.
   97 FB9C:7EEA EF         [ 3] CALCSUB1:       JMP    RPTRERR      ; GO REPORT THE ERROR.
   98 FB9F:C604            [ 2] CALCSUB2:       LDAB   #$4          ; SET POINTER TO START OF SUBSCRIPT EXPRESSION.
   99 FBA1:183A            [ 4]         ABY
  100 FBA3:3C              [ 4]         PSHX                ; SAVE THE POINTER TO THE ARRAY STORAGE AREA.
  101 FBA4:BDFB 12         [ 6]         JSR    DONEXP       ; GO GET THE SUBSCRIPT.
  102 FBA7:1808            [ 4]         INY                 ; BUMP IP PAST THE CLOSING PAREN OF THE SUBSCRIPT.
  103 FBA9:38              [ 5]         PULX                ; RESTORE X.
  104 FBAA:BDFB B9         [ 6]         JSR    PULNUM       ; GET SUBSCRIPT FROM THE OPERAND STACK.
  105 FBAD:1AA3 00         [ 7]         CPD    0,X          ; IS THE SUBSCRIPT WITHIN RANGE?
  106 FBB0:2304 (FBB6)     [ 3]         BLS    CALCSUB3     ; YES. CONTINUE.
  107 FBB2:8619            [ 2]         LDAA   #SUBORERR    ; NO. SUBSCRIPT OUT OF RANGE ERROR.
  108 FBB4:20E6 (FB9C)     [ 3]         BRA    CALCSUB1     ; GO REPORT IT.
  109 FBB6:08              [ 3] CALCSUB3:       INX                 ; BYPASS THE SUBSCRIPT LIMIT.
  110 FBB7:08              [ 3]         INX
  111 FBB8:39              [ 5]         RTS
  112                           *
  113                           *
  114 FBB9:3C              [ 4] PULNUM: PSHX                ; SAVE THE X-REG.
  115 FBBA:DE1F            [ 4]         LDX    NUMSTACK     ; GET THE OPERAND STACK POINTER.
  116 FBBC:EC00            [ 5]         LDD    0,X          ; GET THE OPERAND.
  117 FBBE:08              [ 3]         INX                 ; BUMP THE STACK POINTER.
  118 FBBF:08              [ 3]         INX
  119 FBC0:DF1F            [ 4]         STX    NUMSTACK     ; SAVE THE STACK POINTER.
  120 FBC2:38              [ 5]         PULX                ; RESTORE THE X-REG.
  121 FBC3:1A83 0000       [ 5]         CPD    #0           ; "TEST" THE OPERAND BEFORE WE RETURN.
  122 FBC7:39              [ 5]         RTS                 ; RETURN.
  123                           *
  124                           *
  125                           *        /***** chcknfun() *****/
  126                           *
  127                           *        /* checks for a numeric function and performs it if present */
  128                           *
  129 FBC8:8136            [ 2] CHKNFUN:        CMPA   #FUNCTFLG    ; IS THIS A FUNCTION CALL?
  130 FBCA:2701 (FBCD)     [ 3]         BEQ    CHKNFUN1     ; YES. GO DO THE FUNCTION.
  131 FBCC:39              [ 5]         RTS                 ; NO. JUST RETURN.
  132 FBCD:18A6 01         [ 5] CHKNFUN1:       LDAA   1,Y          ; GET THE FUNCTION CODE BYTE IN B.
  133 FBD0:4A              [ 2]         DECA                ; SUBTRACT 1 FOR INDEXING.
  134 FBD1:C603            [ 2]         LDAB   #3           ; BUMP THE IP.
  135 FBD3:183A            [ 4]         ABY                 ; POINT TO THE FIRST ELEMENT IN THE EXPRESSION.
  136 FBD5:16              [ 2]         TAB                 ; PUT THE FUNCTION NUMBER INTO B.
  137 FBD6:58              [ 2]         ASLB                ; MULT BY THE NUMBER OF BYTES/ADDRESS.
  138 FBD7:CEFB E5         [ 3]         LDX    #RNFUNCT     ; POINT TO THE FUNCTION ADDRESS TABLE.
  139 FBDA:3A              [ 3]         ABX                 ; POINT TO THE PROPER FUNCTION.
  140 FBDB:EE00            [ 5]         LDX    0,X          ; GET THE ADDRESS INTO X.
  141 FBDD:AD00            [ 6]         JSR    0,X          ; GO DO THE FUNCTION.
  142 FBDF:1808            [ 4]         INY                 ; PUT IP PAST THE CLOSING PAREN.
  143 FBE1:18A6 00         [ 5]         LDAA   0,Y          ; GET NEXT CHARACTER.
  144 FBE4:39              [ 5]         RTS                 ; RETURN.
  145                           *
  146                           *
  147      FBE5                 RNFUNCT:        EQU    *
  148 FBE5.FE20                         FDB    RFDIV
  149 FBE7.FE9E                         FDB    ICHRS        ; "ICHRS" BECAUSE IT'S ILLEGAL IN AN EXPRESSION.
  150 FBE9.FE45                         FDB    RADC
  151 FBEB.FDC8                         FDB    RABS
  152 FBED.FE76                         FDB    RRND
  153 FBEF.FDD9                         FDB    RSGN
  154 FBF1.FE9E                         FDB    ITAB         ; "ITAB" BECAUSE IT'S ILLEGAL IN AN EXPRESSION.
  155 FBF3.FDEB                         FDB    RCALL
  156 FBF5.FDF6                         FDB    RPEEK
  157 FBF7.FE05                         FDB    RFEEP        ; "EEP" AS A FUNCTION.
  158 FBF9.FE9E                         FDB    IHEX         ; "IHEX" BECAUSE IT'S ILLEGAL IN AN EXPRESSION.
  159 FBFB.FEAE                         FDB    RFPORTA
  160 FBFD.FEBD                         FDB    RFPORTB
  161 FBFF.FEC1                         FDB    RFPORTC
  162 FC01.FEC5                         FDB    RFPORTD
  163 FC03.FEC9                         FDB    RFPORTE
  164 FC05.FEA3                         FDB    RFTIME
  165 FC07.FE9E                         FDB    IHEX2        ; "IHEX2" BECAUSE IT'S ILLEGAL IN AN EXPRESSION.
  166 FC09.FEA7                         FDB    RFPACC
  167                           *
  168                           *
  169                           *        /***** chckee() *****/
  170                           *
  171                           *        /* if the current token is a semicolin, comma, colin, or space */
  172                           *        /* all pending operations on the math stack are performed and */
  173                           *        /* we return with the carry set */
  174                           *
  175      FC0B                 CHCKEE: EQU    *
  176 FC0B:8111            [ 2]         CMPA   #CPARNTOK    ; IS IT A CLOSED PAREN?
  177 FC0D:2708 (FC17)     [ 3]         BEQ    CHCKEE2      ; YES.
  178 FC0F:817A            [ 2]         CMPA   #MEOLTOK     ; IS IT ONE OF THE "EXPRESSION END" TOKENS?
  179 FC11:2402 (FC15)     [ 3]         BHS    CHCKEE1      ; YES.
  180 FC13:0C              [ 2]         CLC                 ; FLAG "NOT AT THE END OF EXPRESSION".
  181 FC14:39              [ 5]         RTS                 ; RETURN.
  182 FC15:8611            [ 2] CHCKEE1:        LDAA   #CPARNTOK    ; END OF EXPRESSION FOUND. PERFORM ALL PENDING
  183 FC17:8D02 (FC1B)     [ 6] CHCKEE2:        BSR    PSHOP        ; OPERATIONS.
  184 FC19:0D              [ 2]         SEC                 ; FLAG END OF EXPRESSION.
  185 FC1A:39              [ 5]         RTS
  186                           *
  187                           *
  188 FC1B:DE21            [ 4] PSHOP:  LDX    OPSTACK      ; GET THE OPERATOR STACK POINTER.
  189 FC1D:09              [ 3]         DEX                 ; DECREMENT THE STACK POINTER.
  190 FC1E:9C4D            [ 5]         CPX    EOPSTK       ; DID THE STACK OVERFLOW?
  191 FC20:2605 (FC27)     [ 3]         BNE    PSHOP1       ; NO. CONTINUE.
  192 FC22:8617            [ 2]         LDAA   #MSTKOERR    ; YES.
  193 FC24:7EEA EF         [ 3]         JMP    RPTRERR      ; GO REPORT THE ERROR.
  194 FC27:DF21            [ 4] PSHOP1: STX    OPSTACK
  195 FC29:A700            [ 4]         STAA   0,X          ; PUT IT ON THE STACK.
  196 FC2B:DE21            [ 4] PSHOP2: LDX    OPSTACK
  197 FC2D:A600            [ 4]         LDAA   0,X          ; GET THE NEW OPERATOR OFF THE TOP OF STACK.
  198 FC2F:8110            [ 2]         CMPA   #OPARNTOK    ; IS IT AN OPEN PAREN?
  199 FC31:2719 (FC4C)     [ 3]         BEQ    PSHOP5       ; YES. GO PUSH IT.
  200 FC33:E601            [ 4]         LDAB   1,X          ; GET THE PREVIOUS OPERATOR OFF THE STACK.
  201 FC35:C4F0            [ 2]         ANDB   #$F0         ; MASK ALL BUT THE PRECIDENCE VALUE.
  202 FC37:84F0            [ 2]         ANDA   #$F0         ; MASK ALL BUT THE OPERATOR PRECIDENCE.
  203 FC39:11              [ 2]         CBA                 ; IS THE PRECIDENCE OF THE CURRENT OPERATOR >=
  204                           *                             ; THE OPERATOR ON THE TOP OF THE STACK?
  205 FC3A:2210 (FC4C)     [ 3]         BHI    PSHOP5       ; NO. JUST GO PUSH IT ON THE STACK.
  206 FC3C:A601            [ 4]         LDAA   1,X          ; YES. GET THE PREVIOUS OPERATOR FROM THE STACK.
  207 FC3E:E600            [ 4]         LDAB   0,X          ; GET THE CURRENT OPERATOR FROM THE STACK.
  208 FC40:C111            [ 2]         CMPB   #CPARNTOK    ; IS THE CURRENT OPERATOR A CLOSED PAREN?
  209 FC42:2609 (FC4D)     [ 3]         BNE    PSHOP3       ; NO. CONTINUE.
  210 FC44:8110            [ 2]         CMPA   #OPARNTOK    ; YES. IS THE PREVIOUS OPERATOR AN OPEN PAREN?
  211 FC46:2605 (FC4D)     [ 3]         BNE    PSHOP3       ; NO. CONTINUE.
  212 FC48:08              [ 3]         INX                 ; YES. KNOCK BOTH OPERATORS OFF THE STACK.
  213 FC49:08              [ 3]         INX
  214 FC4A:DF21            [ 4]         STX    OPSTACK      ; SAVE THE STACK POINTER.
  215 FC4C:39              [ 5] PSHOP5: RTS                 ; RETURN.
  216 FC4D:E701            [ 4] PSHOP3: STAB   1,X          ; PUT IT ON THE STACK.
  217 FC4F:08              [ 3]         INX                 ; UPDATE THE STACK POINTER.
  218 FC50:DF21            [ 4]         STX    OPSTACK
  219 FC52:8D02 (FC56)     [ 6]         BSR    DOOP         ; GO DO THE OPERATION.
  220 FC54:20D5 (FC2B)     [ 3]         BRA    PSHOP2       ; GO TRY FOR ANOTHER OPERATION.
  221                           *
  222                           *
  223 FC56:8170            [ 2] DOOP:   CMPA   #$70         ; IS IT A UINARY OPERATOR?
  224 FC58:2507 (FC61)     [ 3]         BLO    DOOP1        ; NO. GO CHECK THE NEXT GROUP.
  225 FC5A:8070            [ 2]         SUBA   #$70         ; YES. SUBTRACT THE BASE VALUE OF THE GROUP.
  226 FC5C:CEFC A4         [ 3]         LDX    #HEIR7       ; POINT TO THE EXECUTION ADDRESS TABLE.
  227 FC5F:203C (FC9D)     [ 3]         BRA    DOOP7        ; GO DO THE OPERATION.
  228 FC61:8160            [ 2] DOOP1:  CMPA   #$60         ; IS IT THE "^" OPERATOR?
  229 FC63:2507 (FC6C)     [ 3]         BLO    DOOP2        ; NO. GO CHECK THE NEXT GROUP.
  230 FC65:8060            [ 2]         SUBA   #$60         ; YES. SUBTRACT THE BASE VALUE OF THE GROUP.
  231 FC67:CEFC AA         [ 3]         LDX    #HEIR6       ; POINT TO THE EXECUTION ADDRESS TABLE.
  232 FC6A:2031 (FC9D)     [ 3]         BRA    DOOP7        ; GO DO THE OPERATION.
  233 FC6C:8150            [ 2] DOOP2:  CMPA   #$50         ; IS IT MULTIPLY, DIVIDE, OR MOD?
  234 FC6E:2507 (FC77)     [ 3]         BLO    DOOP3        ; NO. GO CHECK THE NEXT GROUP.
  235 FC70:8050            [ 2]         SUBA   #$50         ; YES. SUBTRACT THE BASE VALUE OF THE GROUP.
  236 FC72:CEFC AC         [ 3]         LDX    #HEIR5       ; POINT TO THE EXECUTION ADDRESS TABLE.
  237 FC75:2026 (FC9D)     [ 3]         BRA    DOOP7        ; GO DO THE OPERATION.
  238 FC77:8140            [ 2] DOOP3:  CMPA   #$40         ; IS IT ADD OR SUBTRACT?
  239 FC79:2507 (FC82)     [ 3]         BLO    DOOP4        ; NO. GO CHECK THE NEXT GROUP.
  240 FC7B:8040            [ 2]         SUBA   #$40         ; YES. SUBTRACT THE BASE VALUE OF THE GROUP.
  241 FC7D:CEFC B2         [ 3]         LDX    #HEIR4       ; POINT TO THE EXECUTION ADDRESS TABLE.
  242 FC80:201B (FC9D)     [ 3]         BRA    DOOP7        ; GO DO THE OPERATION.
  243 FC82:8130            [ 2] DOOP4:  CMPA   #$30         ; IS IT A LOGICAL OPERATOR?
  244 FC84:2507 (FC8D)     [ 3]         BLO    DOOP5        ; NO. GO CHECK THE NEXT GROUP.
  245 FC86:8030            [ 2]         SUBA   #$30         ; YES. SUBTRACT THE BASE VALUE OF THE GROUP.
  246 FC88:CEFC B6         [ 3]         LDX    #HEIR3       ; POINT TO THE EXECUTION ADDRESS TABLE.
  247 FC8B:2010 (FC9D)     [ 3]         BRA    DOOP7        ; GO DO THE OPERATION.
  248 FC8D:8120            [ 2] DOOP5:  CMPA   #$20         ; IS IT AND, OR, OR EOR?
  249 FC8F:2507 (FC98)     [ 3]         BLO    DOOP6        ; NO. ERROR.
  250 FC91:8020            [ 2]         SUBA   #$20         ; YES. SUBTRACT THE BASE VALUE OF THE GROUP.
  251 FC93:CEFC C2         [ 3]         LDX    #HEIR2       ; POINT TO THE EXECUTION ADDRESS TABLE.
  252 FC96:2005 (FC9D)     [ 3]         BRA    DOOP7        ; GO DO THE OPERATION.
  253 FC98:8608            [ 2] DOOP6:  LDAA   #ILTOKERR    ; ILLEGAL OPERATOR TOKEN ENCOUNTERED.
  254 FC9A:7EEA EF         [ 3]         JMP    RPTRERR      ; GO REPORT THE ERROR.
  255 FC9D:16              [ 2] DOOP7:  TAB                 ; PUT THE OFFSET IN B.
  256 FC9E:58              [ 2]         ASLB                ; MULTIPLY THE OFFSET BY 2.
  257 FC9F:3A              [ 3]         ABX                 ; POINT TO THE ROUTINE ADDRESS.
  258 FCA0:EE00            [ 5]         LDX    0,X          ; GET THE ADDRESS.
  259 FCA2:6E00            [ 3]         JMP    0,X          ; GO DO THE OPERATION & RETURN.
  260                           *
  261                           *
  262      FCA4                 HEIR7:  EQU    *
  263 FCA4.FD80                         FDB    RINDIR
  264 FCA6.FD81                         FDB    RNOT
  265 FCA8.FD8A                         FDB    RNEG
  266      FCAA                 HEIR6:  EQU    *
  267 FCAA.FDC7                         FDB    RPWR
  268      FCAC                 HEIR5:  EQU    *
  269 FCAC.FD52                         FDB    RMULT
  270 FCAE.FD00                         FDB    RDIV
  271 FCB0.FD4C                         FDB    RMOD
  272      FCB2                 HEIR4:  EQU    *
  273 FCB2.FCEA                         FDB    RPLUS
  274 FCB4.FCF3                         FDB    RMINUS
  275      FCB6                 HEIR3:  EQU    *
  276 FCB6.FD92                         FDB    RLT
  277 FCB8.FD9D                         FDB    RGT
  278 FCBA.FDA3                         FDB    RLTEQ
  279 FCBC.FDA9                         FDB    RGTEQ
  280 FCBE.FDAF                         FDB    REQ
  281 FCC0.FDB5                         FDB    RNOTEQ
  282      FCC2                 HEIR2:  EQU    *
  283 FCC2.FCDF                         FDB    RAND
  284 FCC4.FCD4                         FDB    RORV
  285 FCC6.FCC8                         FDB    REOR
  286                           *
  287                           *
  288 FCC8:BDFB B9         [ 6] REOR:   JSR    PULNUM
  289 FCCB:DE1F            [ 4]         LDX    NUMSTACK
  290 FCCD:A800            [ 4]         EORA   0,X
  291 FCCF:E801            [ 4]         EORB   1,X
  292 FCD1:ED00            [ 5] REOR1:  STD    0,X
  293 FCD3:39              [ 5]         RTS
  294                           *
  295                           *
  296 FCD4:BDFB B9         [ 6] RORV:   JSR    PULNUM
  297 FCD7:DE1F            [ 4]         LDX    NUMSTACK
  298 FCD9:AA00            [ 4]         ORAA   0,X
  299 FCDB:EA01            [ 4]         ORAB   1,X
  300 FCDD:20F2 (FCD1)     [ 3]         BRA    REOR1
  301                           *
  302                           *
  303 FCDF:BDFB B9         [ 6] RAND:   JSR    PULNUM
  304 FCE2:DE1F            [ 4]         LDX    NUMSTACK
  305 FCE4:A400            [ 4]         ANDA   0,X
  306 FCE6:E401            [ 4]         ANDB   1,X
  307 FCE8:20E7 (FCD1)     [ 3]         BRA    REOR1
  308                           *
  309                           *
  310 FCEA:BDFB B9         [ 6] RPLUS:  JSR    PULNUM
  311 FCED:DE1F            [ 4]         LDX    NUMSTACK
  312 FCEF:E300            [ 6]         ADDD   0,X
  313 FCF1:20DE (FCD1)     [ 3]         BRA    REOR1
  314                           *
  315                           *
  316 FCF3:DE1F            [ 4] RMINUS: LDX    NUMSTACK
  317 FCF5:EC02            [ 5]         LDD    2,X
  318 FCF7:A300            [ 6]         SUBD   0,X
  319 FCF9:08              [ 3]         INX
  320 FCFA:08              [ 3]         INX
  321 FCFB:ED00            [ 5]         STD    0,X
  322 FCFD:DF1F            [ 4]         STX    NUMSTACK
  323 FCFF:39              [ 5]         RTS
  324                           *
  325                           *
  326 FD00:8D08 (FD0A)     [ 6] RDIV:   BSR    RDIVS        ; GO DO A SIGNED DIVIDE.
  327 FD02:BDFB B9         [ 6]         JSR    PULNUM       ; GET INTEGER RESULT OFF STACK.
  328 FD05:DE1F            [ 4]         LDX    NUMSTACK     ; POINT TO NUMERIC STACK.
  329 FD07:ED00            [ 5]         STD    0,X          ; OVERWRITE REMAINDER.
  330 FD09:39              [ 5]         RTS                 ; RETURN.
  331                           *
  332                           *
  333                           *
  334 FD0A:DE1F            [ 4] RDIVS:  LDX    NUMSTACK     ; POINT TO NUMERIC STACK.
  335 FD0C:A600            [ 4]         LDAA   0,X          ; GET UPPER BYTE OF DIVISOR.
  336 FD0E:A802            [ 4]         EORA   2,X          ; GET SIGN OF THE RESULT.
  337 FD10:36              [ 3]         PSHA                ; SAVE RESULT.
  338 FD11:EC00            [ 5]         LDD    0,X          ; GET DIVISOR OFF NUMERIC STACK. IS IT ZERO?
  339 FD13:2605 (FD1A)     [ 3]         BNE    RDIV1        ; NO. CONTINUE.
  340 FD15:861A            [ 2] RDIV2:  LDAA   #ZDIVERR     ; YES. GET DIVIDE BY ZERO ERROR.
  341 FD17:7EEA EF         [ 3]         JMP    RPTRERR      ; GO REPORT IT.
  342 FD1A:2A03 (FD1F)     [ 3] RDIV1:  BPL    RDIV3        ; IF POSITIVE IT'S OK.
  343 FD1C:BDFD 8A         [ 6]         JSR    RNEG         ; IF NOT MAKE IT POSITIVE.
  344 FD1F:6D02            [ 6] RDIV3:  TST    2,X          ; IS THE DIVIDEND NEGATIVE?
  345 FD21:2A09 (FD2C)     [ 3]         BPL    RDIV4        ; NO. CONTINUE.
  346 FD23:EC02            [ 5]         LDD    2,X          ; YES. GET THE NUMBER.
  347 FD25:43              [ 2]         COMA                ; NEGATE IT.
  348 FD26:53              [ 2]         COMB
  349 FD27:C300 01         [ 4]         ADDD   #1
  350 FD2A:ED02            [ 5]         STD    2,X          ; SAVE THE RESULT.
  351 FD2C:EC00            [ 5] RDIV4:  LDD    0,X          ; GET THE DIVISOR.
  352 FD2E:EE02            [ 5]         LDX    2,X          ; GET THE DIVIDEND.
  353 FD30:8F              [ 3]         XGDX                ; PUT THEM IN THE PROPER REGISTERS.
  354 FD31:02              [41]         IDIV                ; DO AN UNSIGNED DIVIDE.
  355 FD32:3C              [ 4]         PSHX                ; SAVE THE QUOTIENT.
  356 FD33:DE1F            [ 4]         LDX    NUMSTACK     ; POINT TO THE NUMERIC STACK.
  357 FD35:ED02            [ 5]         STD    2,X          ; SAVE THE REMAINDER.
  358                           *        PULD                 ; GET THE QUOTIENT.
  359 FD37:32              [ 4]         PULA
  360 FD38:33              [ 4]         PULB
  361 FD39:ED00            [ 5]         STD    0,X          ; PUT IT ON THE NUMERIC STACK.
  362 FD3B:32              [ 4]         PULA                ; GET THE SIGN OF THE RESULT.
  363 FD3C:4D              [ 2]         TSTA                ; SET THE CONDITION CODES.
  364 FD3D:2A0C (FD4B)     [ 3]         BPL    RDIV5        ; IF PLUS, RESULT OK AS IS.
  365 FD3F:BDFD 8A         [ 6]         JSR    RNEG         ; MAKE THE QUOTIENT NEGATIVE.
  366 FD42:EC02            [ 5]         LDD    2,X          ; GET THE REMAINDER.
  367 FD44:43              [ 2]         COMA                ; MAKE IT NEGATIVE.
  368 FD45:53              [ 2]         COMB
  369 FD46:C300 01         [ 4]         ADDD   #1
  370 FD49:ED02            [ 5]         STD    2,X          ; SAVE THE RESULT.
  371 FD4B:39              [ 5] RDIV5:  RTS                 ; RETURN.
  372                           *
  373                           *
  374 FD4C:8DBC (FD0A)     [ 6] RMOD:   BSR    RDIVS        ; GO GET QUOTIENT & REMAINDER.
  375 FD4E:BDFB B9         [ 6]         JSR    PULNUM       ; REMOVE INTEGER RESULT & LEAVE REMAINDER.
  376 FD51:39              [ 5]         RTS                 ; RETURN.
  377                           *
  378                           *
  379 FD52:183C            [ 5] RMULT:  PSHY
  380 FD54:DE1F            [ 4]         LDX    NUMSTACK
  381 FD56:A601            [ 4]         LDAA   1,X
  382 FD58:E603            [ 4]         LDAB   3,X
  383 FD5A:3D              [10]         MUL
  384                           *        PSHD
  385 FD5B:37              [ 3]         PSHB
  386 FD5C:36              [ 3]         PSHA
  387 FD5D:1830            [ 4]         TSY
  388 FD5F:A601            [ 4]         LDAA   1,X
  389 FD61:E602            [ 4]         LDAB   2,X
  390 FD63:3D              [10]         MUL
  391 FD64:18EB 00         [ 5]         ADDB   0,Y
  392 FD67:18E7 00         [ 5]         STAB   0,Y
  393 FD6A:A600            [ 4]         LDAA   0,X
  394 FD6C:E603            [ 4]         LDAB   3,X
  395 FD6E:3D              [10]         MUL
  396 FD6F:18EB 00         [ 5]         ADDB   0,Y
  397 FD72:18E7 00         [ 5]         STAB   0,Y
  398 FD75:08              [ 3]         INX
  399 FD76:08              [ 3]         INX
  400                           *        PULD
  401 FD77:32              [ 4]         PULA
  402 FD78:33              [ 4]         PULB
  403 FD79:ED00            [ 5]         STD    0,X
  404 FD7B:DF1F            [ 4]         STX    NUMSTACK
  405 FD7D:1838            [ 6]         PULY
  406 FD7F:39              [ 5]         RTS
  407                           *
  408                           *
  409      FD80                 RINDIR: EQU    *
  410 FD80:39              [ 5]         RTS
  411                           *
  412                           *
  413      FD81                 RNOT:   EQU    *
  414 FD81:DE1F            [ 4]         LDX    NUMSTACK
  415 FD83:EC00            [ 5]         LDD    0,X
  416 FD85:43              [ 2]         COMA
  417 FD86:53              [ 2]         COMB
  418 FD87:ED00            [ 5]         STD    0,X
  419 FD89:39              [ 5]         RTS
  420                           *
  421                           *
  422      FD8A                 RNEG:   EQU    *
  423 FD8A:8DF5 (FD81)     [ 6]         BSR    RNOT
  424 FD8C:C300 01         [ 4]         ADDD   #1
  425 FD8F:ED00            [ 5]         STD    0,X
  426 FD91:39              [ 5]         RTS
  427                           *
  428                           *
  429      FD92                 RLT:    EQU    *
  430 FD92:8D27 (FDBB)     [ 6]         BSR    CMPNUM
  431 FD94:2C02 (FD98)     [ 3]         BGE    RLT1
  432 FD96:6C03            [ 6] RLT2:   INC    3,X
  433 FD98:08              [ 3] RLT1:   INX
  434 FD99:08              [ 3]         INX
  435 FD9A:DF1F            [ 4]         STX    NUMSTACK
  436 FD9C:39              [ 5]         RTS
  437                           *
  438                           *
  439      FD9D                 RGT:    EQU    *
  440 FD9D:8D1C (FDBB)     [ 6]         BSR    CMPNUM
  441 FD9F:2FF7 (FD98)     [ 3]         BLE    RLT1
  442 FDA1:20F3 (FD96)     [ 3]         BRA    RLT2
  443                           *
  444                           *
  445      FDA3                 RLTEQ:  EQU    *
  446 FDA3:8D16 (FDBB)     [ 6]         BSR    CMPNUM
  447 FDA5:2EF1 (FD98)     [ 3]         BGT    RLT1
  448 FDA7:20ED (FD96)     [ 3]         BRA    RLT2
  449                           *
  450                           *
  451      FDA9                 RGTEQ:  EQU    *
  452 FDA9:8D10 (FDBB)     [ 6]         BSR    CMPNUM
  453 FDAB:2DEB (FD98)     [ 3]         BLT    RLT1
  454 FDAD:20E7 (FD96)     [ 3]         BRA    RLT2
  455                           *
  456                           *
  457      FDAF                 REQ:    EQU    *
  458 FDAF:8D0A (FDBB)     [ 6]         BSR    CMPNUM
  459 FDB1:26E5 (FD98)     [ 3]         BNE    RLT1
  460 FDB3:20E1 (FD96)     [ 3]         BRA    RLT2
  461                           *
  462                           *
  463      FDB5                 RNOTEQ: EQU    *
  464 FDB5:8D04 (FDBB)     [ 6]         BSR    CMPNUM
  465 FDB7:27DF (FD98)     [ 3]         BEQ    RLT1
  466 FDB9:20DB (FD96)     [ 3]         BRA    RLT2
  467                           *
  468                           *
  469      FDBB                 CMPNUM: EQU    *
  470 FDBB:DE1F            [ 4]         LDX    NUMSTACK
  471 FDBD:EC02            [ 5]         LDD    2,X
  472 FDBF:6F02            [ 6]         CLR    2,X
  473 FDC1:6F03            [ 6]         CLR    3,X
  474 FDC3:1AA3 00         [ 7]         CPD    0,X
  475 FDC6:39              [ 5]         RTS
  476                           *
  477                           *
  478      FDC7                 RPWR:   EQU    *
  479 FDC7:39              [ 5]         RTS
  480                           *
  481                           *
  482      FDC8                 RABS:   EQU    *
  483 FDC8:BDFB 12         [ 6]         JSR    DONEXP
  484 FDCB:DE1F            [ 4]         LDX    NUMSTACK
  485 FDCD:EC00            [ 5]         LDD    0,X
  486 FDCF:2A05 (FDD6)     [ 3]         BPL    RABS1
  487 FDD1:43              [ 2] RABS2:  COMA
  488 FDD2:53              [ 2]         COMB
  489 FDD3:C300 01         [ 4]         ADDD   #1
  490 FDD6:ED00            [ 5] RABS1:  STD    0,X
  491 FDD8:39              [ 5]         RTS
  492                           *
  493                           *
  494      FDD9                 RSGN:   EQU    *
  495 FDD9:BDFB 12         [ 6]         JSR    DONEXP
  496 FDDC:DE1F            [ 4]         LDX    NUMSTACK
  497 FDDE:EC00            [ 5]         LDD    0,X
  498 FDE0:27F4 (FDD6)     [ 3]         BEQ    RABS1
  499 FDE2:CC00 01         [ 3]         LDD    #1
  500 FDE5:6D00            [ 6]         TST    0,X
  501 FDE7:2AED (FDD6)     [ 3]         BPL    RABS1
  502 FDE9:20E6 (FDD1)     [ 3]         BRA    RABS2
  503                           *
  504                           *
  505      FDEB                 RCALL:  EQU    *
  506 FDEB:BDFB 12         [ 6]         JSR    DONEXP
  507 FDEE:DE1F            [ 4]         LDX    NUMSTACK
  508 FDF0:EE00            [ 5]         LDX    0,X
  509 FDF2:AD00            [ 6]         JSR    0,X
  510 FDF4:200A (FE00)     [ 3]         BRA    RPEEK1
  511                           *
  512                           *
  513      FDF6                 RPEEK:  EQU    *
  514 FDF6:BDFB 12         [ 6]         JSR    DONEXP
  515 FDF9:DE1F            [ 4]         LDX    NUMSTACK
  516 FDFB:EE00            [ 5]         LDX    0,X
  517 FDFD:E600            [ 4]         LDAB   0,X
  518 FDFF:4F              [ 2]         CLRA
  519 FE00:DE1F            [ 4] RPEEK1: LDX    NUMSTACK
  520 FE02:ED00            [ 5]         STD    0,X
  521 FE04:39              [ 5]         RTS
  522                           *
  523                           *
  524      FE05                 RFEEP:  EQU    *
  525 FE05:BDFB 12         [ 6]         JSR    DONEXP       ; GO GET SUBSCRIPT OF EEPROM ARRAY.
  526 FE08:DE1F            [ 4]         LDX    NUMSTACK     ; POINT TO THE OPERAND STACK.
  527 FE0A:EC00            [ 5]         LDD    0,X          ; GET THE SUBSCRIPT OFF THE STACK.
  528 FE0C:1A83 00FF       [ 5]         CPD    #MAXEESUB    ; IS IT WITHIN THE LIMIT?
  529 FE10:2305 (FE17)     [ 3]         BLS    RFEEP1       ; YES. GO GET THE VALUE.
  530 FE12:8628            [ 2]         LDAA   #EESUBERR    ; NO. SUBSCRIPT ERROR.
  531 FE14:7EEA EF         [ 3] RFEEP2: JMP    RPTRERR      ; REPORT THE ERROR.
  532 FE17:05              [ 3] RFEEP1: LSLD                ; MULT THE SUBSCRIPT BY 2.
  533 FE18:C3B6 00         [ 4]         ADDD   #EEPBASAD    ; ADD IN THE BASE ADDRESS OF THE EEPROM ADDRESS.
  534 FE1B:8F              [ 3]         XGDX                ; PUT THE ADDRESS IN X.
  535 FE1C:EC00            [ 5]         LDD    0,X          ; GET THE DATA.
  536 FE1E:20E0 (FE00)     [ 3]         BRA    RPEEK1       ; GO STEAL SOME CODE.
  537                           *
  538                           *
  539      FE20                 RFDIV:  EQU    *
  540 FE20:BDFB 12         [ 6]         JSR    DONEXP       ; GO EVALUATE THE DIVIDEND EXPRESSION.
  541 FE23:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES.
  542 FE26:1808            [ 4]         INY                 ; PASS UP THE COMMA.
  543 FE28:BDF1 CA         [ 6]         JSR    RSKIPSPC     ; SKIP SPACES AFTER THE COMMA.
  544 FE2B:BDFB 12         [ 6]         JSR    DONEXP       ; EVALUATE THE DIVISOR EXPRESSION.
  545 FE2E:DE1F            [ 4]         LDX    NUMSTACK     ; POINT TO OPERAND STACK.
  546 FE30:EC02            [ 5]         LDD    2,X          ; GET THE DIVIDEND.
  547 FE32:EE00            [ 5]         LDX    0,X          ; GET THE DIVISOR.
  548 FE34:03              [41]         FDIV                ; DO THE FRACTIONAL DIVIDE.
  549 FE35:2804 (FE3B)     [ 3]         BVC    RFDIV1       ; ALL IS OK IF V=0. (IX > D).
  550 FE37:862C            [ 2]         LDAA   #OVDV0ERR    ; ERROR. EITHER OVERFLOW OR /0 ERROR.
  551 FE39:20D9 (FE14)     [ 3] RFDIV2: BRA    RFEEP2       ; GO REPORT IT.
  552 FE3B:8F              [ 3] RFDIV1: XGDX                ; PUT QUOTIENT IN D.
  553 FE3C:DE1F            [ 4]         LDX    NUMSTACK     ; POINT TO OPERAND STACK.
  554 FE3E:08              [ 3]         INX                 ; REMOVE DIVISOR FROM STACK.
  555 FE3F:08              [ 3]         INX
  556 FE40:ED00            [ 5]         STD    0,X          ; PUT QUITIENT ON OPERAND STACK.
  557 FE42:DF1F            [ 4]         STX    NUMSTACK     ; SAVE NEW VALUE OF STACK POINTER.
  558 FE44:39              [ 5]         RTS                 ; RETURN.
  559                           *
  560                           *
  561      FE45                 RADC:   EQU    *
  562 FE45:BDFB 12         [ 6]         JSR    DONEXP       ; GO GET THE CHANNEL NUMBER TO CONVERT.
  563 FE48:DE1F            [ 4]         LDX    NUMSTACK     ; POINT TO THE RESULT.
  564 FE4A:EC00            [ 5]         LDD    0,X          ; GET THE CHANNEL NUMBER.
  565 FE4C:2B06 (FE54)     [ 3]         BMI    RADC4        ; NEGATIVE CHANNEL NUMBERS ARE ILLEGAL.
  566 FE4E:1A83 0007       [ 5]         CPD    #7           ; IS IT A VALID CHANNEL NUMBER?
  567 FE52:2304 (FE58)     [ 3]         BLS    RADC1        ; YES. GO CONVERT IT.
  568 FE54:862D            [ 2] RADC4:  LDAA   #INVCHERR    ; NO. INVALID CHANNEL NUMBER.
  569 FE56:20E1 (FE39)     [ 3]         BRA    RFDIV2       ; GO REPORT THE ERROR.
  570 FE58:DE61            [ 4] RADC1:  LDX    IOBaseV
  571 FE5A:E730            [ 4]         STAB   ADCTL,X      ; START THE CONVERSION ON THE SELECTED.
  572 FE5C:6D30            [ 6] RADC2:  TST    ADCTL,X      ; IS THE CONVERSION COMPLETE?
  573 FE5E:2AFC (FE5C)     [ 3]         BPL    RADC2        ; NO. WAIT FOR 4 CONVERSIONS ON 1 CHANNEL.
  574 FE60:4F              [ 2]         CLRA                ; YES. NOW AVERAGE THE 4 CONVERSIONS.
  575 FE61:E631            [ 4]         LDAB   ADR1,X       ; GET 1ST RESULT.
  576 FE63:EB32            [ 4]         ADDB   ADR2,X       ; ADD IN THE SECOND.
  577 FE65:8900            [ 2]         ADCA   #0           ; ADD IN CARRY.
  578 FE67:EB33            [ 4]         ADDB   ADR3,X       ; ADD IN THE THIRD.
  579 FE69:8900            [ 2]         ADCA   #0           ; ADD IN CARRY.
  580 FE6B:EB34            [ 4]         ADDB   ADR4,X       ; ADD IN THE FOURTH.
  581 FE6D:8900            [ 2]         ADCA   #0           ; ADD IN CARRY.
  582 FE6F:04              [ 3]         LSRD                ; DIVIDE RESULT BY 4.
  583 FE70:04              [ 3]         LSRD
  584 FE71:DE1F            [ 4]         LDX    NUMSTACK     ; POINT TO THE RESULT.
  585 FE73:ED00            [ 5]         STD    0,X          ; PUT THE RESULT ON THE OPERAND STACK.
  586 FE75:39              [ 5]         RTS                 ; RETURN.
  587                           *
  588                           *
  589      FE76                 RRND:   EQU    *
  590 FE76:BDFB 12         [ 6]         JSR    DONEXP       ; GO GET FUNCTION ARGUMENT.
  591 FE79:DE1F            [ 4]         LDX    NUMSTACK     ; GET ARGUMENT OFF STACK. GET NEW RANDOM NUMBER?
  592 FE7B:EC00            [ 5]         LDD    0,X
  593 FE7D:270C (FE8B)     [ 3]         BEQ    RRND2        ; YES. GO GET NEXT RANDOM NUMBER IN THE SERIES.
  594 FE7F:2B04 (FE85)     [ 3]         BMI    RRND1        ; IF NEG., START A NEW SERIES.
  595 FE81:DC35            [ 4]         LDD    RANDOM       ; IF POSITIVE, GET LAST RANDOM NUMBER.
  596 FE83:2015 (FE9A)     [ 3]         BRA    RRND3        ; RETURN.
  597 FE85:DE61            [ 4] RRND1:  LDX    IOBaseV
  598 FE87:EC0E            [ 5]         LDD    TCNT,X       ; USE THE TIMER VALUE AS THE NEW SEED.
  599 FE89:DD35            [ 4]         STD    RANDOM       ; SAVE IT.
  600 FE8B:DC35            [ 4] RRND2:  LDD    RANDOM       ; GET PREVIOUS RANDOM NUMBER (USE AS SEED).
  601 FE8D:58              [ 2]         ASLB                ; DO SOME OPERATIONS.
  602 FE8E:1B              [ 2]         ABA
  603 FE8F:D636            [ 3]         LDAB   RANDOM+1
  604 FE91:05              [ 3]         ASLD
  605 FE92:05              [ 3]         ASLD
  606 FE93:D335            [ 5]         ADDD   RANDOM
  607 FE95:C336 19         [ 4]         ADDD   #$3619
  608 FE98:DD35            [ 4]         STD    RANDOM
  609 FE9A:04              [ 3] RRND3:  LSRD                ; MAKE THE NUMBER POSITIVE.
  610 FE9B:ED00            [ 5]         STD    0,X          ; PUT THE NUMBER ON THE STACK.
  611 FE9D:39              [ 5]         RTS                 ; RETURN.
  612                           *
  613                           *
  614      FE9E                 ITAB:   EQU    *
  615      FE9E                 ICHRS:  EQU    *
  616      FE9E                 IHEX:   EQU    *
  617      FE9E                 IHEX2:  EQU    *
  618 FE9E:8629            [ 2]         LDAA   #PRFUNERR        ; THESE FUNCTIONS MUST BE USED ONLY IN
  619 FEA0:7EEA EF         [ 3]         JMP    RPTRERR  ; PRINT STATEMENTS.
  620                           *
  621                           *
  622 FEA3:DC38            [ 4] RFTIME: LDD    TIMEREG      ; GET THE TIME IN SECONDS.
  623 FEA5:200F (FEB6)     [ 3]         BRA    RFPORTA2     ; GO PUT NUMBER ON THE STACK.
  624                           *
  625                           *
  626 FEA7:DE61            [ 4] RFPACC: LDX    IOBaseV
  627 FEA9:E627            [ 4]         LDAB   PACNT,X      ; GET THE CURRENT VALUE OF THE PULSE ACCUMULATOR.
  628 FEAB:4F              [ 2]         CLRA
  629 FEAC:2008 (FEB6)     [ 3]         BRA    RFPORTA2     ; GO PUT THE NUMBER ON THE STACK.
  630                           *
  631                           *
  632      FEAE                 RFPORTA:        EQU    *
  633 FEAE:C600            [ 2]         LDAB   #PORTAIO      ; GET DATA FROM PORTA.
  634 FEB0:DE61            [ 4] RFPORTA1:       LDX    IOBaseV
  635 FEB2:3A              [ 3]         ABX
  636 FEB3:E600            [ 4]         LDAB   0,X
  637 FEB5:4F              [ 2]         CLRA                ; CLEAR UPPER BYTE OF WORD.
  638 FEB6:1809            [ 4] RFPORTA2:       DEY                 ; DECREMENT IP BECAUSE CALLING ROUTINE WILL TRY
  639 FEB8:1809            [ 4]         DEY                 ; TO BUMP IT PAST AN OPENING & CLOSING PAREN
  640                           *                             ; WHICH ISN'T THERE.
  641 FEBA:7EFB 7C         [ 3]         JMP    PSHNUM4      ; GO PUSH VALUE ON OPERAND STACK & RETURN.
  642                           *
  643      FEBD                 RFPORTB:        EQU    *
  644 FEBD:C604            [ 2]         LDAB   #PORTBIO
  645 FEBF:20EF (FEB0)     [ 3]         BRA    RFPORTA1
  646                           *
  647      FEC1                 RFPORTC:        EQU    *
  648 FEC1:C603            [ 2]         LDAB   #PORTCIO
  649 FEC3:20EB (FEB0)     [ 3]         BRA    RFPORTA1
  650                           *
  651      FEC5                 RFPORTD:        EQU    *
  652 FEC5:C608            [ 2]         LDAB   #PORTDIO
  653 FEC7:20E7 (FEB0)     [ 3]         BRA    RFPORTA1
  654                           *
  655      FEC9                 RFPORTE:        EQU    *
  656 FEC9:C60A            [ 2]         LDAB   #PORTEIO
  657 FECB:20E3 (FEB0)     [ 3]         BRA    RFPORTA1
  658                           *
  659                           *
*** END   INCLUDE FILE: REXPRES.ASM *** (RESUMING FILE: BASIC11.ASM)
   20                           ;        opt    lis
   21                           #Include  'IOPKG.Asm'
*** BEGIN INCLUDE FILE: IOPKG.ASM ***
    1                           *        title    IOPKG
    2                           *        page
    3                           *
    4                           *
    5      FECD                 OUTBYTE:        EQU    *
    6 FECD:7C00 1E         [ 6]         INC    PRINTPOS     ; INCREMENT THE CURRENT PRINT POSITION.
    7 FED0:37              [ 3]         PSHB                ; SAVE THE B-REG.
    8 FED1:3C              [ 4]         PSHX                ; SAVE THE X-REG.
    9 FED2:CE00 B4         [ 3]         LDX    #OUTABLE     ; POINT TO THE OUTPUT VECTOR TABLE.
   10 FED5:D637            [ 3] OUTBYTE1:       LDAB   DEVNUM       ; GET THE CURRENT DEVICE NUMBER.
   11 FED7:58              [ 2]         ASLB                ; MULT BY 2.
   12 FED8:3A              [ 3]         ABX                 ; POINT TO THE ADDRESS OF THE OUTPUT ROUTINE.
   13 FED9:EE00            [ 5]         LDX    0,X          ; GET THE ADDRESS. HAS THE VECTOR BEEN INITALIZED?
   14 FEDB:2608 (FEE5)     [ 3]         BNE    OUTBYTE2     ; YES. GO OUTPUT THE CHARACTER.
   15 FEDD:7F00 37         [ 6]         CLR    DEVNUM       ; NO. RESET TO DEVICE #0.
   16 FEE0:8631            [ 2]         LDAA   #UNINIERR    ; GO REPORT AN UNINITALIZED I/O VECTOR ERROR.
   17 FEE2:7EEA EF         [ 3]         JMP    RPTRERR
   18 FEE5:AD00            [ 6] OUTBYTE2:       JSR    0,X          ; GO OUTPUT THE CHARACTER.
   19 FEE7:38              [ 5]         PULX                ; RESTORE X.
   20 FEE8:33              [ 4]         PULB                ; RESTORE B.
   21 FEE9:39              [ 5]         RTS                 ; RETURN.
   22                           *
   23      FEEA                 INBYTE: EQU    *
   24 FEEA:37              [ 3]         PSHB                ; SAVE THE B-REG.
   25 FEEB:3C              [ 4]         PSHX                ; SAVE THE X-REG.
   26 FEEC:CE00 A4         [ 3]         LDX    #INTABLE     ; POINT TO THE INPUT VECTOR TABLE.
   27 FEEF:20E4 (FED5)     [ 3]         BRA    OUTBYTE1     ; GO USE THE SAME CODE AS OUTBYTE.
   28                           *
   29                           *
   30                                   $if      * > $FF00
   32                                   $endif
   33                           *
   34                           *
   35      FF00                         ORG     $FF00
   36                           *
   37                           *
   38 FF00:8D0D (FF0F)     [ 6] ACIAIN: BSR    ACIAINNE     ; GO GET CHARACTER FROM ACIA, NO ECHO.
   39                           *                             ; NOW, FALL THROUGH TO ACIAOUT TO ECHO CHARACTER.
   40                           *
   41                           *
   42 FF02:36              [ 3] ACIAOUT:        PSHA                ; SAVE THE CHARACTER TO OUTPUT.
   43 FF03:B698 00         [ 4] ACIAOUT1:       LDAA   ACIAST       ; GET THE ACIA STATUS.
   44 FF06:8502            [ 2]         BITA   #$02         ; IS THE XMIT DATA REGISTER EMPTY?
   45 FF08:27F9 (FF03)     [ 3]         BEQ    ACIAOUT1     ; NO. WAIT TILL IT IS.
   46 FF0A:32              [ 4]         PULA                ; YES. GET BYTE TO SEND.
   47 FF0B:B798 01         [ 4]         STAA   ACIADT       ; SEND IT.
   48 FF0E:39              [ 5]         RTS                 ; RETURN.
   49                           *
   50                           *
   51                           *
   52                           *
   53                           *
   54                           *
   55 FF0F:B698 00         [ 4] ACIAINNE:       LDAA   ACIAST       ; GET THE ACIA STATUS.
   56 FF12:8501            [ 2]         BITA   #$01         ; HAS A CHARACTER BEEN RECIEVED?
   57 FF14:27F9 (FF0F)     [ 3]         BEQ    ACIAINNE     ; NO. WAIT TILL WE HAVE ONE.
   58 FF16:B698 01         [ 4]         LDAA   ACIADT       ; YES. GET THE CHARACTER.
   59 FF19:39              [ 5]         RTS                 ; RETURN.
   60                           *
   61      FF1A                 ACIASTAT:       EQU    *
   62 FF1A:36              [ 3]         PSHA                ; SAVE THE A-REG.
   63 FF1B:B698 00         [ 4]         LDAA   ACIAST       ; GET THE ACIA STATUS.
   64 FF1E:8501            [ 2]         BITA   #$01         ; CHECK FOR A CHARACTER.
   65 FF20:32              [ 4]         PULA                ; RESTORE A.
   66 FF21:39              [ 5]         RTS                 ; RETURN.
   67                           *
   68                           *
   69                           
   70                           
   71      FF22                 SCIIN:  EQU    *
   72 FF22:3C              [ 4]         PSHX            ; Save the index register.
   73 FF23:DE61            [ 4]         LDX    IOBaseV
   74 FF25:A62E            [ 4] SCIIN1: LDAA   SCSR,X       ; GET SCI STATUS.
   75 FF27:8420            [ 2]         ANDA   #$20         ; HAS A CHARACTER BEEN RECIEVED?
   76 FF29:27FA (FF25)     [ 3]         BEQ    SCIIN1       ; NO. WAIT FOR CHARACTER TO BE RECIEVED.
   77 FF2B:A62F            [ 4]         LDAA   SCDR,X       ; GET THE CHARACTER.
   78 FF2D:38              [ 5]         PULX            ; Restore X.
   79                           
   80                           * JKJ: Fall thru to echo the char...
   81                           *       RTS                 ; RETURN.
   82                           *
   83                           *
   84                           
   85      FF2E                 SCIOUT: EQU    *
   86 FF2E:3C              [ 4]         PSHX            ; Save the index register.
   87 FF2F:DE61            [ 4]         LDX    IOBaseV
   88 FF31:36              [ 3]         PSHA               ; SAVE THE CHARACTER TO SEND.
   89 FF32:A62E            [ 4] SCIOUT1:        LDAA   SCSR,X      ; GET THE SCI STATUS.
   90 FF34:8580            [ 2]         BITA   #$80        ; HAS THE LAST CHARACTER BEEN SHIFTED OUT?
   91 FF36:27FA (FF32)     [ 3]         BEQ    SCIOUT1     ; NO. WAIT TILL IT HAS.
   92 FF38:32              [ 4]         PULA               ; RESTORE CHARACTER TO SEND.
   93 FF39:A72F            [ 4]         STAA   SCDR,X      ; SEND THE CHARACTER.
   94 FF3B:38              [ 5]         PULX            ; Restore X.
   95 FF3C:39              [ 5]         RTS                ; RETURN.
   96                           *
   97                           *
   98      FF3D                 SCISTAT:        EQU    *
   99 FF3D:3C              [ 4]         PSHX            ; Save the index register.
  100 FF3E:DE61            [ 4]         LDX    IOBaseV
  101 FF40:36              [ 3]         PSHA                ; SAVE THE A-REG.
  102 FF41:A62E            [ 4]         LDAA   SCSR,X       ; GET THE SCI STATUS.
  103 FF43:8520            [ 2]         BITA   #$20         ; CHECK TO SEE IF A CHARACTER HAS BEEN RECIEVED.
  104 FF45:32              [ 4]         PULA                ; RESTORE STATUS.
  105 FF46:38              [ 5]         PULX            ; Restore X.
  106 FF47:39              [ 5]         RTS                 ; RETURN W/ STATUS.
  107                           *
  108                           *
  109      FF48                 IODevInit:
  110                           ;JKJ No ACIA. Set PORTC as output for starters.
  111                           ;        BSR     InitACIA
  112 FF48:8D19 (FF63)     [ 6]         BSR     InitSCI
  113 FF4A:3C              [ 4]         PSHX
  114 FF4B:DE61            [ 4]         LDX     IOBaseV
  115 FF4D:86FF            [ 2]         LDAA    #$FF
  116 FF4F:A707            [ 4]         STAA    DDRC,X
  117 FF51:38              [ 5]         PULX
  118 FF52:867E            [ 2]         LDAA    #JMPOP
  119 FF54:979E            [ 3]         STAA    CONSTAT     ; INITIALIZE THE CONSOLE STATUS VECTOR.
  120 FF56:97A1            [ 3]         STAA    INCONNE     ; INITIALIZE THE INPUT FROM CONSOLE NO ECHO VECT.
  121 FF58:CCFF 3D         [ 3]         LDD     #SCISTAT    ; CONSOLE IS INITIALLY THE SCI.
  122 FF5B:DD9F            [ 4]         STD     CONSTAT+1
  123 FF5D:CCFF 22         [ 3]         LDD     #SCIIN      ; GET BYTE FROM SCI, DON'T ECHO IT.
  124 FF60:DDA2            [ 4]         STD     INCONNE+1
  125 FF62:39              [ 5]         RTS
  126                           *
  127                           *
  128      FF63                 INITSCI:        EQU    *
  129 FF63:3C              [ 4]         PSHX            ; Save the index register.
  130 FF64:DE61            [ 4]         LDX    IOBaseV
  131 FF66:8630            [ 2]         LDAA   #$30        ; SET BAUD RATE TO 9600.
  132 FF68:A72B            [ 4]         STAA   BAUD,X
  133 FF6A:6F2C            [ 6]         CLR    SCCR1,X     ; SET FOR 8 BIT OPERATION, DISABLE WAKEUP.
  134 FF6C:860C            [ 2]         LDAA   #$0C        ; ENABLE THE TRANSMITER & RECEIVER.
  135 FF6E:A72D            [ 4]         STAA   SCCR2,X
  136 FF70:8611            [ 2]         LDAA   #$11        ; GET THE XON CHARACTER (CONTROL-Q).
  137 FF72:9743            [ 3]         STAA   XONCH       ; INITALIZE THE XON REGISTER.
  138 FF74:8613            [ 2]         LDAA   #$13        ; GET THE XOFF CHARACTER (CONTROL-S).
  139 FF76:9744            [ 3]         STAA   XOFFCH      ; INITALIZE THE XOFF CHARACTER.
  140 FF78:38              [ 5]         PULX
  141 FF79:39              [ 5]         RTS                ; RETURN.
  142                           *
  143                           *
  144 FF7A:8613            [ 2] INITACIA:       LDAA   #$13         ; VALUE TO RESET THE ACIA.
  145 FF7C:B798 00         [ 4]         STAA   ACIAST       ; RESET IT.
  146 FF7F:8656            [ 2]         LDAA   #$56         ; SET /64, RTS=HI, 8-DATA/1 STOP
  147 FF81:B798 00         [ 4]         STAA   ACIAST
  148 FF84:39              [ 5]         RTS                 ; RETURN.
  149                           *
  150                           *
  151                           *
  152      FF85                 PROUT:  EQU    *            ; SEND A CHARACTER TO THE PRINTER.
  153 FF85:8DB6 (FF3D)     [ 6]         BSR    SCISTAT      ; WAS AN "X-OFF" RECIEVED?
  154 FF87:270E (FF97)     [ 3]         BEQ    PROUT1       ; NO. GO SEND THE CHARACTER.
  155 FF89:36              [ 3]         PSHA                ; SAVE THE CHARACTER TO SEND.
  156 FF8A:8D96 (FF22)     [ 6]         BSR    SCIIN        ; YES. GO RESET THE SCI RECEIVER STATUS.
  157 FF8C:9144            [ 3]         CMPA   XOFFCH       ; WAS IT AN XOFF?
  158 FF8E:2606 (FF96)     [ 3]         BNE    PROUT2       ; NO. SO GO SEND THE CHARACTER.
  159 FF90:8D90 (FF22)     [ 6] PROUT3: BSR    SCIIN        ; GO WAIT FOR AN "X-ON" CHARACTER.
  160 FF92:9143            [ 3]         CMPA   XONCH        ; IS IT AN X-ON CHARACTER?
  161 FF94:26FA (FF90)     [ 3]         BNE    PROUT3       ; NO. GO WAIT FOR AN X-ON CHARACTER.
  162 FF96:32              [ 4] PROUT2: PULA                ; GET THE CHARACTER TO SEND.
  163 FF97:2095 (FF2E)     [ 3] PROUT1: BRA    SCIOUT       ; SEND THE CHARACTER TO THE PRINTER & RETURN.
  164                           *
  165                           *
*** END   INCLUDE FILE: IOPKG.ASM *** (RESUMING FILE: BASIC11.ASM)
   22                           #Include  'VECTORS.Asm'
*** BEGIN INCLUDE FILE: VECTORS.ASM ***
    1                           *         title  Config/Reset/Interrupt Vectors
    2                           *         page
    3                           
    4                                    $if     * > $ffa0
    6                                    $endif
    7                           *
    8                           *
    9                           *
   10      FFA0                         org     $ffa0
   11 FFA0.FF22                 IOVects fdb     SCIIN
   12 FFA2.0000                         fdb     0
   13 FFA4.0000                         fdb     0
   14 FFA6.0000                         fdb     0
   15 FFA8.0000                         fdb     0
   16 FFAA.0000                         fdb     0
   17 FFAC.0000                         fdb     0
   18 FFAE.0000                         fdb     0
   19                           
   20 FFB0.FF2E                         fdb     SCIOUT
   21 FFB2.0000                         fdb     0
   22 FFB4.0000                         fdb     0
   23 FFB6.0000                         fdb     0
   24 FFB8.0000                         fdb     0
   25 FFBA.0000                         fdb     0
   26 FFBC.0000                         fdb     0
   27 FFBE.0000                         fdb     0
   28                           *
   29                           *
   30      FFC0                         org     $ffc0
   31 FFC0.8000                 RAMStart:       fdb     $8000           ; starting address of system RAM.
   32 FFC2.2000                 RAMSize:        fdb     $2000           ; size of BASIC11 RAM Buffer.
   33 FFC4.6000                 EEStart:        fdb     $6000           ; starting address of program storage EEPROM
   34 FFC6.2000                 EESize:         fdb     $2000           ; size of the program storage EEPROM
   35 FFC8.1000                 IOBase:         fdb     $1000           ; Base Address of the I/O Registers
   36 FFCA.F424                 TimeVal:        fdb     62500           ; value used for generating 'Time' Interrupt
   37 FFCC.FF48                 UserInit:       fdb     IODevInit       ; Used to initialize console/other hardware.
   38 FFCE.4000                 DFLOPADR:       fdb     $4000           ; Address of flip-flop used to connect the HC11 SCI
   39                                                                   ; to the host port connector.
   40                           ;
   41                           ;
   42                           
   43      FFD6                           ORG    ROMBEG+ROMSIZE-42  ; START OF VECTOR TABLE.
   44 FFD6.00C4                           FDB    SCISS          ; SCI SERIAL SYSTEM
   45 FFD8.00C7                           FDB    SPITC          ; SPI TRANSFER COMPLETE
   46 FFDA.00CA                           FDB    PACCIE         ; PULSE ACCUMULATOR INPUT EDGE
   47 FFDC.00CD                           FDB    PACCOVF                ; PULSE ACCUMULATOR OVERFLOW
   48 FFDE.00D0                           FDB    TIMEROVF               ; TIMER OVERFLOW
   49 FFE0.00D3                           FDB    TOC5           ; TIMER OUTPUT COMPARE 5
   50 FFE2.00D6                           FDB    TOC4           ; TIMER OUTPUT COMPARE 4
   51 FFE4.00D9                           FDB    TOC3           ; TIMER OUTPUT COMPARE 3
   52 FFE6.00DC                           FDB    TOC2           ; TIMER OUTPUT COMPARE 2
   53 FFE8.00DF                           FDB    TOC1           ; TIMER OUTPUT COMPARE 1
   54 FFEA.00E2                           FDB    TIC3           ; TIMER INPUT CAPTURE 3
   55 FFEC.00E5                           FDB    TIC2           ; TIMER INPUT CAPTURE 2
   56 FFEE.00E8                           FDB    TIC1           ; TIMER INPUT CAPTURE 1
   57 FFF0.00EB                           FDB    REALTIMI               ; REAL TIME INTERRUPT
   58 FFF2.00EE                           FDB    IRQI           ; IRQ INTERRUPT
   59 FFF4.00F1                           FDB    XIRQ           ; XIRQ INTERRUPT
   60 FFF6.00F4                           FDB    SWII           ; SOFTWARE INTERRUPT
   61 FFF8.00F7                           FDB    ILLOP          ; ILLEGAL OPCODE TRAP
   62 FFFA.00FA                           FDB    COP            ; WATCH DOG FAIL
   63 FFFC.00FD                           FDB    CMF            ; CLOCK MONITOR FAIL
   64 FFFE.ED72                           FDB    POWERUP                ; RESET
   65                           *
   66                           *
   67                           *
*** END   INCLUDE FILE: VECTORS.ASM *** (RESUMING FILE: BASIC11.ASM)
   23                           ;        opt    nol
   24      E003                         END     MAIN

-----------------------------------------------------------

         S E G M E N T   U S A G E   R E P O R T

Segment  Start   End    Size  CodObj  DatObj  TotObj  Lines
-------  -----  -----  -----  ------  ------  ------  -----
ROM      $0000  $FFFF $10000   $1AFF   $04E5   $1FE4   7215

Summary  $E000  $FFFF  $2000   $1AFF   $04E5   $1FE4   7215

-----------------------------------------------------------

         O V E R A L L   M E M O R Y   U S A G E

Total RAM   size:    208   $00D0    0.20 KB
Total CODE  size:   6911   $1AFF    6.75 KB   (3366 instructions)
Total DATA  size:   1253   $04E5    1.22 KB
Total IMAGE size:   8164   $1FE4    7.97 KB

Lowest address  :  57344   $E000
Highest address :  65535   $FFFF
Address Range   :   8192   $2000    8.00 KB   (Used Range: 99.66%)

Number of INCLUDE files: 16

Assembled 7215 lines (No Errors, Warnings: OFF)

                       *** End of BASIC11.ASM listing ***
